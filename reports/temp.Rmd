---
title: "R Notebook"
output: html_notebook
---
```{r}
library(dplyr)
library(ggplot2)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
library(stringr)
library(parallel)
library(ggpubr)
library(DEoptim)
library(marqLevAlg)
```

```{r}
parameters_tsukushi <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156)

time_range <- seq(0, 20, by = 1e-3)
```


```{r}
source(here("functions/chabaudi_si_clean.R"))
```

# trying DE optim. works although slow
```{r}
res <- DEoptim(
    fn = chabaudi_si_clean, 
    control = list(trace = 1, parallelType = 1),
    lower = c(-1, -100, -1000, -5000),
    upper = c(1, 100, 1000, 5000),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = time_range,
    cue = "I",
    log_cue = "log10",
    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
    solver = "vode",
    neg = T)
```

# trying DE optim coinfection
```{r}
source(here("functions/co_infection_opt_do.R"))
source(here("functions/chabaudi_ci_clean.R"))
source(here("functions/co_infection_opt_alt.R"))
```

# Ig alone logged
note started at 0.5x4.
```{r}
ci_Ig_log_opt <- co_infection_opt_do(parameters_cr = c(0.359066,  -65.485796,  344.211487, -438.589440),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "Ig1",
                             cue_2 = "Ig2",
                             cue_range_1 = seq(0, log10(6*(10^6)), by = log10(6*(10^6))/5000),
                             cue_range_2 = seq(0, log10(6*(10^6)), by = log10(6*(10^6))/5000),
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10",
                             neg = T)
```

# trying alt where last round of optimization is started with 0.5 x 4
```{r}
ci_Ig_log_opt <- co_infection_opt_alt(parameters_cr = c(35.6294,	-65.6898,	-11.5609,	-52.0779),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "Ig1",
                             cue_2 = "Ig2",
                             cue_range_1 = seq(0, log10(6*(10^6)), by = log10(6*(10^6))/5000),
                             cue_range_2 = seq(0, log10(6*(10^6)), by = log10(6*(10^6))/5000),
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")

# 2.189146 -5.450051  4.543525 -9.356682

# testing dynamics
test <- chabaudi_ci_clean(
  parameters_cr_1 = c( 2.189146, -5.450051,  4.543525, -9.356682),
                  parameters_cr_2 = c(2.189146, -5.450051,  4.543525, -9.356682),
                  immunity = "tsukushi",
                  parameters = parameters_tsukushi,
                  cue_1 = "Ig1",
                  cue_2 = "Ig2",
                  cue_range_1 = seq(0, log10(6*10^6), by = log10(6*10^6)/5000),
                  cue_range_2 = seq(0, log10(6*10^6), by = log10(6*10^6)/5000),
                  log_cue_1 = "log10",
                  log_cue_2 = "log10",
                  solver = "vode",
                  time_range = seq(0, 30, 0.001),
                  dyn = T)

# run preliminary random test. create df first. do 50 rep
test.df <- ci_opt.df[5,]
test.df$var1 <- 2.189146
test.df$var2 <- -5.45005
test.df$var3 <- 4.543525
test.df$var4 <- -9.356682
```

```{r}
check_ci_opt <- function(df, n = 1000){
  
  # get label
  label <- df$label_3
  
  # cluster initialization
  cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
  registerDoParallel(cl)
  registerDoRNG(137)
  
  res <- foreach(i= 1:n, .packages = c("doParallel", "doRNG", "deSolve", "splines2", "stringr", "dplyr", "tidyr", "crone", "here")) %dorng% {
  # source function
  source(here("functions/chabaudi_ci_clean.R"))
    
  # parameters 
  parameters_tsukushi <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156)
  
  # read in df info
  if(stringr::str_detect(df$cue, "-i")){cue_1 = paste0(gsub("*-i", "", df$cue), "1")}
  if(stringr::str_detect(df$cue, "-i", negate = T)){cue_1 = df$cue}
  if(stringr::str_detect(df$cue, "-i")){cue_2 = paste0(gsub("*-i", "", df$cue), "2")}
  if(stringr::str_detect(df$cue, "-i", negate = T)){cue_2 = df$cue}
  if(stringr::str_detect(df$log, "log")){log_1 = "log10"}
  if(stringr::str_detect(df$log, "none")){log_1 = "none"}
  if(stringr::str_detect(df$log, "log")){log_2 = "log10"}
  if(stringr::str_detect(df$log, "none")){log_2 = "none"}
  par <- c(df$var1, df$var2, df$var3, df$var4)
  cue_range <- seq(df$low, df$high, by = df$by)
  
  # generate random par, bounds for parameters based on previous determined bounds
  par1 <- runif(1, -1, 1)
  par2 <- runif(1, -100, 100)
  par3 <- runif(1, -1000, 10000)
  par4 <- runif(1, -5000, 5000)
  
  par_rand <- c(par1, par2, par3, par4)
  
  # get fitness. 20 days simulation to cut down on computation time
  fitness <- chabaudi_ci_clean(parameters_cr_1 = par,
                  parameters_cr_2 = par_rand,
                  immunity = "tsukushi",
                  parameters = parameters_tsukushi,
                  cue_1 = cue_1,
                  cue_2 = cue_2,
                  cue_range_1 = cue_range,
                  cue_range_2 = cue_range,
                  log_cue_1 = log_1,
                  log_cue_2 = log_2,
                  solver = "vode",
                  time_range = seq(0, 30, by = 1e-3),
                  dyn = F)
  }
  stopCluster(cl)
  
  ## get fitness.df
  fitness.df <- do.call("rbind", res)

  ## rbind
  fitness.df <- as.data.frame(cbind(fitness.df, label = rep(label, nrow(fitness.df))))
  
  return(fitness.df)
}
```


#-----------------------#
# code for invasion analysis of ci
#-----------------------#
```{r}
ci_invasion_analysis <- function(df){
  
  # get mutant info (invader)
  mut_par <- c(df$var1, df$var2, df$var3, df$var4) ## mutant parameter
  if(stringr::str_detect(df$cue, "-i")){mut_cue = paste0(gsub("*-i", "", df$cue), "1")} ## mutant cue
  if(stringr::str_detect(df$cue, "-i", negate = T)){mut_cue = df$cue} ## mutant cue
  if(stringr::str_detect(df$log, "log")){mut_log = "log10"} ## mutant log
  if(stringr::str_detect(df$log, "none")){mut_log = "none"} ## mutant log
  mut_cue_range <- seq(df$low, df$high, by = df$by) ## mutant cue range
  
  # get resident info (being invaded)
  res_par <- c(df$var1_2, df$var2_2, df$var3_2, df$var4_2) ## resident parameter
  if(stringr::str_detect(df$cue_2, "-i")){res_cue = paste0(gsub("*-i", "", df$cue_2), "1")} ## resident cue
  if(stringr::str_detect(df$cue_2, "-i", negate = T)){res_cue = df$cue_2} ## resident cue
  if(stringr::str_detect(df$log_2, "log")){res_log = "log10"} ## resident log
  if(stringr::str_detect(df$log_2, "none")){res_log = "none"} ## resident log
  res_cue_range <- seq(df$low_2, df$high_2, by = df$by_2) ## resident cue range

  # get ids
  mut_id <- df$id
  res_i <- id$id_2
  
  # one way optimization
  ## start cluster
  cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
  
  # start optimization LFBGS
  res <- optimParallel(
    par = mut_par,
    fn = chabaudi_ci_clean, 
    control = list(trace = 6, fnscale = -1),
    parameters_cr_2 = res_par,
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 1e-3),
    cue_range_1 <- mut_cue_range,
    cue_range_2 <- res_cue_range,
    cue_1 = mut_cue,
    cue_2 = res_cue,
    log_cue_1 = mut_log,
    log_cue_2 = res_log,
    solver = "vode")
  
  # close cluster
  stopCluster(cl)
  
  # get model output
  fitness <- res$value ## fitness difference between mutant and residence
  mut_opt_par <- res$par ## optimized parameters of mutant
  
  # produce output
  output <- cbind.data.frame(mut_id = mut_id, res_id = res_id, 
                             fitness = fitness, 
                             mut_var1 = df$var1, mut_var2 = df$var2, mut_var3 = df$var3, mut_var4 = df$var4,
                             res_var1 = df$var1_2, res_var2 = df$var2_2, res_var3 = df$var3_2, res_var4 = df$var4_2,
                             mut_var1_opt = mut_opt_par[1], mut_var2_opt = mut_opt_par[2], mut_var3_opt = mut_opt_par[3], mut_var4_opt = mut_opt_par[4])
  
  return(output)
  
}
```

```{r}
source(here("functions/co_infection_opt_alt2.R"))
ci_Ig1_Ig2_log_opt <- co_infection_opt_alt(parameters_cr = c(22.08106, -47.95592, -12.97148,  19.60815),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "Ig1+Ig2",
                             cue_2 = "Ig1+Ig2",
                             cue_range_1 = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                             cue_range_2 = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")

# going to another local optimam
# 22.08106 -47.95592 -12.97148  19.60815


# trying DE
source(here("functions/co_infection_opt_do.R"))
ci_Ig1_Ig2_log_opt <- co_infection_opt_do(parameters_cr = c(22.08106, -47.95592, -12.97148,  19.60815),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "Ig1+Ig2",
                             cue_2 = "Ig1+Ig2",
                             cue_range_1 = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                             cue_range_2 = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10",
                             neg = T)


test <- chabaudi_ci_clean(
  parameters_cr_1 = c(75.73915, -128.01549,  -41.16782,  -96.21549),
                  parameters_cr_2 = rep(2,4),
                  immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "Ig1+Ig2",
                             cue_2 = "Ig1+Ig2",
                             cue_range_1 = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                             cue_range_2 = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10",
  dyn = T)

ggplot() +
  geom_line(data = test, aes(x = time, y = value, color = strain)) +
  facet_wrap(~variable_alt, scales = "free") +
  theme_bw()

```

#---------------------#
# continued LBFGS optimization for DE
#---------------------#
Ensure that our DE parameters are as good as it gets!
```{r}
source(here("functions/chabaudi_ci_clean.R"))
source(here("functions/co_infection_opt.R"))
source(here("functions/co_infection_opt_do.R"))
max(time_range)
```

# total gametocyte
```{r}
ci_G1_G2_opt <- co_infection_opt_alt(parameters_cr = c(1.000000,  -21.911779 , 338.362460,-4999.999660),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "G1+G2",
                             cue_2 = "G1+G2",
                             cue_range_1 = seq(0, 6*(10^4), (6*(10^4))/5000),
                             cue_range_2 = seq(0, 6*(10^4), (6*(10^4))/5000),
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")

# 1.47335 -40.5887 455.327 -4999.26 (0.2977774)
# 2.37351 -357.796 447.259 -4999.44 (0.6773614)
# 0.401419 -48.5977 781.709 -4971.52 (3.606348)
# 1.07918 -47.6794 781.757 -4971.52 (2.704072)
# 1.27179 -48.4816 781.586 -4971.53 (0.1746626)
# 1.93922 -137.227 777.853 -4971.79 (0.2672778)
# 1.86641 -863.926 776.093 -4972.56 (0.7118306)(CANNOT outcompete original)
# 1.60268 -863.927 776.093 -4972.56 (0.05445573) 
# 0.577886 -58.8971 778.208 -4972.96 ( 3.984319)
# 1.1498 -49.127 778.772 -4972.92 (2.203271)
# n1.54544 -69.2024 775.987 -4973.35 (0.1328694)
# 3.21813 -767.445 766.282 -4973.91 ( 0.7715941) -> stuck at 0

# check end parameter results with original. noone of the lbfgs is good. Let's just stick with the original one
test <- chabaudi_ci_clean(
  parameters_cr_1 = c(1.000000,  -21.911779 , 338.362460,-4999.999660),
  parameters_cr_2 = c(1.86641, -863.926, 776.093, -4972.56),
                  immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "G1+G2",
                             cue_2 = "G1+G2",
                             cue_range_1 = seq(0, 6*(10^4), (6*(10^4))/5000),
                             cue_range_2 = seq(0, 6*(10^4), (6*(10^4))/5000),
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")

test
```

#----------------------------#
DE optimization for cycling cues
#----------------------------#
# total asexual iRBC log10
```{r}
ci_I1_I2_opt <- co_infection_opt_do(parameters_cr = rep(0.5,4),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "I1+I2",
                             cue_2 = "I1+I2",
                             cue_range_1 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                             cue_range_2 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none",
                             neg = T)

# 0.9999999   -9.1650326  -71.7214007 4998.7943898 
```

# total sexual iRBC log10
```{r}
ci_Ig1_Ig2_opt <- co_infection_opt_do(parameters_cr = rep(0.5, 4),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "Ig1+Ig2",
                             cue_2 = "Ig1+Ig2",
                             cue_range_1 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                             cue_range_2 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none",
                             neg = T)

 # 1.000000  -32.831645  378.108931-4999.999969
```

#-------------------------#
# validation for gametocyte total
#--------------------------#
This is the 0 conversion strategy one. Need to validate further with 5000 randomized parameters
```{r}
g_tot_log.df <- ci_opt.df %>% filter(label == "Total\ngametocyte log10")

g_tot_log.cf <- check_ci_opt(g_tot_log.df, n = 5000)
```


#----------------------------#
# running invasion analysis
#----------------------------#
```{r}
ci_cue_pair.ls3 <- ci_cue_pair.ls3[11:length(ci_cue_pair.ls3)]
```


```{r}
surveillance::plapply(ci_cue_pair.ls3 , ci_invasion_analysis)

```

# bugged out at 19
it seems that the G1+G2 log residence strategy is returning NA tau (basically meaning 0 transmission potential). Changed chabaudi ci clean such that is fitness difference is NA or Inf/-Inf, we automatically output 0 as transmission potential
```{r}
source(here("functions/chabaudi_ci_clean.R"))
ci_cue_pair.ls4 <- ci_cue_pair.ls3[19:length(ci_cue_pair.ls3)]

# for this, we need to turn default off, starting at original position. 
ci_invasion_analysis(ci_cue_pair.ls4[[1]], default = F)
ci_cue_pair.ls5 <- ci_cue_pair.ls3[20:length(ci_cue_pair.ls3)]
surveillance::plapply(ci_cue_pair.ls5 , ci_invasion_analysis)
```

# rerun SEVERAL dataframes because short time frame of optimization. sum_none vs G1+G2 log. cannot optimizes. Trying to set default to F. 
```{r}
sum_non_G1_G2_log <- ci_cue_pair.ls3[[26]]
G_log_G1_G2_log <- ci_cue_pair.ls3[[15]]
G_none_G1_G2_log <- ci_cue_pair.ls3[[16]]
Ig_none_G1_G2_log <- ci_cue_pair.ls3[[22]]
Ig_log_G1_G2_log<- ci_cue_pair.ls3[[21]]
G1_G2_none_G1_G2_log <- ci_cue_pair.ls3[[17]]

ci_invasion_analysis(sum_non_G1_G2_log, default = F)
ci_invasion_analysis(G_log_G1_G2_log, default = F)
ci_invasion_analysis(G_none_G1_G2_log, default = F)
ci_invasion_analysis(Ig_none_G1_G2_log, default = F)
ci_invasion_analysis(Ig_log_G1_G2_log, default = F)

ci_invasion_analysis(G1_G2_none_G1_G2_log, default = F)
```

# getting the rest of the newly optimized parameters. 54 new runs in total
```{r}
# getting the newer iteration of ci_opt
ci_opt_new.df <- read.csv(here("data/ci_opt.csv"))
cue_range_new.df <- read.csv(here("data/cue_range.csv"))

# get unique id and join with cue range df
ci_cue_new.df <- ci_opt_new.df %>% 
  mutate(id = paste0(cue, "_", log)) %>% 
  left_join(select(cue_range_new.df, c(id, low, high, by)), by = c("id" = "id"))

# get all pairwise combinations
ci_cue_pair_new.df <- ci_cue_new.df %>% 
  setNames(paste0(names(ci_cue_new.df), '_2')) %>% 
  tidyr::crossing(ci_cue_new.df, .name_repair = "check_unique") %>% 
  janitor::clean_names()

# filter out all the same cue optimization
ci_cue_pair_new.df2 <- ci_cue_pair_new.df %>% filter(id!=id_2) %>% mutate(id_3 = paste0(id, id_2))

# all all new df that is not present in original. we have 2 more cues, which amounts to 28 df?
new_cue_pair.df <- ci_cue_pair_new.df2 %>% anti_join(ci_cue_pair.df3 %>% mutate(id_3 = paste0(id, id_2)), by = "id_3") 

new_cue_pair.ls <- split(new_cue_pair.df, seq(nrow(new_cue_pair.df)))

surveillance::plapply(new_cue_pair.ls , ci_invasion_analysis)

```

# rerun some of the GI+G2 log optimization
```{r}
rerun.df <- ci_cue_pair_new.df2 %>% 
  filter(id_2 == "G1+G2_log") %>% 
  filter(id == "Ig1+Ig2_none" | id == "I1+I2_none" | id == "G1+G2_none" | id == "Ig-i_none" | id == "Ig-i_log")

rerun.ls <- split(rerun.df, seq(nrow(rerun.df)))

surveillance::plapply(rerun.ls , function(x){ci_invasion_analysis(x, default = F)})


```

# certain fitness optimized is lower than static. Need to rerun those. 28 in total
```{r}
ci_comp_static.df <- read.csv(here("data/ci_comp_static.csv"))
# get reverse. Here, we will simply multiple fitness difference by -1
ci_comp_static.df2 <- select(ci_comp_static.df, id_1_alt, id_2_alt, fitness_diff)
names(ci_comp_static.df2) <- c("id_2_alt", "id_1_alt","fitness_diff")
ci_comp_static.df2$fitness_diff <- ci_comp_static.df2$fitness_diff*-1

invasion.df2 <- read.csv(here("data/ci_invasion_final.csv"))

# left join and filter out those that have a fitness (optimized) that is less than fitness diff (unoiptimized)
static_invasion.df <- left_join(ci_comp_static.df, invasion.df2, by = c("id_1_alt" = "mut_alt",
                                                          "id_2_alt"= "res_alt")) %>% 
  filter(fitness<fitness_diff) %>% 
  select(mut_id, res_id)

static_invasion.df2 <- left_join(static_invasion.df, ci_cue_pair.df, by = c("mut_id" = "id", "res_id" = "id_2")) %>% 
  mutate(label_1 = case_when(
  cue == "I-i" ~ "Asexual iRBC",
  cue == "I1+I2" ~ "Total asexual\niRBC",
  cue == "Ig-i" ~ "Sexual iRBC",
  cue == "Ig1+Ig2" ~ "Total sexual\niRBC",
  cue == "sum" ~ "Total iRBC",
  cue == "G-i" ~ "Gametocyte",
  cue == "G1+G2" ~ "Total\ngametocyte",
  cue == "R" ~ "RBC"
)) %>% 
  mutate(label_2 = case_when(
    log == "log" ~ "log10",
    log == "none" ~ ""
  )) %>% 
  mutate(label_3 = paste(label_1, label_2),
         id = paste0(cue, "_", log))

static_invasion.df2
# rerun withd efault turned off
static_invasion.ls <- split(static_invasion.df2, seq(nrow(static_invasion.df2)))
surveillance::plapply(static_invasion.ls, function(x){ci_invasion_analysis(x, default = F)})

```

# redo optimization using default = F (all stored in ci_invasion_2 folder) 
```{r}
ci_cue_pair.df3 <- ci_cue_pair.df %>% filter(id!=id_2)
ci_cue_pair.ls <- split(ci_cue_pair.df3, seq(nrow(ci_cue_pair.df3)))
length(ci_cue_pair.ls)
surveillance::plapply(ci_cue_pair_new.ls, function(x){ci_invasion_analysis(x, default = F)})
```

#-------------------------------------#
validate single infection data
#-------------------------------------_#
```{r}

si_opt.df2 <- read.csv(here("job_scripts/si_opt2.csv"))
si_opt.ls <- split(si_opt.df2, seq(nrow(si_opt.df2)))

validate <- function(df){
  # cluster initialization
  cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
  registerDoParallel(cl)
  registerDoRNG(137)
  
  res <- foreach(i= 1:1000, .verbose = T, .packages = c("doParallel", "doRNG", "deSolve", "splines2", "stringr", "dplyr", "tidyr", "crone", "here")) %dorng% {
    # generate random par, bounds for parameters based on previous determined bounds
    par1 <- runif(1, -1, 1)
    par2 <- runif(1, -100, 100)
    par3 <- runif(1, -1000, 10000)
    par4 <- runif(1, -5000, 5000)
    
    # get random parameters
    par_rand <- c(par1, par2, par3, par4)
    
    # get log
    if(df$log == "log"){log = "log10"}
    if(df$log == "none"){log = "none"}
    
    # get cue_range
    cue_range <- seq(df$low, df$high, by = df$by)
    
    # get fitness. 20 days simulation to cut down on computation time
   fitness <- chabaudi_si_clean(parameters_cr = par_rand,
                                parameters= parameters_tsukushi,
                               immunity = "tsukushi",
                               time_range = seq(0,30,0.001),
                                 cue = df$cue,
                                 log_cue = log,
                                 cue_range = cue_range,
                                 dyn = F)
    
    print(fitness)
  }
  
  ## get fitness.df
  fitness.df <- do.call("rbind", res)
  ## rbind
  fitness.df <- as.data.frame(cbind(fitness.df, 
                                    cue = rep(df$cue, nrow(fitness.df)),
                                    log = rep(df$log, nrow(fitness.df)),
                                    id = rep(df$id, nrow(fitness.df))))
  
  filename <- paste0("si_", df$id, "_cf.csv")
  
  ## write.csv
  write.csv(fitness.df, here(paste0("data/si_validation/", filename)))
}


# cluster initialization

surveillance::plapply(si_opt.ls, validate)



```








