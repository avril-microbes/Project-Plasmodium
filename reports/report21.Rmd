---
title: "R Notebook"
output: html_notebook
---

Exploring dual-cue approach
```{r}
library(dplyr)
library(ggplot2)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
library(stringr)
library(parallel)
library(ggpubr)
library(microbenchmark)
library(profvis)
library(RANN)
```

```{r}
parameters_tsukushi <- c(R1 = 8.89*(10^6), # slightly higher
                lambda = 3.7*(10^5),
                mu = 0.025, 
                p = 8*(10^-6), # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156)

I_range_none <- seq(0, 6*(10^6), by = (6*(10^6))/500)
I_range_log <- seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/500)
G_range_none <- seq(0, 6*(10^4), by = (6*(10^4))/500)
G_range_log <- seq(0, log10(6*(10^4)), by = (log10(6*(10^4)))/500)
```

# testing out mgcv dual cue spline surface. looks good.
## note that if we go with ti, than we have only interactions between the 2 cues whereas te includes both main effect and interaction. ti gives us 5 parameters to optimze whereas te gives us 9. We should compare the two
```{r}
source(here("functions/chabaudi_si_clean.R"))

# smaller division
cue_range <- seq(0, 6*(10^6), by = (6*(10^6))/500)
cue_range_b <- seq(0, 6*(10^4), by = (6*(10^4))/500)
parameters_cr <- rep(-0.5,9)

cr_grid <- expand.grid(cue_range, cue_range_b)
    ## rename
    names(cr_grid) <- c("cue_range", "cue_range_b")
    ## create dummy y
    dummy_y <- runif(length(cue_range_b), 0, 1)
    ## put together df
    dummy_df <- data.frame(cue_range, cue_range_b, dummy_y)
    ## gam model
    dummy_cr.mod <- mgcv::gam(dummy_y ~ te(cue_range, cue_range_b, 
                                           bs = c("tp", "tp")
                                           k = c(3,3)), 
                              data = dummy_df, 
                              method = "REML")
    ## assign parameters
    dummy_cr.mod$coefficients <- parameters_cr
    
    # exponential transformation to limit conversion rate to between 0 and 1
    cr_fun <- function(cue_1, cue_2){
      res <- exp(-exp(mgcv::predict.gam(dummy_cr.mod, 
                                        newdata = data.frame("cue_range" = cue_1,
                                                             "cue_range_b" = cue_2))))
      return(res)
    }
    

```



# cutting down computational time
```{r}
source(here("functions/chabaudi_si_clean.R"))
source(here("functions/test.R"))

# each run takes around 1 minute (cr_fun) (100 divisions)
# switching to nn2 takes 145 seconds
# increasing divisons to 500 using predict.gam takes still around 57 seconds. So increasing to 500 doesn't seem like a bad idea
system.time(test(parameters_cr = rep(0.5, 5),
       immunity = "tsukushi",
       parameters = parameters_tsukushi,
       time_range = seq(0, 20, 0.001),
       cue = "I",
       cue_b = "G",
       cue_range = I_range_log,
       cue_range_b = G_range_log,
       solver = "vode",
       log_cue = "log10",
       log_cue_b = "log10"
       ))


```

# making shit go fast! Need to cut down on time to get cr from function
```{r}
cue_range <- I_range_log
cue_range_b <- G_range_log
cr_grid <- expand.grid(cue_range, cue_range_b)

## rename
names(cr_grid) <- c("cue_range", "cue_range_b")
## create dummy y
dummy_y <- runif(length(cue_range_b), 0, 1)
## put together df
dummy_df <- data.frame(cue_range, cue_range_b, dummy_y)
## gam model
dummy_cr.mod <- mgcv::bam(dummy_y ~ ti(cue_range, cue_range_b, 
                                           k = c(3,3)), 
                              data = dummy_df)
## assign parameters
dummy_cr.mod$coefficients <- rep(0.5,5)
    
# original function of getting cr
cr_fun <- function(cue_1, cue_2){
      exp(-exp(mgcv::predict.bam(dummy_cr.mod, 
                                 newdata = data.frame("cue_range" = cue_1,
                                                             "cue_range_b" = cue_2),
                                 n.threads = 3)))
  }
    

cr_res <- exp(-exp(mgcv::predict.gam(dummy_cr.mod, 
                                        newdata = cr_grid)))
cr_df <- cbind(cr_grid, cr_res)

cue_1 <- 1
cue_2 <- 0.5

# another function for nearnest neighoubrs
nn_fun <- function(cue_1, cue_2){
  cr_df[nn2(data=cr_grid, query = cbind(cue_1, cue_2), k=1, treetype= "kd",
            searchtype = "priority")[[1]],3]
}

nn_fun2 <- function(cue_1, cue_2){
  cr_df[FNN::knnx.index(data=cr_grid, query = cbind(cue_1, cue_2), k = 1, algorithm = "kd_tree"),3]
}


# very similar
cr_fun(1,1)
nn_fun(1,1)
nn_fun2(1,1)

# gam.predict is faster
microbenchmark(cr_fun(1,1))
microbenchmark(nn_fun(1,1))
microbenchmark(nn_fun2(1,1))
```
# sanity checkz
```{r}
source(here("functions/test.R"))
# switching between cue and cue_b. should not make a difference
# 4.469067
test(parameters_cr = rep(0.5, 5),
       immunity = "tsukushi",
       parameters = parameters_tsukushi,
       time_range = seq(0, 20, 0.01),
       cue = "I",
       cue_b = "G",
       cue_range = I_range_log,
       cue_range_b = G_range_log,
       solver = "vode",
       log_cue = "log10",
       log_cue_b = "log10"
       )

# 4.469066. good
test(parameters_cr = rep(0.5, 5),
       immunity = "tsukushi",
       parameters = parameters_tsukushi,
       time_range = seq(0, 20, 0.01),
       cue = "G",
       cue_b = "I",
       cue_range = G_range_log,
       cue_range_b = I_range_log,
       solver = "vode",
       log_cue = "log10",
       log_cue_b = "log10"
       )

# short time steps vs longer time steps. barely made a difference
# 4.46904
test(parameters_cr = rep(0.5, 5),
       immunity = "tsukushi",
       parameters = parameters_tsukushi,
       time_range = seq(0, 20, 0.001),
       cue = "I",
       cue_b = "G",
       cue_range = I_range_log,
       cue_range_b = G_range_log,
       solver = "vode",
       log_cue = "log10",
       log_cue_b = "log10"
       )

# changing logs on cue_b
# 6.20639
test(parameters_cr = rep(0.5, 5),
       immunity = "tsukushi",
       parameters = parameters_tsukushi,
       time_range = seq(0, 20, 0.01),
       cue = "I",
       cue_b = "G",
       cue_range = I_range_log,
       cue_range_b = G_range_none,
       solver = "vode",
       log_cue = "log10",
       log_cue_b = "none"
       )

# changing logs on cue
# 5.110873
test(parameters_cr = rep(0.5, 5),
       immunity = "tsukushi",
       parameters = parameters_tsukushi,
       time_range = seq(0, 20, 0.01),
       cue = "I",
       cue_b = "G",
       cue_range = I_range_none,
       cue_range_b = G_range_log,
       solver = "vode",
       log_cue = "none",
       log_cue_b = "log10"
       )

# checing single cue infection. same 
## 4.724804
test(parameters_cr = rep(0.5, 4),
       immunity = "tsukushi",
       parameters = parameters_tsukushi,
       time_range = seq(0, 20, 0.01),
       cue = "I",
       cue_range = I_range_none,
       solver = "vode",
       log_cue = "none",
       )
# 4.724804
chabaudi_si_clean(parameters_cr = rep(0.5, 4),
       immunity = "tsukushi",
       parameters = parameters_tsukushi,
       time_range = seq(0, 20, 0.01),
       cue = "I",
       cue_range = I_range_none,
       solver = "vode",
       log_cue = "none",
       )
```

#--------------------------------------------------#
# remaking of co-infection reaction norm
#--------------------------------------------------#
```{r}
source(here("functions/chabaudi_ci_clean.R"))
source(here("functions/par_to_df.R"))
```

# function for getting conversion rate reaction norm and dynamics
```{r}
get_ci_dyn <- function(df){
  
  # get heavisde transformation
  heaviside_trans <- function(cue_range, max){
    crone::heaviside(cue_range)*(cue_range)+(crone::heaviside(cue_range-max)*(max-cue_range))
}
  
  # read in df info
  cue_1 <- ifelse(stringr::str_detect(df$cue, "-i"), 
                  gsub("*-i", "1", df$cue),
                  df$cue)
  
  cue_2 <- ifelse(stringr::str_detect(df$cue, "-i"), 
                  gsub("*-i", "2", df$cue),
                  df$cue)
  
  log <- ifelse(stringr::str_detect(df$log, "log"),
                "log10", "none")
  
  # get parameter
  par <- c(df$var1, df$var2, df$var3, df$var4)
  cue_range <- seq(df$low, df$high, by = df$by)
  label <- df$label
  
  # get dynamics
  dyn <- chabaudi_ci_clean(parameters_cr_1 = par,
                  parameters_cr_2 = par,
                  immunity = "tsukushi",
                  parameters = parameters_tsukushi,
                  cue_1 = cue_1,
                  cue_2 = cue_2,
                  cue_range_1 = cue_range,
                  cue_range_2 = cue_range,
                  log_cue_1 = log,
                  log_cue_2 = log,
                  solver = "vode",
                  time_range = seq(0, 30, 0.001),
                  dyn = T)
  
    dyn2 <- data.frame(dyn, label = rep(label, nrow(dyn)))

  # get reaction norm
  rn <- par_to_df(par = par, cue_range = cue_range)

  # get rug
  ## if + in cue, need to filter out those variables and add together
  if(stringr::str_detect(cue_1, "\\+")){
    cue_split <- stringr::str_split(string = cue_1, pattern = "\\+", simplify = T)
    ## get the two cues 
    cue_temp_1 <- cue_split[[1]]
    cue_temp_2 <- cue_split[[2]]
    
    ## filter dyn
    rug <- dyn2 %>% 
      filter(variable == cue_temp_1 | variable == cue_temp_2) %>% 
      dplyr::group_by(time) %>% 
      dplyr::mutate(sum = sum(value)) %>% 
      select(time, value = sum, label)
  }
  
  ## if sum
  if(cue_1 == "sum"){
    ## filter dyn
    rug <- dyn2 %>% 
      filter(variable == "I1" | variable == "I2" | variable == "Ig1" | variable == "Ig2") %>% 
      dplyr::group_by(time) %>% 
      dplyr::mutate(sum = sum(value)) %>% 
      select(time, value = sum, label)
  }
  
  # for simplified cue
  if(stringr::str_detect(cue_1, "\\+", negate = T) && cue_1 != "sum"){
    rug <- dyn2 %>% 
      dplyr::filter(variable == cue_1) %>% 
      dplyr::select(time, value, label)}
  
  # for logged, backtransform cue range of reaction norm 
  rn2 <- rn
  
  if(stringr::str_detect(log, "log")){rn2$cue_range <- 10^(rn2$cue_range)}

  # append label to reaction norm, dyn, and rug
  rn2 <- data.frame(rn2, label = rep(label, nrow(rn)))

  return(list(dyn2, rn2, rug))
}
```

# read in co_infection opt
```{r}
ci_opt.df <- read.csv(here("data/ci_opt.csv"))
cue_range_ci <- read.csv(here("data/cue_range_ci.csv"))

# join with cue range
ci_opt.df <- ci_opt.df %>% left_join(select(cue_range_ci, id, low, high, by), by = c("id" = "id"))

# split
ci_opt.ls <- split(ci_opt.df, seq(nrow(ci_opt.df)))

# loop
ci_opt.dyn <- lapply(ci_opt.ls, get_ci_dyn)

# bind together dynamics
dyn.ls <- lapply(ci_opt.dyn, function(x)x[[1]])
ci_dyn.df <- do.call(rbind, dyn.ls)
write_parquet(ci_dyn.df, here("data/ci_dyn/ci_dyn.parquet"))

rn.ls <- lapply(ci_opt.dyn, function(x)x[[2]])
ci_rn.df <- do.call(rbind, rn.ls)
write_parquet(ci_rn.df, here("data/ci_dyn/ci_rn.parquet"))

rug.ls <- lapply(ci_opt.dyn, function(x)x[[3]])
ci_rug.df <- do.call(rbind, rug.ls)
write_parquet(ci_rug.df , here("data/ci_dyn/ci_rug.parquet"))
```

# process reaction norm data
```{r}
# filter to restriction conversion rate reaction norm range to cue ranges that appear in rug
## change to Inf/-inf to NA
ci_rug_lim.df <- ci_rug.df %>% 
  group_by(label) %>% 
  summarise(min = min(value, na.rm = T)*0.9,
         max = max(value, na.rm = T)*1.1)

# filter ci_rn by limit
ci_rn_lim.df <- ci_rn.df %>% 
  left_join(ci_rug_lim.df) %>% 
  group_by(label) %>% 
  filter(cue_range <= max & cue_range >= min)

ci_rug_lim.df
```

# get in single infection reaction norm to match
```{r}
si_opt.df <- read.csv(here("data/si_opt.csv"))
si_opt.df 
```

# plot
```{r}
ggplot() +
  geom_line(data = ci_rn_lim.df, aes(x = cue_range, y = cr)) +
  geom_rug(data = ci_rug.df, aes(x = value), color = "red") +
  facet_wrap(~label, scales = "free_x", ncol = 2) +
  theme_bw() +
  labs(y = "Conversion rate", x = "Cue range") +
  scale_x_continuous(labels = function(x) format(x, scientific = FALSE),
                     guide = guide_axis(check.overlap = TRUE)) + 
                    theme(axis.text.x = element_text(size = 7)) 
```










