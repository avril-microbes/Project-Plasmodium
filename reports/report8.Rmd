---
title: "report8"
output: html_document
---

# Load libraries
```{r}
library(deSolve)
library(splines)
library(optimParallel)
library(ggplot2)
library(ggpubr)
library(tidyr)
library(magrittr)
library(Rcpp)
library(microbenchmark)
library(GA)
library(here)
```

# Load functions
```{r}
source(here("functions/chabaudi_ci_opt_lag.R"))
source(here("functions/co_infection_opt.R"))
source(here("functions/par_to_df.R"))
source(here("functions/chabaudi_si_opt_lag.R"))
source(here("functions/total_parasite.R"))
source(here("functions/test.R"))
```

# define parameters
```{r}
parameters <- c(R1 = 8.5*10^6,
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 4*10^-6,
                alpha = 1, 
                alphag = 2, 
                beta = 10, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1)

parameters_tsukushi <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156,
                mud = -log(1-0.94)) # drug induced action. 94% death per day

time_range <- seq(0, 20, by = 1e-3)
I_range <- seq(0, 2.18*10^6, by = 1000) 
I_range_large <- seq(0, (3.7*10^5)*(8.5*10^6)/((3.7*10^5)-0.025*(8.5*10^6)), by = 1000) 
I_range_mid <- seq(0, 5*10^6, by = 1000)
I_range_mid2 <- seq(0, 4*10^6, by = 1000)
I_range_mid4 <- seq(0, 6*10^6, by = (6*10^6)/5000)

# logged counterpart
I_range_mid2_log <- seq(0, log(4*10^6), by = log(4*10^6)/5000)
I_range_mid3_log <- seq(0, log(5*10^6), by = log(5*10^6)/5000)
I_range_mid4_log <- seq(0, log(6*10^6), by = log(6*10^6)/5000)
I_range_mid4_log10 <- seq(0, log10(6*10^6), by = log10(6*10^6)/5000)
I_range_large_log10 <- seq(0, log10((3.7*10^5)*(8.5*10^6)/((3.7*10^5)-0.025*(8.5*10^6))), by = log10((3.7*10^5)*(8.5*10^6)/((3.7*10^5)-0.025*(8.5*10^6)))/10000)
```


#-----------------------------#
# continue with dual axis optimization
#------------------------------#

# testing gam. Better! 
```{r}
library(mgcv)
# basic set up
cue_range <- seq(0,100,1)
cue_rangeb <- seq(0,1,0.01)
cr_grid <- expand.grid(cue_range, cue_rangeb)
names(cr_grid) <- c("cue_range", "cue_rangeb") # must have the same name!!!
y <- runif(length(cue_rangeb), 0, 1)

df <- data.frame(cue_range,cue_rangeb,y)

# run gam model with tensor product smooth. 3 basis spline for each variable. Tensor product smooth makes more sense for different unit variables.
mod3 <- mgcv::gam(y ~ te(cue_range, cue_rangeb, k = c(3,3)), data = df, method = "REML")
mod32 <- mgcv::gam(y ~ te(cue_range, cue_rangeb, k = c(3,3)), data = df, method = "REML")
mod4 <- mgcv::bam(y ~ te(cue_range, cue_rangeb, k = c(3,3)), data = df, method = "REML")

# assign coefficient. Takes 9!
mod3$coefficients <- rep(0.5, 9)
mod4$coefficients <- rep(0.5, 9)
mod32$coefficients <- rep(-1, 9)

# predict
cr_df3 <- data.frame(pred = mgcv::predict.gam(mod3, newdata = cr_grid), cr_grid)
cr_df32 <- data.frame(pred = mgcv::predict.gam(mod32, newdata = cr_grid), cr_grid)

# plot
ggplot() +
  geom_tile(data = cr_df3, aes(x = cue_range, y = cue_rangeb, fill = pred)) +
  viridis::scale_fill_viridis() +
  theme_bw() +
  theme(legend.position="bottom")
vis.gam(mod3, c("cue_range", "cue_rangeb"), plot.type = "contour")

ggplot() +
  geom_tile(data = cr_df32, aes(x = cue_range, y = cue_rangeb, fill = pred)) +
  viridis::scale_fill_viridis() +
  theme_bw() +
  theme(legend.position="bottom")
vis.gam(mod32, c("cue_range", "cue_rangeb"), plot.type = "contour")

# write function for later
cr <- function(mod, cue_1, cue_2){
  res <- 
mgcv::predict.gam(mod, newdata = data.frame("cue_range"=cue_1,"cue_rangeb"=cue_2))
  return(res)
}

cr2 <- function(mod, cue_1, cue_2){
  res <- predict(mod, newdata = data.frame("cue_range"=cue_1,"cue_rangeb"=cue_2))
  return(res)
}


cr3 <- function(mod, cue_1, cue_2){
  res <- predict(mod, newdata = data.frame("cue_range"=cue_1,"cue_rangeb"=cue_2))
  return(res)
}

cr5 <- function(mod, cue_1, cue_2){
  df <- data.frame("cue_range"=cue_1,"cue_rangeb"=cue_2)
  res <- predict(mod, newdata = df)
  return(res)
}

cr6 <- function(mod, cue_1, cue_2){
  res <- exp(-exp(predict(mod, newdata = data.frame("cue_range"=cue_1,"cue_rangeb"=cue_2))))
  return(res)
}


```

# trying to fasten the function
```{r}
# using mgcv to predict while double exponentiating it
cr_df3 <- data.frame(pred = exp(-exp(mgcv::predict.gam(mod3, newdata = c(1,100)))), cr_grid)
cr(mod3, 0, 0.1)

# alternative approach. Using grid expand then thin plate interplating it
library(fields)
cr_df3 <- data.frame(pred = mgcv::predict.gam(mod3, newdata = cr_grid), cr_grid) # predict whole grid
x = data.matrix(cr_df3 %>% dplyr::select(cue_range, cue_rangeb))
Tps(x = x, Y = cr_df3$pred, df = 3)

# trying akima interpolation
library(akima)
n_interpolation <- 200
x <- cr_df3$cue_range
y <- cr_df3$cue_rangeb
z <- cr_df3$pred
int <- interp(x, y, z, xo=seq(min(x), max(x), length = n_interpolation),
                              yo=seq(min(y), max(y), length = n_interpolation),
                              linear = FALSE, extrap = TRUE)


# match closest one from dataframe?
## finer grid and get nearest result
cue_range <- seq(0,100,0.1)
cue_rangeb <- seq(0,1,0.001)
cr_grid <- expand.grid(cue_range, cue_rangeb)
names(cr_grid) <- c("cue_range", "cue_rangeb") 
cr_df4 <- data.frame(pred = mgcv::predict.gam(mod3, newdata = cr_grid), cr_grid) 

cr4 <- function(cue_1, cue_2){
  nearest_x <- cr_df4$cue_range[which.min(abs(cue_1 - cr_df4$cue_range))]
  nearest_y <- cr_df4$cue_rangeb[which.min(abs(cue_2 - cr_df4$cue_rangeb))]
  res <- cr_df4$pred[cr_df4$cue_range == nearest_x & cr_df4$cue_rangeb == nearest_y]
  return(res)
}

cr4(0,0.1)
cr(mod3, 0, 0.1)
cr2(mod3,0, 0.1)
cr(mod4, 0,0.1)

# bench mark speed
library(microbenchmark)
microbenchmark(cr(mod3, 0, 0.1),
               cr(mod4, 0,0.1))
```

# testing speed
```{r}
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
lag_si_IW_20.opt_tsukushi <- optimParallel(par = rep(0.5, 7),# new parameter search space
                      fn = chabaudi_si_opt_lag2, 
                      control = list(trace = 6, fnscale = -1),
                      immunity = "tsukushi",
                 parameters = parameters_tsukushi,
                 time_range = seq(0, 25, 1e-3),
                 df = 2,
                 cue = "I",
                 cue_b = "W",
                 cue_range = I_range_mid4_log10,
                 cue_range_b = seq(0, log10(5), by = log10(5)/5000),
                 solver = "vode",
                 log_cue = "log10",
                 log_cue_b = "none",
                 dual_cue = TRUE)
stopCluster(cl)

source(here("functions/test.R"))

test <- chabaudi_si_opt_lag2(parameters_cr = rep(0.5, 9),
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = seq(0, 25, 1e-3),
                             df = 3,
                             dual_cue = TRUE,
                             cue = "I",
                             cue_b = "W",
                             cue_range = seq(0, log10(6*10^6), by = log10(6*10^6)/5000), 
                             cue_range_b = seq(0, 2, by = 2/5000),
                             solver = "vode",
                             log_cue = "log10", 
                             log_cue_b = "none",
                             dyn = TRUE)


```

