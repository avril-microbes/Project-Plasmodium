---
title: "report12"
output: html_document
---

# load in libraries
```{r}
library(ggplot2)
library(dplyr)
library(here)
library(doParallel)
library(doRNG)
library(GA)
```

#-----------------------#
# Incorporating noise according to Kamiya et al 2020 Uncovering Dose...
#-----------------------#
# get record of individual level distribution (dose-independent)
# all are expionential normal distribution!
```{r}
rep <- 10000

#proprotion of RBC recovered per day. rho: sd = 0.2579136
rho_sd <- 0.2579136
rho_dist <- exp(rnorm(rep, 0, rho_sd))
hist(rho_dist)

# burst size: sd= 0.1722868
beta_sd <- 0.1722868
beta_dist <- exp(rnorm(rep, 0, beta_sd))
hist(beta_dist)


# general RBC clearance activation strength. Sd = 0.5778196
psiN_sd <- 0.5778196
psiN_dist <- exp(rnorm(rep, 0, psiN_sd))
hist(psiN_dist)

# targetted iRBC clearance activations strength, sd = 0.2355804
psiW_sd <- 0.2355804
psiW_dist <- exp(rnorm(rep, 0, psiN_sd))
hist(psiW_dist)

# half life of general RBC clearance. sd = 0.02609495
phiN_sd <- 0.02609495
phiN_dist <- exp(rnorm(rep, 0, psiN_sd))

# half life of targeted iRBC clearance. sd = 0.8286213
phiW_sd <- 0.8286213
phiW_dist <- exp(rnorm(rep, 0, phiW_sd))

```

# Figure 1. plot individual level variations
```{r}
tiff(here("figures/report12/parameter_distribution.tiff"), res = 100)
par(mfrow = c(3, 2), mar = c(4, 2, 2, 2))

hist(rho_dist*0.2627156, xlab = "rho (Proportion of RBC recovered/day)", ylab = "Frequency", main = NULL, breaks = 75)

hist(beta_dist*5.721, xlab = "beta (Burst size)", ylab = "Frequency", main = NULL, breaks = 75)

hist(psiN_dist*16.69234, xlab = "psiN (General RBC clearance\nactivation strength)", ylab = "Frequency", main = NULL, breaks = 75)

hist(psiW_dist*0.8431785, xlab = "psiW (Targeted iRBC clearance\nactivation strength)", ylab = "Frequency", main = NULL, breaks = 75)

hist(phiN_dist*0.03520591, xlab = "phiN (General RBC clearance half-life)", ylab = "Frequency", main = NULL, breaks = 75)

hist(phiW_dist*550.842, xlab = "phiW (Targeted iRBC clearance half-life)", ylab = "Frequency", main = NULL, breaks = 75)

dev.off()
```

#----------------------------------#
# Stochastic modelling testing
#------------------------------------#
# Idea #1. Assess effects of incorporating noise into single infection model
Assess effects of noise on the fitness of optimal model. Basically, how sensitive are each cue strategy to noise incorporation?
All script encoded in chabaudi_si_sto.R

To run, need to first specify a list of rho, burst, psin, psiw, phin, and phiw from set distribution 

## get function and get parameter sets
```{r}
source(here("functions/chabaudi_si_sto.R"))
source(here("functions/chabaudi_si_clean.R"))

parameters_tsukushi <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156)

time_range <- seq(0, 20, by = 1e-3)

I_log_range <- seq(0, log10(10^8), by = log10(10^8)/5000)
```

## Monte carlo simulation code
```{r}
monte_carlo <- function(parameters_cr, # parameter sets for strategy (use optimal)
                        parameters, # parameter set for model
                        time_range, # time range
                        cue, # cue to use
                        cue_range, # cue range
                        log_cue, # whether to log cue or not
                        rho_sd, # sd for rho
                        beta_sd, # sd for beta (burst size)
                        psin_sd, # sd for psin (activation strength for general RBC removal)
                        psiw_sd, # sd for psiw (activation strength for targeted iRBC removal)
                        phin_sd, # sd for general RBC removal half-life
                        phiw_sd, # sd for targeted RBC removal half-lfie 
                        factor = 1 # factor to divide sd with
                        ){
  
  # forcing parameters
  force(parameters_cr)
  force(parameters)
  force(log_cue)
  force(cue)
  force(cue_range)
  force(rho_sd)
  force(beta_sd)
  force(psin_sd)
  force(psiw_sd)
  force(phin_sd)
  force(phiw_sd)
  
  ## define the random list of parameter values
  rho_rand <- parameters["rho"]*exp(rnorm(n = length(time_range) + 1, mean = 0, sd = rho_sd/factor)) # proportion of RBC recovered
  beta_rand <- parameters["beta"]*exp(rnorm(n = length(time_range) + 1, mean = 0, sd = beta_sd/factor)) # burst size
  psin_rand <- parameters["psin"]*exp(rnorm(n = length(time_range) + 1, mean = 0, sd = psin_sd/factor))
  psiw_rand <- parameters["psiw"]*exp(rnorm(n = length(time_range) + 1, mean = 0, sd = psiw_sd/factor))
  phin_rand <- parameters["phin"]*exp(rnorm(n = length(time_range) + 1, mean = 0, sd = phin_sd/factor))
  phiw_rand <- parameters["phiw"]*exp(rnorm(n = length(time_range) + 1, mean = 0, sd = phiw_sd/factor))
  
  ## run the numerical simulation
  sim <- chabaudi_si_lag_sto(parameters_cr = parameters_cr,
                             immunity = "tsukushi",
                             parameters = parameters,
                             time_range = time_range,
                             cue = cue,
                             cue_range = cue_range, 
                             solver = "vode",
                             log_cue = log_cue, 
                             rho_rand = rho_rand,
                             beta_rand = beta_rand,
                             psin_rand = psin_rand,
                             psiw_rand = psiw_rand,
                             phin_rand = phin_rand,
                             phiw_rand = phiw_rand,
                             dyn = TRUE)

  ## return simulation results
  return(sim)
}
```

## testing monte carlo simulation
Overall, seems our original distribution is too big. Might need to divide by a factor. 
```{r}
# run deterministic with optimal parameters
deterministic <- chabaudi_si_lag_clean(
  parameters_cr = c(5.511734, 2.394041,-17.890312,4.598348), 
  parameters = parameters_tsukushi, 
  time_range = time_range, 
  cue = "I", 
  cue_range = I_range, 
  log_cue = "log10",
  immunity = "tsukushi",
  solver = "vode",
  dyn = TRUE
)


source(here("functions/test.R"))

rho_rand <- parameters_tsukushi["rho"]*exp(rnorm(n = length(time_range) + 1, mean = 0, sd = rho_sd)) # this is fine 
beta_rand <- parameters_tsukushi["beta"]*exp(rnorm(n = length(time_range) + 1, mean = 0, sd = beta_sd)) # this is fine
psin_rand <- parameters_tsukushi["psin"]*exp(rnorm(n = length(time_range) + 1, mean = 0, sd = psiN_sd)) # this is fine
psiw_rand <- parameters_tsukushi["psiw"]*exp(rnorm(n = length(time_range) + 1, mean = 0, sd = psiW_sd)) # this is fine
phin_rand <- parameters_tsukushi["phin"]*exp(rnorm(n = length(time_range) + 1, mean = 0, sd = phiN_sd)) # this is fine
phiw_rand <- parameters_tsukushi["phiw"]*exp(rnorm(n = length(time_range) + 1, mean = 0, sd = phiW_sd)) # this is fine

# test function
test_res <- chabaudi_si_lag_sto(
  parameters_cr = c(5.511734, 2.394041,-17.890312,4.598348), 
  parameters = parameters_tsukushi, 
  time_range = time_range, 
  cue = "I", 
  cue_range = I_range, 
  log_cue = "log10",
  immunity = "tsukushi",
  solver = "vode",
  dyn = TRUE,
  rho_rand = rho_rand, 
  beta_rand = beta_rand, 
  psin_rand = psin_rand,
  psiw_rand = psiw_rand, 
  phin_rand = phin_rand, 
  phiw_rand = phiw_rand
)

ggplot() +
  geom_line(data = test_res, aes(x = time, y = value, color = "test")) +
  geom_line(data = deterministic, aes(x = time, y = value, color = "deterministic"), alpha = 0.5) +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```


```{r}
# control. should be the same
set.seed(1)
mc1 <- monte_carlo(
  parameters_cr = c(5.511734, 2.394041,-17.890312,4.598348), 
  parameters = parameters_tsukushi, 
  time_range = time_range, 
  cue = "I", 
  cue_range = I_range, 
  log_cue = "log10",
  rho_sd = 0, 
  beta_sd = 0, 
  psin_sd = 0,
  psiw_sd = 0, 
  phin_sd = 0, 
  phiw_sd = 0)

mc2 <- monte_carlo(
  par = c(5.511734, 2.394041,-17.890312,4.598348), 
  parameters = parameters_tsukushi, 
  time_range = time_range, 
  cue = "I", 
  cue_range = I_range, 
  log_cue = "log10",
  rho_sd = 0.2579136, 
  beta_sd = 0.1722868, 
  psin_sd = 0.5778196,
  psiw_sd = 0.2355804, 
  phin_sd = 0.02609495, 
  phiw_sd = 0.8286213)

# 
ggplot() +
  geom_line(data = deterministic, aes(x = time, y = value, color = "deterministic")) +
  geom_line(data = mc1, aes(x = time, y = value, color = "mc_control")) +
  geom_line(data = mc2, aes(x = time, y = value, color = "mc2")) +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

# trouble shoot complete. Need to visualize several simulation
```{r}
cl <- makeCluster(4)
registerDoParallel(cl)
registerDoRNG(137)

loop_test <- foreach(i= 1:10, .packages = c("doParallel", "doRNG", "deSolve", "splines2", "stringr", "dplyr", "tidyr")) %dorng% {
  monte_carlo(
      par = c(5.511734, 2.394041,-17.890312,4.598348), 
      parameters = parameters_tsukushi, 
      time_range = time_range, 
      cue = "I", 
      cue_range = I_range, 
      log_cue = "log10",
      rho_sd = 0.2579136, 
      beta_sd = 0.1722868, 
      psin_sd = 0.5778196,
      psiw_sd = 0.2355804, 
      phin_sd = 0.02609495, 
      phiw_sd = 0.8286213)}
stopCluster(cl)

loop_test.df <- dplyr::bind_rows(loop_test, .id = "id")

ggplot() +
  geom_line(data = loop_test.df, aes(x = time, y = value, color = id)) +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

#----------------------------------_#
# Finding optimal cue range + GA
#----------------------------------_#

# systematically spline curve bounds
```{r}
# fit different combination of parameter values
make_par <- function(bounds){
  par_1 <- c(bounds, rep(0.5, 3))
  par_2 <- c(0.5, bounds, 0.5, 0.5)
  par_3 <- c(rep(0.5,2), bounds, 0.5)
  par_4 <- c(rep(0.5, 3), bounds)
  
  return(list(par_1, par_2, par_3, par_4))

}

# get parameter list with different bounds
bound.ls <- c(-2000, -1000, -500, -100, -50, -10, 10, 50, 100, 500, 1000, 2000)

par.ls <- unlist(lapply(bound.ls, make_par), recursive = F)

# get list of models
get_spline_mod <- function(par){
  dummy_y.vals <- rep(0, 5000) 
  dummy_cr.data <- as.data.frame(cbind(seq(1,5000), dummy_y.vals))
    
  dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(x = seq(1,5000), degree = 3))
  dummy_cr.mod$data <- dummy_cr.data
  dummy_cr.mod$coefficients <- par
  cr_fit <- exp(-exp(predict(dummy_cr.mod, newdata = data.frame(seq(1,5000)))))  
  df <- data.frame(x = seq(1, 5000), value = cr_fit, id = paste(par, collapse = " "))
  return(df)
}

# generate range of splines
## first par
spline.ls1 <- lapply(par.ls[seq(1, length(par.ls), by = 4)], get_spline_mod)
spline_df.ls1 <- do.call(rbind, spline.ls1)

spline.ls2 <- lapply(par.ls[seq(2, length(par.ls), by = 4)], get_spline_mod)
spline_df.ls2 <- do.call(rbind, spline.ls2)

spline.ls3 <- lapply(par.ls[seq(3, length(par.ls), by = 4)], get_spline_mod)
spline_df.ls3 <- do.call(rbind, spline.ls3)

spline.ls4 <- lapply(par.ls[seq(4, length(par.ls), by = 4)], get_spline_mod)
spline_df.ls4 <- do.call(rbind, spline.ls4)

# plot
# parameter 1 can be very small
ggplot() +
  geom_line(data = spline_df.ls1, aes(y = value, x= x, color = id))  +
  theme_bw()

# paramter 2 -100 to 100 works
ggplot() +
  geom_line(data = spline_df.ls2, aes(y = value, x= x, color = id))  +
  theme_bw()

# parameter 3 -500 to 500 works
ggplot() +
  geom_line(data = spline_df.ls3, aes(y = value, x= x, color = id))  +
  theme_bw()

# paraketer 4 -1000 to 1000 is not perfect but keeps it in check
ggplot() +
  geom_line(data = spline_df.ls4, aes(y = value, x= x, color = id))  +
  theme_bw()

```

# testing out GA
couldn't get this to work properly, which is weird given that I used the same code as beofre.
```{r}
registerDoParallel(cl)
#clusterExport(cl, varlist = c("chabaudi_si_lag_clean", "parameters_tsukushi", "time_range", "I_range"))
si_I_log10.ga <- ga(type = "real-valued", 
         fitness = fitness,
         lower = c(-1, -100, -500, -1000), # range determined that would alter shape of spline
         upper = c(1, 100, 500, 1000), 
         popSize = 100, 
         maxiter = 1, 
         run = 30, 
         pmutation = 0.3,
         parallel = TRUE,
         seed = 137,
         keepBest = TRUE,
         monitor = TRUE)
stopCluster(cl)
```


# creating custom ga that writes log file
```{r}
# note. after many hours of suffering, you need to put x and set the parameter values as x[1]... or else this will just produce NAs!!!!!!!!!!!!!!!!
cl <- makeCluster(4)
registerDoParallel(cl)

library(here)
source(here("functions/ga_verbose.R"))
test <- ga_verbose(type = "real-valued", 
         function(x)
            chabaudi_si_lag_clean(
            parameters_cr = c(x[1], x[2], x[3], x[4]), 
            parameters = parameters_tsukushi, 
            time_range = time_range, 
            cue = "I", 
            cue_range = I_range, 
            log_cue = "log10",
            immunity = "tsukushi",
            solver = "vode"),
         lower = c(-5, -10,-10,-10), # range determined that would alter shape of spline
         upper = c(5, 5,5,5), 
         popSize = 4, 
         maxiter = 5, 
         run = 10, 
         pmutation = 0.3,
         keepBest = TRUE,
         parallel = TRUE,
         monitor = TRUE)

stopCluster(cl)


# another issue. I range not enough. Compute canada go up to 10^7.02634. Let's change this to 10^8
seq(0, log10(10^8), by = log10(10^8)/5000)
```

# testing out hydropSo
particle swarming algorithm. I give up.
```{r}
library(hydroPSO)

# 
det_model <- function(x){
  chabaudi_si_lag_clean(
    parameters_cr = c(x[[1]],x[[2]],x[[3]],x[[4]]), 
    parameters = parameters_tsukushi, 
    time_range = time_range, 
    cue = "I", 
    cue_range = I_range, 
    log_cue = "log10",
    immunity = "tsukushi",
    solver = "vode")
}
# write model function to be optimized. determinisic model here.

cl <- makeCluster(4)
registerDoParallel(cl)
hydropso_test <- hydroPSO(
  fn = det_model,
  lower = c(-1, -100, -500, -500),
  upper = c(1, 100, 500, 500),
  control = list(verbose = TRUE,
    MinMax = "max",
              parallel = "parallel",
              REPORT = 1)
)

stopCluster(cl)


det_model(list(0.5,0.5,0.5,0.5))
```


# testing out ppso
```{r}
library(ppso)
source(here("functions/chabaudi_si_clean.R"))
source(here("functions/test.R"))


parameter_bounds <- cbind(c(-10, -100, -500, -500),
                          c(10, 100, 500, 500))

optim_pso(
  objective_function = function(X)
            chabaudi_si_clean(
            parameters_cr = X, 
            parameters = parameters_tsukushi, 
            time_range = time_range, 
            cue = "I", 
            cue_range = I_range, 
            log_cue = "log10",
            immunity = "tsukushi",
            solver = "vode",
            neg = TRUE),
  number_of_parameters = 4,
  parameter_bounds = parameter_bounds,
  tryCall = TRUE
)
# using default setting
# 0.8026691   7.5016711 -12.4452724   7.9655673
#8.164052


```


#----------------------------#
# GA with 200 iterations gave followign parameters
#----------------------------#
1.436777 -5.726695 15.34231 -39.01399
with fitness of 7.79281

# further local LFBGS optimization
```{r}
library(optimParallel)
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
si_I_log10.ga <- optimParallel(
  par =c(26.25904, -38.77391, -26.81986, -17.54260),
  fn = chabaudi_si_clean, 
  control = list(trace = 6, fnscale = -1),
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = time_range,
  cue = "I",
  log_cue = "log10",
  cue_range = I_range,
  solver = "vode")
stopCluster(cl)

si_I_log10.ga
# 1 st iteration. cannot go any further
#26.25904 -38.77391 -26.81986 -17.54260
#9.541386

# maximize ppso
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
si_I_log10.ppso <- optimParallel(
  par =c(0.8026691,   7.5016711, -12.4452724 ,  7.9655673),
  fn = chabaudi_si_clean, 
  control = list(trace = 6, fnscale = -1),
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = time_range,
  cue = "I",
  log_cue = "log10",
  cue_range = I_range,
  solver = "vode")
stopCluster(cl)
#7.59787 -1.37371 -26.0138 17.4015 
#9.50001

# compare to local starting at 0.5
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
si_I_log10.local <- optimParallel(
  par =rep(0.5,4),
  fn = chabaudi_si_clean, 
  control = list(trace = 6, fnscale = -1),
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = time_range,
  cue = "I",
  log_cue = "log10",
  cue_range = I_range,
  solver = "vode")
stopCluster(cl)
si_I_log10.local
#11.951024 -10.153976 -26.094426   9.100654
# 9.510186

#look at shape of rxn norm
source(here("functions/par_to_df.R"))

si_I_log_ga.rn <- par_to_df(c(26.25904, -38.77391, -26.81986, -17.54260), cue_range = I_range)
si_I_log_ppso.rn <- par_to_df(c(7.59787, -1.37371, -26.0138, 17.4015), cue_range = I_range)
si_I_log_loc.rn <- par_to_df(c(11.951024, -10.153976, -26.094426,   9.100654), cue_range = I_range)

# very little difference lol
ggplot() +
  geom_line(data= si_I_log_ga.rn, aes(x = cue_range, y = cr, color = "GA Hybrid")) +
  geom_line(data= si_I_log_ppso.rn, aes(x = cue_range, y = cr, color = "PPSO hybrid")) +
  geom_line(data= si_I_log_loc.rn, aes(x = cue_range, y = cr, color = "LBFGS")) +
  theme_bw()
```


#----------------#
# note about GA
#---------------_#
better results obtained with population size of 500, run value = 100, and longer max-teration. Whole node with 48 cores = 104 iterations at 3 hours. different parameter values: 
0.4233447 -0.01626622 5.753277 -20.34907, which gives us a fitness of around 7.970117
from original GA run with smaller population size. 

#---------------------# 
#more comprehensively trying out PPSO
#---------------------#
```{r}
library(ppso)
parameter_bounds <- cbind(c(-5, -100, -500, -500),
                          c(5, 100, 500, 500))

optim_pso(
  objective_function = function(X)
            chabaudi_si_clean(
            parameters_cr = X, 
            parameters = parameters_tsukushi, 
            time_range = time_range, 
            cue = "I", 
            cue_range = I_range, 
            log_cue = "log10",
            immunity = "tsukushi",
            solver = "vode",
            neg = TRUE),
  number_of_parameters = 4,
  number_of_particles = 70, # increase to 500. Which is on the higher end of the optimal range,. according to https://doi.org/10.1016/j.swevo.2020.100718
  max_number_of_iterations = 100,
  parameter_bounds = parameter_bounds,
  tryCall = TRUE
)

#0.8026691   7.5016711 -12.4452724   7.9655673
#8.164052
```

NOTE FOR PPSO, you need to delete the log or else it retrieves the best results based on your previous runs!!!!

#-------------------------------#
# cue limits testing
#------------------------------#
Need to test for the following:
1. log(I) -> done. 1 to log(10^8)
2. I -> use 0 to 10^8
3. log(R) 
4. R -> use 10^6 -> 10^7.
5. log(G)
6. G


# R testing
```{r}
R_range1 <- seq(10^6, 10^7, by = (9*(10^6))/5000) # this seems fine for stochastic model
R_range0 <- seq(0, 10^7, by = (10^7)/5000) # considering stochastic model that might dip further

# no log
optim_pso(
  objective_function = function(X)
            chabaudi_si_clean(
            parameters_cr = X, 
            parameters = parameters_tsukushi, 
            time_range = time_range, 
            cue = "R", 
            cue_range = R_range, 
            log_cue = "none",
            immunity = "tsukushi",
            solver = "vode",
            neg = TRUE),
  number_of_parameters = 4,
  number_of_particles = 50, # increase to 500. Which is on the higher end of the optimal range,. according to https://doi.org/10.1016/j.swevo.2020.100718
  max_number_of_iterations = 5,
  parameter_bounds = parameter_bounds,
  tryCall = TRUE
)

chabaudi_si_clean(
            parameters_cr = c(-0.132004226,	-48.22755103,	12.34318544,	394.7057029), 
            parameters = parameters_tsukushi, 
            time_range = time_range, 
            cue = "R", 
            cue_range = R_range1, 
            log_cue = "none",
            immunity = "tsukushi",
            solver = "vode",
            neg = TRUE)
```

# G testing
```{r}
G_range1 <- seq(0, 10^5, by = (10^5)/5000) # this is fine
G_range2 <- seq(0, 5*10^4, by = (10^5)/5000)# this is also fine

optim_pso(
  objective_function = function(X)
            chabaudi_si_clean(
            parameters_cr = X, 
            parameters = parameters_tsukushi, 
            time_range = time_range, 
            cue = "G", 
            cue_range = G_range2, 
            log_cue = "none",
            immunity = "tsukushi",
            solver = "vode",
            neg = TRUE),
  number_of_parameters = 4,
  number_of_particles = 50, # increase to 500. Which is on the higher end of the optimal range,. according to https://doi.org/10.1016/j.swevo.2020.100718
  max_number_of_iterations = 5,
  parameter_bounds = parameter_bounds,
  tryCall = TRUE
)


source(here("functions/par_to_df.R"))

G_rn_1 <- par_to_df(par = c(0.1941519,  -29.2703889,  296.3940933, -206.6236651), cue_range = G_range1)

# complex shape. Need to check dynamics. In reality, it seems that gametocyte goes to 2*10^4
plot(G_rn_1$cue_range, G_rn_1$cr, type = "lines")
#-6.902992
#0.1941519  -29.2703889  296.3940933 -206.6236651

# getting dynamics data
G_dyn_1 <- chabaudi_si_clean(
            parameters_cr = c(0.1941519,  -29.2703889,  296.3940933, -206.6236651), 
            parameters = parameters_tsukushi, 
            time_range = time_range, 
            cue = "G", 
            cue_range = G_range1, 
            log_cue = "none",
            immunity = "tsukushi",
            solver = "vode",
            neg = TRUE,
            dyn = TRUE)

ggplot() +
  geom_line(data = G_dyn_1, aes(x = time, y = value)) +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

#-------------------------#
# testing out new GA verbose so that we can submit many jobs with dedicated id
#-------------------------#
```{r}
source(here("functions/ga_verbose.R"))
source(here("functions/cbahadi_si_clean.R"))

G_range <- seq(0, 10^5, by= (10^5)/5000)
test <- ga_verbose(type = "real-valued", 
             function(x)
               chabaudi_si_clean(
                 parameters_cr = c(x[1], x[2], x[3], x[4]), 
                 parameters = parameters_tsukushi, 
                 time_range = time_range, 
                 cue = "G", 
                 cue_range = G_range, 
                 log_cue = "none",
                 immunity = "tsukushi",
                 solver = "vode"),
             lower = c(-5, -100, -500, -500), # range determined that would alter shape of spline
             upper = c(5, 100, 500, 500),  
             popSize = 5, 
             maxiter = 2, # change to 10 for testing purpose 
             run = 5, 
             pmutation = 0.3,
             keepBest = TRUE,
             seed = 137,
             monitor = TRUE,
             id = "test")
```


#---------------------------------#
#LFGBS of GA runs that finished successfully
#----------------------------------#
```{r}
source(here("functions/chabaudi_si_clean.R"))
source(here("functions/par_to_df.R"))
```


# R log
# 10^6-10^8 finished with 500 populations, 50 runs, max 500 iterations
#-0.9841931 12.20793 -30.23427 63.48455
#8.025093 

# changing 10^8->10^7.5 still finish. However, lower fitness such that = 7.985181
```{r}
library(optimParallel)
R_log_range <- seq(log10(10^6), log10(10^8), by = log10((10^8)-(10^6))/5000)

cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
si_R_log.local <- optimParallel(
  par = c(-0.9841931, 12.20793, -30.23427, 63.48455),
  fn = chabaudi_si_clean, 
  control = list(trace = 6, fnscale = -1),
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = time_range,
  cue = "R",
  log_cue = "log10",
  cue_range = R_log_range,
  solver = "vode")
stopCluster(cl)

#-0.9462285  12.3937075 -30.4948618  63.3172971
#8.025768
si_R_log.local

si_R_log.rn <- par_to_df(c(-0.9462285,  12.3937075, -30.4948618,  63.3172971), R_log_range)

plot(si_R_log.rn$cue_range, si_R_log.rn$cr, type = "lines")

# plto dynamics
si_R_log.dyn <- chabaudi_si_clean(
  parameters_cr = c(-0.9462285,  12.3937075, -30.4948618,  63.3172971),
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = time_range,
  cue = "R",
  log_cue = "log10",
  cue_range = R_log_range,
  solver = "vode",
  dyn = TRUE
)

ggplot() +
  geom_line(data = si_R_log.dyn, aes(x = time, y = value)) +
  facet_wrap(~variable, scales = "free") +
  scale_y_continuous(labels = function(x) format(x, scientific = TRUE)) +
  theme_bw()
```
# I-log
1. (2022-01-27) population size of 500 population size (10^8) limit did not finish but ended with highest point. 
0.4233447 -0.01626622 5.753277 -20.34907 where fitness = 7.970117
2. 

# G-log
1. 0 to 10^5 stopped at iteration 4
2. 0 to 10^6 stopped at iteration 2
3. 0 to 10^7 did not start at all


# if shit doesn't work, use PPSO to optimize G
```{r}
library(ppso)
G_range <- seq(0, 10^5, by = (10^5)/5000)
parameter_bounds <- cbind(c(-5, -100, -500, -500),
                          c(5, 100, 500, 500))

ppso_si_G <- optim_pso(
  objective_function = function(X)
            chabaudi_si_clean(
            parameters_cr = X, 
            parameters = parameters_tsukushi, 
            time_range = time_range, 
            cue = "G", 
            cue_range = G_range, 
            log_cue = "none",
            immunity = "tsukushi",
            solver = "vode",
            neg = TRUE),
  number_of_parameters = 4,
  number_of_particles = 70,
  max_number_of_iterations = 500,
  parameter_bounds = parameter_bounds,
  max_number_function_calls = 10000,
  tryCall = TRUE,
  log = "ppso_si_G6.log")

ppso_si_G 
#7.047563
#0.1543677 -21.9189036 179.9696198 166.6666667
# max iteration reached with 1000 iteraitons

# 10 max iterations
#-0.1189398  -12.3031964  147.4372224 -261.1575244
#-7.590436
#max number of function calls reached

# 50 max iteration
#-0.1189398  -12.3031964  147.4372224 -261.1575244
#-7.590436

#500 max iteration
#-0.1189398  -12.3031964  147.4372224 -261.1575244
#-7.590436

# 500 max iterations, 5000 max function calls
# -0.1053204   -7.1153938   62.0880905 -234.3408273
# -8.278978

# 500 max iterations, 10000 max function calls
# did not complete. stopped at around 5436
#-0.003896759	-7.478472547	64.01540971	-310.8298563
#-8.383730568
```

# optimize G-log
```{r}
G_log_range <- seq(5e-324, log10(10^6), by = log10(10^6)/5000)

ppso_si_G_log <- optim_pso(
  objective_function = function(X)
            chabaudi_si_clean(
            parameters_cr = X, 
            parameters = parameters_tsukushi, 
            time_range = time_range, 
            cue = "G", 
            cue_range = G_log_range, 
            log_cue = "log10",
            immunity = "tsukushi",
            solver = "vode",
            neg = TRUE),
  number_of_parameters = 4,
  number_of_particles = 70,
  max_number_of_iterations = 500,
  parameter_bounds = parameter_bounds,
  max_number_function_calls = 10000,
  tryCall = TRUE,
  log = "ppso_si_G_log.log")

 chabaudi_si_clean
```

