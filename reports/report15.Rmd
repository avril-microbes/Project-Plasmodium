---
title: "report15"
output: html_document
---
```{r}
library(dplyr)
library(ggplot2)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
```


# load parameter
```{r}
source(here("functions/par_to_df.R"))
source(here("functions/chabaudi_si_clean.R"))

parameters_tsukushi <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156)

time_range <- seq(0, 20, by = 1e-3)
```

#-------------------------------------#
# Repeat optimization attempt
#--------------------------------------#
I resubmitted my compute canada jobs with even more limited cue range. These are based on the experimental values derived from single infection with drug resistant P. chabaudi to the nearest "whole number" in terms of scientific notation. 

iRBC: 0-6*(10^6)
GL 0-6*(10^4)
RBC: (10^6)-(10^7). Here the max RBC value is set to less than experimental max given our max RBC density is set to 8.89*10^6

Overall, much better performance. Need to wait for GA to come back though.

Note that GA converged with the results with the L-BFGS so might stick with L-BFGS for now.
# function for local L-BFGS optimization
```{r}
opt_local <- function(
  par, # initial parameter sets
  cue, #
  log,
  cue_range,
  dyn = F
  ){
  # start cluster
  cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
  
  # start optimization LFBGS
  res <- optimParallel(
    par = par,
    fn = chabaudi_si_clean, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = time_range,
    cue = cue,
    log_cue = log,
    cue_range = cue_range,
    solver = "vode")
  
  # close cluster
  stopCluster(cl)
  
  return (res)
}
```

# I non-logged
```{r}
I_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "I",
                            log = "none",
                            cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))
#0.1135384  -39.0585154 1941.9082813  119.8228980
#8.49777
```

# I logged
```{r}
I_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "I",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

#5.463558   2.383948 -17.757281   4.571835
#9.494991
```

# Ig
```{r}
Ig_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "Ig",
                            log = "none",
                            cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))
# 0.05234791  -46.03368629 1897.61313455   70.57689145
# 8.569285
```

# Ig logged
```{r}
Ig_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "Ig",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))
#1.746334 -1.785818 -5.528335  1.573436
# 9.618812
```

# I + Ig
```{r}
I_Ig_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "I+Ig",
                            log = "none",
                            cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))

#0.3159297  -46.1104558 1250.7529081   -6.1982093
# 8.854682
```

# I+Ig logged
```{r}
I_Ig_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "Ig+I",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

#3.594042   4.157744 -13.530672   2.599905
#9.573291
```

# I logged
```{r}
I_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "I",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

#5.463558   2.383948 -17.757281   4.571835
#9.494991
```

# RBC non-logged
```{r}
R_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "R",
                            log = "none",
                            cue_range = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000))
#7.0976026  30.1295151 -28.0565613  -0.2788713
#8.23991
```

# RBC logged
```{r}
R_loc_log.op <- opt_local(par = rep(0.5, 4),
                            cue = "R",
                            log = "log10",
                            cue_range = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000))
#48.70772 105.18882 -81.80625 -44.60051
#8.181604
```

# G non-logged
GA have same result
```{r}
G_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "G",
                            log = "none",
                            cue_range = seq(0, 6*(10^4), (6*(10^4))/5000))
#0.04061288   -9.31445958   74.13015506 -431.59843638
#8.58856
```

# G logged
```{r}
G_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "G",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000))
#1.211521 -3.936778 -1.312944 -1.285713
#9.561373
```

#-------------------------------#
# Writing the code to optimize co-infection
#-------------------------------#
We cannot use GA for optimizing co-infection data given that each individual iteration would take too long. Here, what we acn do is to perform local co-infection optimization using L-BFGS but repeat it many times using different initial values. For each initial value, we would get an "optimum" parameter set. We can then compete all the optimum parameter set with each other (n*(n-1)/2 competitions). If the focal parameter set wins, we assign the parameter set a value of 1 and lossage results in 0. For each parameter set we can then sum up its total point in the competition, with the maximum point being n-1 and the lowest point being 0.

The optimum parameter set would be the parameter with the highest score.

If this is too much, then we could stick with local optimization but acknowledging the caveats

we need to test out the following combo
1) both competitors adopting the same cue
I1+I2, Ii (only recognize self), G1+G2, Gi, R and their logged counterpart
2) different cues adoption
across all combo

# function to perform all co-infection combo
```{r}
do_ci_combo <- function(cue_1, cue_2, par, limit){
  
  # get df full of model requirements. Do all combinations
  par_df <- expand.grid(
  cue_1 = cue_1,
  cue_2 = cue_2,
  log_1 = c("none", "log10"),
  log_2 = c("none", "log10"))
  
  # run paralellized L-BFGS across the different permutations. Note that cluster iniation is included in the co_infection_opt function
  output <- mapply(function(x, y, z, k){
    ## get cue range based on cue
    if(z == "none"){
      if(x == "I1" | x == "Ig1" | x == "I1+I2" | x == "Ig1+Ig2" | x == "sum"){cue_range_1 = seq(0, 6*(10^6), by = (6*(10^6))/5000)}
      if(x == "R"){cue_range_1 = seq(10^6, 10^7, ((10^7)-(10^6))/5000)}
      if(x == "G1" | x == "G1+G2"){cue_range_1 = seq(0, 6*(10^4), by = (6*(10^4))/5000)}
    }
    if(z == "log10"){
      if(x == "I1" | x == "Ig1" | x == "I1+I2" | x == "Ig1+Ig2" | x == "sum"){cue_range_1 = seq(0, log10(6*(10^6)), by = log10(6*(10^6))/5000)}
      if(x == "R"){cue_range_1 = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000)}
      if(x == "G1" | x == "G1+G2"){cue_range_1 = seq(0, log10(6*(10^4)), by = log10((6*(10^4)))/5000)}
    }

    if(k == "none"){
      if(y == "I2" | y == "Ig2" | y == "I1+I2" | y == "Ig1+Ig2" | y == "sum"){cue_range_2 = seq(0, 6*(10^6), by = (6*(10^6))/5000)}
      if(y == "R"){cue_range_2 = seq(10^6, 10^7, ((10^7)-(10^6))/5000)}
      if(y == "G2" | y == "G1+G2"){cue_range_2 = seq(0, 6*(10^4), by = (6*(10^4))/5000)}
    }
    if(k == "log10"){
      if(y == "I2" | y == "Ig2" | y == "I1+I2" | y == "Ig1+Ig2" | y == "sum"){cue_range_2 = seq(0, log10(6*(10^6)), by = log10(6*(10^6))/5000)}
      if(y == "R"){cue_range_2 = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000)}
      if(y == "G2" | y == "G1+G2"){cue_range_2 = seq(0, log10(6*(10^4)), by = (log10(6*(10^4)))/5000)}
    }
    
    co_infection_opt(parameters_cr = par,
                 limit = limit, 
                 model = chabaudi_ci_clean,
                 immunity = "tsukushi",
                 parameters = parameters_tsukushi,
                 time_range = time_range,
                 cue_1 = x,
                 cue_2 = y,
                 cue_range_1 = cue_range_1,
                 cue_range_2 = cue_range_2,
                 solver = "vode",
                 log_cue_1 = z,
                 log_cue_2 = k)}, x = par_df$cue_1, y = par_df$cue_2, z = par_df$log_1, k = par_df$log_2, SIMPLIFY = F)
  return(output)
}


```

# new co-infection optimization function for switcheroo
```{r}
switcheroo <- function(parameters_cr,  # preliminary parameter set
                       limit, # minimum fitness difference between competing strains to break
                       model, # infection model
                       cue_1,
                       cue_2,
                       cue_range_1,
                       cue_range_2,
                       log_cue_1,
                       log_cue_2,
                       ...){ # additional parameters to be inserted into the infection model
  force(parameters_cr)
  force(limit)
  force(model)
  additional_arg <- list(...) # unpack for do.call
  
  # assign default parameters
  # assign iteration index
  index <- 1
  output_ls <- list()
  
  # do-while loop to continue to optimize strain 1 fitness
  repeat{
    ## for first iteration, both strain adopts initial parameter condition assigned
    if(index == 1){
      mutant_par <- parameters_cr
      resident_par <- parameters_cr
      
      ### assigning cue
      mutant_cue <- cue_1
      resident_cue <- cue_2
      
      ### assigning cue range
      mutant_cue_range <- cue_range_1
      resident_cue_range <- cue_range_2
      
      ### assigning log
      mutant_log <- log_cue_1
      resident_log <- log_cue_2
      
      print(paste("First round of optimization! Mutant is using", mutant_cue, min(mutant_cue_range), max(mutant_cue_range), mutant_log, ". resident is using", resident_cue, min(resident_cue_range), max(resident_cue_range), resident_log, sep = " "))
    }
      
    ## for second iteration, if strain 1 is fitter, than assign strain 1 to resident
    ## and assign strain to be mutant adopting initial condition. 
    if(index == 2){
        mutant_par <- parameters_cr
        resident_par <- par
        
        ### switch cue
        mutant_cue <- cue_2
        resident_cue <- cue_1
    
        ### switch cue range
        mutant_cue_range <- cue_range_2
        resident_cue_range <- cue_range_1
        
        ### switch log
        mutant_log <- log_cue_2
        resident_log <- log_cue_1
          
        print(paste("Second round! Strain 1 is fitter than strain 2. First switch! Mutant is using", mutant_cue, min(mutant_cue_range), max(mutant_cue_range), mutant_log, ". resident is using", resident_cue, min(resident_cue_range), max(resident_cue_range), resident_log, sep = " "))
    } 
    if(index > 2) {
      ###--------assign cues, cue ranges, and logs based on iteration index
      if((index %% 2) == 0) {
        ### if index is even, strain 2 is mutant, strain 1 is resident
        mutant_cue <- cue_2
        resident_cue <- cue_1
        
        mutant_cue_range <- cue_range_2
        resident_cue_range <- cue_range_1
        
        mutant_log <- log_cue_2
        resident_log <- log_cue_1
      } else { ### if index is odd, strain 1 is mutant, strain 2 is resident
        mutant_cue <- cue_1
        resident_cue <- cue_2
        
        mutant_cue_range <- cue_range_1
        resident_cue_range <- cue_range_2
        
        mutant_log <- log_cue_1
        resident_log <- log_cue_2
        }
      
      ###---------------assign parameters 
      ### if strain 1 (mutant) is fitter than strain 2 (resident), switcheroo! 
      ### strain 2 becomes mutant and strain 1 becomes resident. Here, we assign
      ### resident par as optimized par. 
      if(fitness > 0 && fitness < limit){
        mutant_par <- output_ls[[index - 2]][[2]] ## assign mutant par to the optimized par 2 gen ago (corresponding to the same cue and cue range)
        resident_par <- output_ls[[index - 1]][[2]] ## assign resident to the optimized par just obtained
        print(paste("Strain 1 is fitter than strain 2. First switch! Mutant is using", mutant_cue, min(mutant_cue_range), max(mutant_cue_range), mutant_log, ". resident is using", resident_cue, min(resident_cue_range), max(resident_cue_range), resident_log, sep = " "))
      }
    }
    
    ## code to execute parallel LGBF-GS optimization
    output <- list() # reset per run
    cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
    model_output <- do.call(optimParallel::optimParallel, c(list(par = mutant_par, # competing parameter
                                                                 fn = model,
                                                                 control = list(trace = 6, fnscale = -1),
                                                                 parameters_cr_2 = resident_par, 
                                                                 cue_1 = mutant_cue,
                                                                 cue_2 = resident_cue,
                                                                 cue_range_1 = mutant_cue_range,
                                                                 cue_range_2 = resident_cue_range,
                                                                 log_cue_1 = mutant_log,
                                                                 log_cue_2 = resident_log),
                                                            additional_arg))
   
    ## save output
    par <- model_output$par ### final parameters after optimization
    fitness <- model_output$value ### fitness difference between mutant and resident
    output <- list(index, 
                   par,
                   fitness,
                   mutant_cue, mutant_par, min(mutant_cue_range), max(mutant_cue_range), mutant_log, 
                   resident_cue, resident_par, min(resident_cue_range), max(resident_cue_range), resident_log)
    output_ls[[index]] <- output
    print(output)
    
    ## move index forward
    index <- index + 1
    print(paste("starting iteration", index))
    
    # exit loop IF
    ## previous run converged, strain 1 is fitter than strain 2, and that the fitness difference is minute
    if(fitness > 0 && fitness < limit){
      print("Strain 1 is fitter than strain 2 but difference is minute.")
      stopCluster(cl)
      break
      }
    # If fitness after optimization is smaller than 0, break (strain 1 cannot outcompete strain 2)
    if(fitness < 0){
      print("Strain 1 is less fit than strain 2.")
      stopCluster(cl)
      break
      }
  }

  # final output
    return(output_ls)
}
```

# test function
```{r}
source(here("chabaudi_ci_clean.R"))
switcheroo(parameters_cr = rep(0.5,4),
                 limit = 0.01, 
                 model = chabaudi_ci_clean,
                 immunity = "tsukushi",
                 parameters = parameters_tsukushi,
                 time_range = time_range,
                 cue_2 = "sum",
                 cue_1 = "R",
                 cue_range_2 = seq(0, log10(6*(10^6)), by = log10(6*(10^6))/5000),
                 cue_range_1 = seq(10^6, (10^7), by = ((10^7)-(10^6))/5000),
                 solver = "vode",
                 log_cue_2 = "log10",
                 log_cue_1 = "none")
```


# run all possible combo of compeition with different cues
```{r}
source(here("functions/chabaudi_ci_clean.R"))
source(here("functions/co_infection_opt.R"))

co_infection_opt(parameters_cr = rep(0.5,4),
                 limit = 0.01, 
                 model = chabaudi_ci_clean,
                 immunity = "tsukushi",
                 parameters = parameters_tsukushi,
                 time_range = time_range,
                 cue_1 = "sum",
                 cue_2 = "Ig1",
                 cue_range_1 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                 cue_range_2 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                 solver = "vode",
                 log_cue_1 = "none",
                 log_cue_2 = "none")


test <- do_ci_combo(cue_1 = c("I1+I2"),
                          cue_2 = c("sum"),
                          par = rep(0.5, 4),
                          limit = 0.01)

ci_opt.raw <- do_ci_combo(cue_1 = c("I1", "I1+I2", "Ig1", "Ig1+Ig2", "sum", "G1", "G1+G2", "R"),
                          cue_2 = c("I2", "I1+I2", "Ig2", "Ig1+Ig2", "sum", "G2", "G1+G2", "R"),
                          par = rep(0.5, 4),
                          limit = 0.01)
```

#----------------------#
# Repeat MC using updated parameters
#---------------------#

# this time, for each iteration, the parameter values are drawn from the log-normal distribution. Hence, through out an entire infection, we have the same parameter. However, the value differs between runs

# MC function for 1000 iterations
```{r}
mc_run <- function(par, cue, cue_range, log, seed){
  # run 5 iterations each with 1000
    cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
    registerDoParallel(cl)
    registerDoRNG(seed)
    mc_res <- foreach(i= 1:1000, .packages = c("doParallel", "doRNG", "deSolve", "splines2", "stringr", "dplyr", "tidyr", "crone", "here")) %dorng% {
      
      # source function
      source(here("functions/chabaudi_si_clean.R"))
      
      # get parameter values that are stochastic
      rho_rand <- 0.2627156*exp(rnorm(n = 1, mean = 0, sd = 0.2579136)) # proportion of RBC recovered
      beta_rand <- 5.721*exp(rnorm(n = 1, mean = 0, sd = 0.1722868)) # burst size
      psin_rand <- 16.69234*exp(rnorm(n = 1, mean = 0, sd = 0.5778196))
      psiw_rand <- 0.8431785*exp(rnorm(n = 1, mean = 0, sd = 0.2355804))
      phin_rand <- 0.03520591*exp(rnorm(n = 1, mean = 0, sd = 0.02609495))
      phiw_rand <- 550.842*exp(rnorm(n = 1, mean = 0, sd = 0.8286213))

      parameters_tsukushi <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025,
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = beta_rand, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = psin_rand,
                psiw = psiw_rand,
                phin = phin_rand, 
                phiw = phiw_rand,
                iota = 2.18*(10^6),
                rho = rho_rand)

      time_range <- seq(0, 20, by = 1e-3)
      
      # run dynamics
      chabaudi_si_clean(
        parameters_cr = par, 
        parameters = parameters_tsukushi, 
        immunity = "tsukushi",
        time_range = time_range, 
        cue = cue, 
        cue_range = cue_range, 
        log_cue = log,
        solver = "vode",
        dyn = TRUE)
      
    }

   stopCluster(cl)
   
   # process data
  fitness.ls <- mclapply(mc_res, function(x){
    fitness <- x %>% 
      dplyr::filter(variable == "tau_cum") %>% 
      dplyr::summarise(max_fitness = max(value))
    
    return(fitness)
  })
  
  ## get fitness.df
  fitness.df <- do.call(rbind, fitness.ls)
 
  # get cue vs dynamics
  ## produce wide df for plotting cue vs cr graph
  df_wide.ls <- mclapply(mc_res, function(x){
    ## convert to wide
    wide <- tidyr::pivot_wider(x, names_from = variable, values_from = value, id_cols = c(time))
    ## get every 10th row
    wide_filtered <- wide %>% dplyr::filter(row_number() %% 10 == 1)
    return(wide_filtered)
  })
  
  # get wide list
  df_wide.df <- dplyr::bind_rows(df_wide.ls, .id = "id")

  # return output
  return(list(fitness.df, df_wide.df))
}

# functions to run five of these serially 
mc_five <- function(par, cue, cue_range, log){
  mc.1 <- mc_run(par = par,
                 cue = cue,
                 cue_range = cue_range,
                 log = log,
                 seed = 137)
  mc.2 <- mc_run(par = par,
                 cue = cue,
                 cue_range = cue_range,
                 log = log,
                 seed = 138)
  mc.3 <- mc_run(par = par,
                 cue = cue,
                 cue_range = cue_range,
                 log = log,
                 seed = 139)
  mc.4 <- mc_run(par = par,
                 cue = cue,
                 cue_range = cue_range,
                 log = log,
                 seed = 140)
  mc.5 <- mc_run(par = par,
                 cue = cue,
                 cue_range = cue_range,
                 log = log,
                 seed = 141)
  
  
  # get fitness
  fitness <- rbind(mc.1[[1]],mc.2[[1]],mc.3[[1]],mc.4[[1]],mc.5[[1]])

  # produce output for convergence of fitness
  ## get cum sum of fitness
  fitness.sum <- cumsum(fitness)
  ## get average fitness across iteration
  fitness.avg <- fitness.sum/(1:length(fitness.sum))
  
  # get wide data
  dyn <- rbind(
    cbind(mc.1[[2]], run = 1),
    cbind(mc.2[[2]], run = 2),
    cbind(mc.3[[2]], run = 3),
    cbind(mc.4[[2]], run = 4),
    cbind(mc.5[[2]], run = 5))
  
  # get unique id
  dyn <- dyn %>% 
    dplyr::mutate(run_id = paste0(run,"_", id))
  
  return(list(fitness, fitness.avg, dyn))
}
```

# I
```{r}
# non-logged
mc_I.res <- mc_five(par = c(0.1135384,  -39.0585154, 1941.9082813,  119.8228980),
                    cue = "I",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none")

write.csv(mc_I.res[[1]], here("data/MC2/mc_I_fitness.csv"))
write_parquet(mc_I.res[[3]], here("data/MC2/mc_I_dyn.parquet"))

# logged
mc_I_log.res <- mc_five(par = c(5.463558,   2.383948, -17.757281,   4.571835),
                    cue = "I",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10")

write.csv(mc_I_log.res[[1]], here("data/MC2/mc_I_log_fitness.csv"))
write_parquet(mc_I_log.res[[3]], here("data/MC2/mc_I_log_dyn.parquet"))
```

# Ig
```{r}
# non-logged
mc_Ig.res <- mc_five(par = c(0.05234791,  -46.03368629, 1897.61313455,   70.57689145),
                    cue = "Ig",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none")

write.csv(mc_Ig.res[[1]], here("data/MC2/mc_Ig_fitness.csv"))
write_parquet(mc_Ig.res[[3]], here("data/MC2/mc_Ig_dyn.parquet"))

# logged
mc_Ig_log.res <- mc_five(par = c(1.74633, -1.78582, -5.52834, 1.57344 ),
                    cue = "Ig",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10")

write.csv(mc_Ig_log.res[[1]], here("data/MC2/mc_Ig_log_fitness.csv"))
write_parquet(mc_Ig_log.res[[3]], here("data/MC2/mc_Ig_log_dyn.parquet"))
```


# I+Ig
```{r}
mc_I_Ig.res <- mc_five(par = c(0.3159297,  -46.1104558, 1250.7529081,   -6.1982093),
                    cue = "I+Ig",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none")

write.csv(mc_I_Ig.res[[1]], here("data/MC2/mc_I_Ig_fitness.csv"))
write_parquet(mc_I_Ig.res[[3]], here("data/MC2/mc_I_Ig_dyn.parquet"))

mc_I_Ig_log.res <- mc_five(par = c(3.594042,   4.157744, -13.530672,   2.599905),
                    cue = "I+Ig",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10")

write.csv(mc_I_Ig_log.res[[1]], here("data/MC2/mc_I_Ig_log_fitness.csv"))
write_parquet(mc_I_Ig_log.res[[3]], here("data/MC2/mc_I_Ig_log_dyn.parquet"))
```

# G
```{r}
# non-logged
MC_G.res <- MC_five(par = c(0.04061288,   -9.31445958,   74.13015506, -431.59843638),
                    cue = "G",
                    cue_range = seq(0, 6*(10^4), (6*(10^4))/5000),
                    log= "none")

write.csv(mc_G.res[[1]], here("data/MC2/mc_G_fitness.csv"))
write_parquet(mc_G.res[[3]], here("data/MC2/mc_G_dyn.parquet"))


mc_G_log.res <- mc_five(par = c(1.211521, -3.936778,-1.312944, -1.285713),
                    cue = "G",
                    cue_range = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000),
                    log= "log10")

write.csv(mc_G_log.res[[1]], here("data/MC2/mc_G_log_fitness.csv"))
write_parquet(mc_G_log.res[[3]], here("data/MC2/mc_G_log_dyn.parquet"))
```

# R
```{r}
mc_R.res <- mc_five(par = c(7.0976026,  30.1295151, -28.0565613,  -0.2788713),
                    cue = "R",
                    cue_range = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000),
                    log= "none")

write.csv(mc_R.res[[1]], here("data/MC2/mc_R_fitness.csv"))
write_parquet(mc_R.res[[3]], here("data/MC2/mc_R_dyn.parquet"))

mc_R_log.res <- mc_five(par = c(48.70772, 105.18882, -81.80625, -44.60051),
                    cue = "R",
                    cue_range = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000),
                    log= "log10")

write.csv(mc_R_log.res[[1]], here("data/MC2/mc_R_log_fitness.csv"))
write_parquet(mc_R_log.res[[3]], here("data/MC2/mc_R_log_dyn.parquet"))
```


# read MC data
```{r}
# read in dymamics
mc_G_log.dyn <- read_parquet(here("data/MC2/mc_G_log_dyn.parquet"))
mc_G.dyn <- read_parquet(here("data/MC2/mc_G_dyn.parquet"))
mc_R_log.dyn <- read_parquet(here("data/MC2/mc_R_log_dyn.parquet"))
mc_R.dyn <- read_parquet(here("data/MC2/mc_R_dyn.parquet"))
mc_I_log.dyn <- read_parquet(here("data/MC2/mc_I_log_dyn.parquet"))
mc_I.dyn <- read_parquet(here("data/MC2/mc_I_dyn.parquet"))
mc_Ig_log.dyn <- read_parquet(here("data/MC2/mc_Ig_log_dyn.parquet"))
mc_Ig.dyn <- read_parquet(here("data/MC2/mc_Ig_dyn.parquet"))
mc_I_Ig_log.dyn <- read_parquet(here("data/MC2/mc_I_Ig_log_dyn.parquet"))
mc_I_Ig.dyn <- read_parquet(here("data/MC2/mc_I_Ig_dyn.parquet"))

# read in fitness
mc_G_log.fitness <- read.csv(here("data/MC2/mc_G_log_fitness.csv"))
mc_G.fitness <- read.csv(here("data/MC2/mc_G_fitness.csv"))
mc_R_log.fitness <- read.csv(here("data/MC2/mc_R_log_fitness.csv"))
mc_R.fitness <- read.csv(here("data/MC2/mc_R_fitness.csv"))
mc_I_log.fitness <- read.csv(here("data/MC2/mc_I_log_fitness.csv"))
mc_I.fitness <- read.csv(here("data/MC2/mc_I_fitness.csv"))
mc_Ig_log.fitness <- read.csv(here("data/MC2/mc_Ig_log_fitness.csv"))
mc_Ig.fitness <- read.csv(here("data/MC2/mc_Ig_fitness.csv"))
mc_I_Ig_log.fitness <- read.csv(here("data/MC2/mc_I_Ig_log_fitness.csv"))
mc_I_Ig.fitness <- read.csv(here("data/MC2/mc_I_Ig_fitness.csv"))
```

# examine variation
```{r}
# plot fitness vs iteration
fitness.df <- rbind(
  cbind(mc_G_log.fitness, id = "Gametocyte\nlog10"),
  cbind(mc_G.fitness, id = "Gametocyte"),
  cbind(mc_R_log.fitness, id = "RBC log10"),
  cbind(mc_R.fitness, id = "RBC"),
  cbind(mc_I_log.fitness, id = "Asexual iRBC\nlog10"),
  cbind(mc_I.fitness, id = "Asexual iRBC"),
  cbind(mc_Ig_log.fitness, id = "Sexual iRBC\nlog10"),
  cbind(mc_Ig.fitness, id = "Sexual iRBC"),
  cbind(mc_I_Ig_log.fitness, id = "Total iRBC\nlog10"),
  cbind(mc_I_Ig.fitness, id = "Total iRBC")
)

# fitness vs time
#fig2a <- ggplot() +
#  geom_line(data = fitness.df, aes(x = X, y = max_fitness), size =0.5) +
#  facet_wrap(~id, ncol = 2) +
#  labs(x = "Iteration", y = "Maximum fitness", color = "Cue") +
#  theme_bw() +
#  guides(color = FALSE, fill = F)

# quantify variance and mean
fitness_var.df <- fitness.df %>% 
  dplyr::group_by(id) %>% 
  dplyr::summarise(std = sd(max_fitness),
                   mean = mean(max_fitness)) %>% 
  dplyr::mutate(id = forcats::fct_reorder(factor(id), std, .desc = F))

# original rank by standard deviation
##fig2b <- ggplot() +
##  geom_col(data = fitness_var.df, aes(y = id, x = std)) +
  #scale_fill_manual(values = c("#619CFF", "#B79F00", "#F564E3", "#00BA38", "#F8766D", "#00BFC4")) +
##  theme_bw() +
#  labs(y = "Cue", x = "Standard deviation") +
#  guides(fill = F, color = F)

fig2a <- ggplot() +
  geom_point(data = fitness_var.df, aes(x = mean, y = std)) +
  ggrepel::geom_label_repel(data = fitness_var.df, aes(x = mean, y = std, label = id)) +
  theme_bw() +
  labs(x = "Mean fitness", y = "Fitness standard deviation")

fitness_var.df
```

# plot violin with difference in deterministic model fitness and mean model fitness
```{r}
# get deterministic df
det.df <- data.frame(id = fitness_var.df$id, fitness =  c(8.49777, 9.494991, 8.58856, 9.561373, 8.23991, 8.181604, 8.569285, 9.618812, 8.854682, 9.573291))

fig2b <- ggplot() +
  geom_violin(data = fitness.df, aes(y = id, x = max_fitness), alpha = 0.5) +
  geom_point(data = fitness_var.df, aes(y = id, x = mean)) +
  geom_point(data = det.df, aes(y = id, x = fitness), color = "red") +
  labs(x = "Fitness", y = "Cue") +
  theme_bw()


```


# get deviation from ideal cr
```{r}
dev_cr <- function(dyn, par, cue, cue_range, log){
  # get reference dynamics
  ref_dyn <- chabaudi_si_clean(
              parameters_cr = par,
              parameters = parameters_tsukushi, 
              time_range = time_range, 
              cue = cue, 
              cue_range = cue_range, 
              log_cue = log,
              immunity = "tsukushi",
              solver = "vode",
              dyn = TRUE)
  
  # convert to wide
  ref_dyn.wide <- tidyr::pivot_wider(ref_dyn, names_from = variable, values_from = value)
  
  # get 95% CI. Use t score of 1.960439 given our sample size of 5000. Margin of error = t*(sd/sqrt(n))
  mc_sum <- dyn %>%
  dplyr::group_by(time) %>% 
  dplyr::summarise(cr_top = mean(cr)+sd(cr),
                   cr_bot = mean(cr)-sd(cr),
                   tau_top = mean(tau)+sd(tau),
                   tau_bot = mean(tau)-sd(tau))
  
  # return list
  return(list(ref_dyn.wide, mc_sum))
}
```

# run tests
```{r}
# G log
G_log.diff <- dev_cr(mc_G_log.dyn, 
                    par = c(1.211521, -3.936778,-1.312944, -1.285713),
                    cue = "G",
                    cue_range = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000),
                    log= "log10")

# G
G.diff <- dev_cr(mc_G.dyn, 
                 par = c(0.04061288,   -9.31445958,   74.13015506, -431.59843638),
                    cue = "G",
                    cue_range = seq(0, 6*(10^4), (6*(10^4))/5000),
                    log= "none")

# R log
R_log.diff <- dev_cr(mc_R_log.dyn, 
                     par = c(48.70772, 105.18882, -81.80625, -44.60051),
                    cue = "R",
                    cue_range = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000),
                    log= "log10")

# R
R.diff <- dev_cr(mc_R.dyn, 
                 par = c(7.0976026,  30.1295151, -28.0565613,  -0.2788713),
                    cue = "R",
                    cue_range = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000),
                    log= "none")

# I log
I_log.diff <- dev_cr(mc_I_log.dyn, 
                     par = c(5.463558,   2.383948, -17.757281,   4.571835),
                    cue = "I",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10")

# I
I.diff <- dev_cr(mc_I.dyn, 
                     par = c(0.1135384,  -39.0585154, 1941.9082813,  119.8228980),
                    cue = "I",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none")

# Ig log
Ig_log.diff <- dev_cr(mc_Ig_log.dyn, 
                  par = c(1.74633, -1.78582, -5.52834, 1.57344 ),
                    cue = "Ig",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10")

# Ig
Ig.diff <- dev_cr(mc_Ig.dyn, 
                  par = c(0.05234791,  -46.03368629, 1897.61313455,   70.57689145),
                    cue = "Ig",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none")


# I+Ig log
I_Ig_log.diff <- dev_cr(mc_I_Ig_log.dyn, 
                    par = c(3.594042,   4.157744, -13.530672,   2.599905),
                    cue = "I+Ig",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10")


# I+Ig
I_Ig.diff <- dev_cr(mc_I_Ig.dyn, 
                    par = c(0.3159297,  -46.1104558, 1250.7529081,   -6.1982093),
                    cue = "I+Ig",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none")

```

# plot
```{r}
# cr time series
## concatenate data
reference.df <- rbind(
  cbind(G_log.diff[[1]], cue = "Gametocyte log10"),
  cbind(G.diff[[1]], cue = "Gametocyte"),
  cbind(R_log.diff[[1]], cue = "RBC log10"),
  cbind(R.diff[[1]], cue = "RBC"),
  cbind(I_log.diff[[1]], cue = "Asexual iRBC log10"),
  cbind(I.diff[[1]], cue = "Asexual iRBC"),
  cbind(Ig_log.diff[[1]], cue = "Sexual iRBC log10"),
  cbind(Ig.diff[[1]], cue = "Sexual iRBC"),
  cbind(I_Ig_log.diff[[1]], cue = "Total iRBC log10"),
  cbind(I_Ig.diff[[1]], cue = "Total iRBC")
)

## different data contenate
diff.df <- rbind(
  cbind(G_log.diff[[2]], cue = "Gametocyte log10"),
  cbind(G.diff[[2]], cue = "Gametocyte"),
  cbind(R_log.diff[[2]], cue = "RBC log10"),
  cbind(R.diff[[2]], cue = "RBC"),
  cbind(I_log.diff[[2]], cue = "Asexual iRBC log10"),
  cbind(I.diff[[2]], cue = "Asexual iRBC"),
  cbind(Ig_log.diff[[2]], cue = "Sexual iRBC log10"),
  cbind(Ig.diff[[2]], cue = "Sexual iRBC"),
  cbind(I_Ig_log.diff[[2]], cue = "Total iRBC log10"),
  cbind(I_Ig.diff[[2]], cue = "Total iRBC")
)


# plot conversion time series
fig2c <- ggplot() +
  geom_line(data = reference.df, aes(x = time, y = cr)) +
  geom_ribbon(data = diff.df, aes(x = time, ymin = cr_bot, ymax = cr_top), alpha = 0.3, fill = "red") +
  facet_wrap(~cue, ncol = 2) +
  labs(x = "Time (days)", y = "Conversion rate") +
  theme_bw()
  
# plot fitness timeseries. When if tiness lost? At the latter part
fig2d <- ggplot() +
  geom_line(data = reference.df, aes(x = time, y = tau)) +
  geom_ribbon(data = diff.df, aes(x = time, ymin = tau_bot, ymax = tau_top), alpha = 0.3, fill = "red") +
  facet_wrap(~cue, ncol = 2) +
  labs(x = "Time (days)", y = "Transmission potential") +
  theme_bw()

```



# plot togehter
```{r}
# arrange
fig2ab <- ggpubr::ggarrange(fig2a, fig2b, ncol = 2, widths = c(1.5,1), labels = c("A", "B"))
fig2cd <- ggpubr::ggarrange(fig2c, fig2d, labels = c("C", "D"))
fig2 <- ggpubr::ggarrange(fig2ab, fig2cd, ncol = 1)
ggsave(here("figures/report15/MC_simulation.png"), height = 8, width = 8)
```

#-------------------- partitioning MC-------------------------#

# general function that takes rand_var, rand_mean, and rand_sd to perform 1000 MC simulations
```{r}
partition_var <- function(par, cue, cue_range, log, rand_var, rand_mean, rand_sd, seed){
  # run 5 iterations each with 1000
    cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
    registerDoParallel(cl)
    registerDoRNG(seed)
    mc_res <- foreach(i= 1:1000, .packages = c("doParallel", "doRNG", "deSolve", "splines2", "stringr", "dplyr", "tidyr", "crone", "here")) %dorng% {
      
      # source function
      source(here("functions/chabaudi_si_clean.R"))
      
      # get parameter values that are stochastic
      rand <- rand_mean*exp(rnorm(n = 1, mean = 0, sd = rand_sd)) # proportion of RBC recovered

      # get different parameter set, each incorporating only 1 random variable
      if(rand_var == "rho"){
      parameters_tsukushi_rand <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = rand)
      }
      
      if(rand_var == "beta"){
      parameters_tsukushi_rand <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = rand, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156)
      }
      
      if(rand_var == "psin"){
      parameters_tsukushi_rand <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = rand,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156)
      }
      
      if(rand_var == "psiw"){
      parameters_tsukushi_rand <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = rand,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156)
      }
      
      if(rand_var == "phin"){
      parameters_tsukushi_rand <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = rand, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156)
      }
      
      if(rand_var == "phiw"){
      parameters_tsukushi_rand <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = rand,
                iota = 2.18*(10^6),
                rho = 0.2627156)
      }

      time_range <- seq(0, 20, by = 1e-3)
      
      # run dynamics
      chabaudi_si_clean(
        parameters_cr = par, 
        parameters = parameters_tsukushi_rand, 
        immunity = "tsukushi",
        time_range = time_range, 
        cue = cue, 
        cue_range = cue_range, 
        log_cue = log,
        solver = "vode",
        dyn = TRUE)
      
    }

   stopCluster(cl)
   
   # process data
  fitness.ls <- mclapply(mc_res, function(x){
    fitness <- x %>% 
      dplyr::filter(variable == "tau_cum") %>% 
      dplyr::summarise(max_fitness = max(value))
    
    return(fitness)
  })
  
  ## get fitness.df
  fitness.df <- do.call(rbind, fitness.ls)
  ## bind fitness.df with cue, log, and variable being randomized
 
  # get cue vs dynamics
  ## produce wide df for plotting cue vs cr graph
  df_wide.ls <- mclapply(mc_res, function(x){
    ## convert to wide
    wide <- tidyr::pivot_wider(x, names_from = variable, values_from = value, id_cols = c(time))
    ## get every 10th row
    wide_filtered <- wide %>% dplyr::filter(row_number() %% 10 == 1)
    return(wide_filtered)
  })
  
  # get wide list
  df_wide.df <- dplyr::bind_rows(df_wide.ls, .id = "id")
  ## bind with cue, log and variable being randomized
  df_wide.df <- cbind(df_wide.df, cue = cue, log = log, rand_var = rand_var)

  # return output
  return(list(fitness.df, df_wide.df))
}

```

# run 5 iterations of par_var
```{r}
mc_five2 <- function(par, cue, cue_range, log, rand_var, rand_mean, rand_sd){
  mc.1 <- partition_var(par = par,
                 cue = cue,
                 cue_range = cue_range,
                 log = log,
                 rand_var = rand_var,
                 rand_mean = rand_mean,
                 rand_sd = rand_sd, 
                 seed = 137)
  mc.2 <- partition_var(par = par,
                 cue = cue,
                 cue_range = cue_range,
                 log = log,
                 rand_var = rand_var,
                 rand_mean = rand_mean,
                 rand_sd = rand_sd, 
                 seed = 138)
  mc.3 <- partition_var(par = par,
                 cue = cue,
                 cue_range = cue_range,
                 log = log,
                 rand_var = rand_var,
                 rand_mean = rand_mean,
                 rand_sd = rand_sd, 
                 seed = 139)
  mc.4 <- partition_var(par = par,
                 cue = cue,
                 cue_range = cue_range,
                 log = log,
                 rand_var = rand_var,
                 rand_mean = rand_mean,
                 rand_sd = rand_sd, 
                 seed = 140)
  mc.5 <- partition_var(par = par,
                 cue = cue,
                 cue_range = cue_range,
                 log = log,
                 rand_var = rand_var,
                 rand_mean = rand_mean,
                 rand_sd = rand_sd, 
                 seed = 141)
  
  
  # get fitness
  fitness <- rbind(mc.1[[1]],mc.2[[1]],mc.3[[1]],mc.4[[1]],mc.5[[1]])

  # produce output for convergence of fitness
  ## get cum sum of fitness
  fitness.sum <- cumsum(fitness)
  ## get average fitness across iteration
  fitness.avg <- fitness.sum/(1:length(fitness.sum))
  
  # get wide data
  dyn <- rbind(
    cbind(mc.1[[2]], run = 1),
    cbind(mc.2[[2]], run = 2),
    cbind(mc.3[[2]], run = 3),
    cbind(mc.4[[2]], run = 4),
    cbind(mc.5[[2]], run = 5))
  
  # get unique id
  dyn <- dyn %>% 
    dplyr::mutate(run_id = paste0(run,"_", id, "_", rand_var))
  
  return(list(fitness, fitness.avg, dyn))
}
```

# function to run all 6 rand. 3rd nested function!
```{r}
get_par_MC <- function(par, cue, cue_range, log){
  # run MC with only rho
  res <- mc_five2(par = par,
                    cue = cue,
                    cue_range = cue_range,
                    log = log,
                    rand_var = "rho",
                    rand_mean = 0.2627156,
                    rand_sd = 0.2579136)
  
  fitness_name <- paste0("mc_par_", cue, "_", log, "_rho_fitness.csv")
  write.csv(res[[1]], here("data/MC_partitioned", fitness_name))
  
  dyn_name <- paste0("mc_par_", cue, "_", log, "_rho_dyn.parquet")
  write_parquet(res[[3]], here("data/MC_partitioned", dyn_name))
  
  # beta
  res <- mc_five2(par = par,
                    cue = cue,
                    cue_range = cue_range,
                    log = log,
                    rand_var = "beta",
                    rand_mean = 5.721,
                    rand_sd = 0.1722868)
  
  fitness_name <- paste0("mc_par_", cue, "_", log, "_beta_fitness.csv")
  write.csv(res[[1]], here("data/MC_partitioned", fitness_name))
  
  dyn_name <- paste0("mc_par_", cue, "_", log, "_beta_dyn.parquet")
  write_parquet(res[[3]], here("data/MC_partitioned", dyn_name))
  
  # psin
  res <- mc_five2(par = par,
                    cue = cue,
                    cue_range = cue_range,
                    log = log,
                    rand_var = "psin",
                    rand_mean = 16.69234,
                    rand_sd = 0.5778196)
  
  fitness_name <- paste0("mc_par_", cue, "_", log, "_psin_fitness.csv")
  write.csv(res[[1]], here("data/MC_partitioned", fitness_name))
  
  dyn_name <- paste0("mc_par_", cue, "_", log, "_psin_dyn.parquet")
  write_parquet(res[[3]], here("data/MC_partitioned", dyn_name))
  
  # psiw
  res <- mc_five2(par = par,
                    cue = cue,
                    cue_range = cue_range,
                    log = log,
                    rand_var = "psiw",
                    rand_mean = 0.8431785,
                    rand_sd = 0.2355804)
  
  fitness_name <- paste0("mc_par_", cue, "_", log, "_psiw_fitness.csv")
  write.csv(res[[1]], here("data/MC_partitioned", fitness_name))
  
  dyn_name <- paste0("mc_par_", cue, "_", log, "_psiw_dyn.parquet")
  write_parquet(res[[3]], here("data/MC_partitioned", dyn_name))
  
  # phin
  res <- mc_five2(par = par,
                    cue = cue,
                    cue_range = cue_range,
                    log = log,
                    rand_var = "phin",
                    rand_mean = 0.03520591,
                    rand_sd = 0.02609495)
  
  fitness_name <- paste0("mc_par_", cue, "_", log, "_phin_fitness.csv")
  write.csv(res[[1]], here("data/MC_partitioned", fitness_name))
  
  dyn_name <- paste0("mc_par_", cue, "_", log, "_phin_dyn.parquet")
  write_parquet(res[[3]], here("data/MC_partitioned", dyn_name))
  
  # phiw
  res <- mc_five2(par = par,
                    cue = cue,
                    cue_range = cue_range,
                    log = log,
                    rand_var = "phiw",
                    rand_mean = 550.842,
                    rand_sd = 0.8286213)
  
  fitness_name <- paste0("mc_par_", cue, "_", log, "_phiw_fitness.csv")
  write.csv(res[[1]], here("data/MC_partitioned", fitness_name))
  
  dyn_name <- paste0("mc_par_", cue, "_", log, "_phiw_dyn.parquet")
  write_parquet(res[[3]], here("data/MC_partitioned", dyn_name))
}
```


#------------- run the code!
```{r}
# I
# non-logged
get_par_MC(par = c(0.1135384,  -39.0585154, 1941.9082813,  119.8228980),
                    cue = "I",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none")

# logged
get_par_MC(par = c(5.463558,   2.383948, -17.757281,   4.571835),
                    cue = "I",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10")

# Ig
# non-logged
get_par_MC(par = c(0.05234791,  -46.03368629, 1897.61313455,   70.57689145),
                    cue = "Ig",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none")

# logged
get_par_MC(par = c(1.74633, -1.78582, -5.52834, 1.57344 ),
                    cue = "Ig",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10")

# I+Ig
get_par_MC(par = c(0.3159297,  -46.1104558, 1250.7529081,   -6.1982093),
                    cue = "I+Ig",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none")

get_par_MC(par = c(3.594042,   4.157744, -13.530672,   2.599905),
                    cue = "I+Ig",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10")
# G
# non-logged
get_par_MC(par = c(0.04061288,   -9.31445958,   74.13015506, -431.59843638),
                    cue = "G",
                    cue_range = seq(0, 6*(10^4), (6*(10^4))/5000),
                    log= "none")

get_par_MC(par = c(1.211521, -3.936778,-1.312944, -1.285713),
                    cue = "G",
                    cue_range = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000),
                    log= "log10")
# R
get_par_MC(par = c(7.0976026,  30.1295151, -28.0565613,  -0.2788713),
                    cue = "R",
                    cue_range = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000),
                    log= "none")
get_par_MC(par = c(48.70772, 105.18882, -81.80625, -44.60051),
                    cue = "R",
                    cue_range = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000),
                    log= "log10")
```


#---------------------------#
# co-infection optimization
#--------------------------#
Need to examine the following combinations:
1. I1 alone
2. I1 + I2
3. Ig1 alone
4. Ig1+Ig2
5. I1+Ig1 alone
6. sum (I1+I2+Ig1+Ig2)
7. G1 alone
8. G1+G2
9. R
```{r}
#----------I--------#
# nonlog
ci_I_opt <- co_infection_opt(parameters_cr = rep(0.5, 4),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "I1",
                             cue_2 = "I2",
                             cue_range_1 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                             cue_range_2 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")

erer::write.list(ci_I_opt, here("data/ci_opt/ci_I_opt.txt"))
#1.931059  -63.786820 1295.819775  -31.580440
#0.0009844663


test <-chabaudi_ci_clean(parameters_cr_1 = c(1.931059,  -63.786820, 1295.819775,  -31.580440),
                  parameters_cr_2 = c(1.572635,  -45.561616, 779.429608,  11.468115),
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "I1",
                             cue_2 = "I2",
                             cue_range_1 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                             cue_range_2 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")
```


```{r}
# log
ci_I_log_opt <- co_infection_opt(parameters_cr = rep(0.5, 4),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "I1",
                             cue_2 = "I2",
                             cue_range_1 = seq(0, log10(6*(10^6)), by = log10(6*(10^6))/5000),
                             cue_range_2 = seq(0, log10(6*(10^6)), by = log10(6*(10^6))/5000),
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")
erer::write.list(ci_I_log_opt, here("data/ci_opt/ci_I_log_opt.txt"))
#381.7701,-528.2317,-324.5508,-403.8235
```


```{r}
#----------- I1+I2
ci_I1_I2_opt <- co_infection_opt(parameters_cr = c(1.972578, -47.763100, 640.414152, -12.177047),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "I1+I2",
                             cue_2 = "I1+I2",
                             cue_range_1 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                             cue_range_2 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")
erer::write.list(ci_I1_I2_opt, here("data/ci_opt/ci_I1_I2_opt.txt"))
# 1: 1.972578 -47.763100 640.414152 -12.177047
# 2: 1.98219 -24.8733 193.375 -33.4819  (0.6436819 diff)
# 3: 2.02704 -27.182 193.185 -33.4892 (0.124252 diff)
# 4: 1.93507 -37.3871 376.59 -27.7111 (0.077143 diff)
# 5: 1.94476 -46.0747 603.14 -20.1892 (0.1044941)
# 6: 2.0125 -24.6041 187.759 -41.7831 (0.5960287)
#1.99546 -25.2332 167.509 -40.9867 (0.1463846)
# 1.92808 -36.2342 351.969 -32.7568 (0.0902934)
#1.96598 -47.1496 621.223 -27.3944 (0.112605)
```


```{r}
ci_I1_I2_log_opt <- co_infection_opt(parameters_cr = rep(0.5, 4),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "I1+I2",
                             cue_2 = "I1+I2",
                             cue_range_1 = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                             cue_range_2 = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")
erer::write.list(ci_I1_I2_log_opt, here("data/ci_opt/ci_I1_I2_log_opt.txt"))
#404.6170 -529.2684 -365.0516 -417.0552
#0.001341288
```


```{r}
#--------------Ig1 alone
ci_Ig_opt <- co_infection_opt(parameters_cr = rep(0.5, 4),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "Ig1",
                             cue_2 = "Ig2",
                             cue_range_1 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                             cue_range_2 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")
#1.096857  -80.496897 1412.461014    3.463079
#0.007282484
```


```{r}
#
ci_Ig_log_opt <- co_infection_opt(parameters_cr = c(35.6294, -65.6898, -11.5609, -52.0779),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "Ig1",
                             cue_2 = "Ig2",
                             cue_range_1 = seq(0, log10(6*(10^6)), by = log10(6*(10^6))/5000),
                             cue_range_2 = seq(0, log10(6*(10^6)), by = log10(6*(10^6))/5000),
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")
#35.6294 -65.6898 -11.5609 -52.0779 
```


```{r}
#--------------Ig1+Ig2
ci_Ig1_Ig2_opt <- co_infection_opt(parameters_cr = rep(0.5, 4),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "Ig1+Ig2",
                             cue_2 = "Ig1+Ig2",
                             cue_range_1 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                             cue_range_2 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")
# 1.506671 -88.902499 337.507606  11.190877 (0.2543592)
# 1.53278 -1042.41 342.572 10.1707 (0.167393)
# 0.247449 -8.45154 0.659347 -5.05097 (4.954811)
# 1.06745 -29.5788 435.027 2.71807 (2.782235)
# 0.809145 -29.578476 435.027531   2.718066 (0.6013032)
```


```{r}
ci_Ig1_Ig2_log_opt <- co_infection_opt(parameters_cr = rep(0.5, 4),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "Ig1+Ig2",
                             cue_2 = "Ig1+Ig2",
                             cue_range_1 = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                             cue_range_2 = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")
#75.73915 -128.01549  -41.16782  -96.21549

#----------------sum
ci_sum_opt <- co_infection_opt(parameters_cr = rep(0.5, 4),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "sum",
                             cue_2 = "sum",
                             cue_range_1 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                             cue_range_2 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")

#1.86014   -25.61573   257.60126 -2823.09564
ci_sum_log_opt <- co_infection_opt(parameters_cr = rep(0.5, 4),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "sum",
                             cue_2 = "sum",
                             cue_range_1 = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                             cue_range_2 = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")

#435.1835 -565.3985 -395.7242 -446.5950
#--------------G1 only
ci_G_opt <- co_infection_opt(parameters_cr = rep(0.5, 4),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "G1",
                             cue_2 = "G2",
                             cue_range_1 = seq(0, 6*(10^4), (6*(10^4))/5000),
                             cue_range_2 = seq(0, 6*(10^4), (6*(10^4))/5000),
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")
# 1.352967 -165.891572   61.230266   -7.374788

ci_G_log_opt <- co_infection_opt(parameters_cr = rep(0.5, 4),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "G1",
                             cue_2 = "G2",
                             cue_range_1 = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000),
                             cue_range_2 = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000),
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")

# 1.762225 -4.329505  2.548675 -6.726894

#---------------G1+G2
ci_G1_G2_opt <- co_infection_opt(parameters_cr = rep(0.5, 4),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "G1+G2",
                             cue_2 = "G1+G2",
                             cue_range_1 = seq(0, 6*(10^4), (6*(10^4))/5000),
                             cue_range_2 = seq(0, 6*(10^4), (6*(10^4))/5000),
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")
# 3.05668 -5077.22092   585.42826 -8703.57817

ci_G1_G2_log_opt <- co_infection_opt(parameters_cr = rep(0.5, 4),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "G1+G2",
                             cue_2 = "G1+G2",
                             cue_range_1 = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000),
                             cue_range_2 = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000),
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")
#12.106219 -21.043524  -5.010265 -16.928459

#---------------R
ci_R_opt <- co_infection_opt(parameters_cr = rep(0.5, 4),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "R",
                             cue_2 = "R",
                             cue_range_1 = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000),
                             cue_range_2 = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000),
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")
#-88.36793 136.04925  65.44548  98.14261

ci_R_log_opt <- co_infection_opt(parameters_cr = rep(0.5, 4),
                             limit = 0.01,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "R",
                             cue_2 = "R",
                             cue_range_1 = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000),
                             cue_range_2 = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000),
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")
#-971.1975 1175.9801  931.5406  978.0870

```



