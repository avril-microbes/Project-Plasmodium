---
title: "report15"
output: html_document
---
```{r}
library(dplyr)
library(ggplot2)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
```


# load parameter
```{r}
source(here("functions/par_to_df.R"))
source(here("functions/chabaudi_si_clean.R"))

parameters_tsukushi <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156)

time_range <- seq(0, 20, by = 1e-3)
```

#-------------------------------------#
# Repeat optimization attempt
#--------------------------------------#
I resubmitted my compute canada jobs with even more limited cue range. These are based on the experimental values derived from single infection with drug resistant P. chabaudi to the nearest "whole number" in terms of scientific notation. 

iRBC: 0-6*(10^6)
GL 0-6*(10^4)
RBC: (10^6)-(10^7). Here the max RBC value is set to less than experimental max given our max RBC density is set to 8.89*10^6

Overall, much better performance. Need to wait for GA to come back though.

Note that GA converged with the results with the L-BFGS so might stick with L-BFGS for now.
# function for local L-BFGS optimization
```{r}
opt_local <- function(
  par, # initial parameter sets
  cue, #
  log,
  cue_range,
  dyn = F
  ){
  # start cluster
  cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
  
  # start optimization LFBGS
  res <- optimParallel(
    par = par,
    fn = chabaudi_si_clean, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = time_range,
    cue = cue,
    log_cue = log,
    cue_range = cue_range,
    solver = "vode")
  
  # close cluster
  stopCluster(cl)
  
  return (res)
}
```

# I non-logged
```{r}
I_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "I",
                            log = "none",
                            cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))
#0.1135384  -39.0585154 1941.9082813  119.8228980
#8.49777
```

# I logged
```{r}
I_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "I",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

#5.463558   2.383948 -17.757281   4.571835
#9.494991
```

# Ig
```{r}
Ig_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "Ig",
                            log = "none",
                            cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))
# 0.05234791  -46.03368629 1897.61313455   70.57689145
# 8.569285
```

# Ig logged
```{r}
Ig_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "Ig",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))
#1.746334 -1.785818 -5.528335  1.573436
# 9.618812
```

# I + Ig
```{r}
I_Ig_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "I+Ig",
                            log = "none",
                            cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))

#0.3159297  -46.1104558 1250.7529081   -6.1982093
# 8.854682
```

# I+Ig logged
```{r}
Ig_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "Ig+I",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))
#1.746334 -1.785818 -5.528335  1.573436
#9.618812
```

# I logged
```{r}
I_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "I",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

#5.463558   2.383948 -17.757281   4.571835
#9.494991
```

# RBC non-logged
```{r}
R_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "R",
                            log = "none",
                            cue_range = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000))
#7.0976026  30.1295151 -28.0565613  -0.2788713
#8.23991
```

# RBC logged
```{r}
R_loc_log.op <- opt_local(par = rep(0.5, 4),
                            cue = "R",
                            log = "log10",
                            cue_range = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000))
#48.70772 105.18882 -81.80625 -44.60051
#8.181604
```

# G non-logged
GA have same result
```{r}
G_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "G",
                            log = "none",
                            cue_range = seq(0, 6*(10^4), (6*(10^4))/5000))
#0.04061288   -9.31445958   74.13015506 -431.59843638
#8.58856
```

# G logged
```{r}
G_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "G",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000))
#1.211521 -3.936778 -1.312944 -1.285713
#9.561373
```

#-------------------------------#
# Writing the code to optimize co-infection
#-------------------------------#
We cannot use GA for optimizing co-infection data given that each individual iteration would take too long. Here, what we acn do is to perform local co-infection optimization using L-BFGS but repeat it many times using different initial values. For each initial value, we would get an "optimum" parameter set. We can then compete all the optimum parameter set with each other (n*(n-1)/2 competitions). If the focal parameter set wins, we assign the parameter set a value of 1 and lossage results in 0. For each parameter set we can then sum up its total point in the competition, with the maximum point being n-1 and the lowest point being 0.

The optimum parameter set would be the parameter with the highest score.

If this is too much, then we could stick with local optimization but acknowledging the caveats

we need to test out the following combo
1) both competitors adopting the same cue
I1+I2, Ii (only recognize self), G1+G2, Gi, R and their logged counterpart
2) different cues adoption
across all combo

# function to perform all co-infection combo
```{r}
do_ci_combo <- function(cue_1, cue_2, par, limit){
  
  # get df full of model requirements. Do all combinations
  par_df <- expand.grid(
  cue_1 = cue_1,
  cue_2 = cue_2,
  log_1 = c("none", "log10"),
  log_2 = c("none", "log10"))
  
  # run paralellized L-BFGS across the different permutations. Note that cluster iniation is included in the co_infection_opt function
  output <- mapply(function(x, y, z, k){
    ## get cue range based on cue
    if(z == "none"){
      if(x == "I1" | x == "Ig1" | x == "I1+I2" | x == "Ig1+Ig2" | x == "sum"){cue_range_1 = seq(0, 6*(10^6), by = (6*(10^6))/5000)}
      if(x == "R"){cue_range_1 = seq(10^6, 10^7, ((10^7)-(10^6))/5000)}
      if(x == "G1" | x == "G1+G2"){cue_range_1 = seq(0, 6*(10^4), by = (6*(10^4))/5000)}
    }
    if(z == "log10"){
      if(x == "I1" | x == "Ig1" | x == "I1+I2" | x == "Ig1+Ig2" | x == "sum"){cue_range_1 = seq(0, log10(6*(10^6)), by = log10(6*(10^6))/5000)}
      if(x == "R"){cue_range_1 = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000)}
      if(x == "G1" | x == "G1+G2"){cue_range_1 = seq(0, log10(6*(10^4)), by = log10((6*(10^4)))/5000)}
    }

    if(k == "none"){
      if(y == "I2" | y == "Ig2" | y == "I1+I2" | y == "Ig1+Ig2" | y == "sum"){cue_range_2 = seq(0, 6*(10^6), by = (6*(10^6))/5000)}
      if(y == "R"){cue_range_2 = seq(10^6, 10^7, ((10^7)-(10^6))/5000)}
      if(y == "G2" | y == "G1+G2"){cue_range_2 = seq(0, 6*(10^4), by = (6*(10^4))/5000)}
    }
    if(k == "log10"){
      if(y == "I2" | y == "Ig2" | y == "I1+I2" | y == "Ig1+Ig2" | y == "sum"){cue_range_2 = seq(0, log10(6*(10^6)), by = log10(6*(10^6))/5000)}
      if(y == "R"){cue_range_2 = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000)}
      if(y == "G2" | y == "G1+G2"){cue_range_2 = seq(0, log10(6*(10^4)), by = (log10(6*(10^4)))/5000)}
    }
    
    co_infection_opt(parameters_cr = par,
                 limit = limit, 
                 model = chabaudi_ci_clean,
                 immunity = "tsukushi",
                 parameters = parameters_tsukushi,
                 time_range = time_range,
                 cue_1 = x,
                 cue_2 = y,
                 cue_range_1 = cue_range_1,
                 cue_range_2 = cue_range_2,
                 solver = "vode",
                 log_cue_1 = z,
                 log_cue_2 = k)}, x = par_df$cue_1, y = par_df$cue_2, z = par_df$log_1, k = par_df$log_2, SIMPLIFY = F)
  return(output)
}


```

# run all possible combo of compeition with different cues
```{r}
source(here("functions/chabaudi_ci_clean.R"))
source(here("functions/co_infection_opt.R"))

co_infection_opt(parameters_cr = rep(0.5,4),
                 limit = 0.01, 
                 model = chabaudi_ci_clean,
                 immunity = "tsukushi",
                 parameters = parameters_tsukushi,
                 time_range = time_range,
                 cue_1 = "sum",
                 cue_2 = "Ig1",
                 cue_range_1 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                 cue_range_2 = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                 solver = "vode",
                 log_cue_1 = "none",
                 log_cue_2 = "none")


test <- do_ci_combo(cue_1 = c("I1+I2"),
                          cue_2 = c("sum"),
                          par = rep(0.5, 4),
                          limit = 0.01)

ci_opt.raw <- do_ci_combo(cue_1 = c("I1", "I1+I2", "Ig1", "Ig1+Ig2", "sum", "G1", "G1+G2", "R"),
                          cue_2 = c("I2", "I1+I2", "Ig2", "Ig1+Ig2", "sum", "G2", "G1+G2", "R"),
                          par = rep(0.5, 4),
                          limit = 0.001)
```

#----------------------#
# Repeat MC using updated parameters
#---------------------#

# this time, for each iteration, the parameter values are drawn from the log-normal distribution. Hence, through out an entire infection, we have the same parameter. However, the value differs between runs

# MC function for 1000 iterations
```{r}
mc_run <- function(par, cue, cue_range, log, seed){
  # run 5 iterations each with 1000
    cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
    registerDoParallel(cl)
    registerDoRNG(seed)
    mc_res <- foreach(i= 1:5, .packages = c("doParallel", "doRNG", "deSolve", "splines2", "stringr", "dplyr", "tidyr", "crone", "here")) %dorng% {
      
      # source function
      source(here("functions/chabaudi_si_clean.R"))
      
      # get parameter values that are stochastic
      rho_rand <- 0.2627156*exp(rnorm(n = 1, mean = 0, sd = 0.2579136)) # proportion of RBC recovered
      beta_rand <- 5.721*exp(rnorm(n = 1, mean = 0, sd = 0.1722868)) # burst size
      psin_rand <- 16.69234*exp(rnorm(n = 1, mean = 0, sd = 0.5778196))
      psiw_rand <- 0.8431785*exp(rnorm(n = 1, mean = 0, sd = 0.2355804))
      phin_rand <- 0.03520591*exp(rnorm(n = 1, mean = 0, sd = 0.02609495))
      phiw_rand <- 550.842*exp(rnorm(n = 1, mean = 0, sd = 0.8286213))

      parameters_tsukushi <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025,
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = beta_rand, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = psin_rand,
                psiw = psiw_rand,
                phin = phin_rand, 
                phiw = phiw_rand,
                iota = 2.18*(10^6),
                rho = rho_rand)

      time_range <- seq(0, 20, by = 1e-3)
      
      # run dynamics
      chabaudi_si_clean(
        parameters_cr = par, 
        parameters = parameters_tsukushi, 
        immunity = "tsukushi",
        time_range = time_range, 
        cue = cue, 
        cue_range = cue_range, 
        log_cue = log,
        solver = "vode",
        dyn = TRUE)
      
    }

   stopCluster(cl)
   
   # process data
  fitness.ls <- mclapply(mc_res, function(x){
    fitness <- x %>% 
      dplyr::filter(variable == "tau_cum") %>% 
      dplyr::summarise(max_fitness = max(value))
    
    return(fitness)
  })
  
  ## get fitness.df
  fitness.df <- do.call(rbind, fitness.ls)
 
  # get cue vs dynamics
  ## produce wide df for plotting cue vs cr graph
  df_wide.ls <- mclapply(mc_res, function(x){
    ## convert to wide
    wide <- tidyr::pivot_wider(x, names_from = variable, values_from = value, id_cols = c(time))
    ## get every 10th row
    wide_filtered <- wide %>% dplyr::filter(row_number() %% 10 == 1)
    return(wide_filtered)
  })
  
  # get wide list
  df_wide.df <- dplyr::bind_rows(df_wide.ls, .id = "id")

  # return output
  return(list(fitness.df, df_wide.df))
}
```

# test
```{r}
test <- mc_run(par = c(1.211521, -3.936778, -1.312944, -1.285713), 
                   cue = "G", 
                   cue_range = seq(0, log10(6*(10^4)), by = log10(6*(10^4))/5000), 
                   log = "log10", 
                   seed = 137)

test
  
```




