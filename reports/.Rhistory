dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(x = cue_range, degree = 3))
dummy_cr.mod$data <- dummy_cr.data
# assign coefficient to be optimized to the dummy conversion rate function
dummy_cr.mod$coefficients <- rep(0.5,4)
# trying heaviside transformation
cr_pred <- predict(dummy_cr.mod, newdata = data.frame(cue_range))
cr_trans <- crone::heaviside(cr_pred)*(cr_pred)+(crone::heaviside(cr_pred-1)*(1-cr_pred))
# fit spline function to predicted conversion rate. This increases processing speed
cr_fun <- splinefun(cbind(cue_range, cr_trans))
return(cr_fun)
}
# get dataframe of all permutation of parameter values and their position
par.df <- expand.grid(n = c(1,2,3,4), par = par_seq)
# substitute each value within the 4 parameters with par_seq (generate all iterations)
changed_par <- mapply(function(x, y){
## define original parameter
par_trans <- rep(0.5,4)
## change according to df
par_trans[[x]] <- y
return(par_trans)
}, x = par.df$n, y = par.df$par)
# convert matrix (each column) into a list of parameters
par.ls <- lapply(seq_len(ncol(changed_par)), function(i) changed_par[,i])
#get a list of splines form the transformed parameter lists
spline.ls <- lapply(par.ls, function(x){
get_spline(par = x, cue_range = cue_range)
})
return(spline.ls)
}
spline_par(par_seq = seq(-10, 10, by = 1), cue_range = test_range)
test_spline <- spline_par(par_seq = seq(-10, 10, by = 1), cue_range = test_range)
test_spline
test_spline
spline_par <- function(
par_seq, # range of parameters we want to test
cue_range) # cue_range optimized over
{
get_spline <- function(par, cue_range){
# create dummy model
dummy_y.vals <- rep(0, length(cue_range))
dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
# fit basic cubic spline with no internal knots.
dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(x = cue_range, degree = 3))
dummy_cr.mod$data <- dummy_cr.data
# assign coefficient to be optimized to the dummy conversion rate function
dummy_cr.mod$coefficients <- rep(0.5,4)
# trying heaviside transformation
cr_pred <- predict(dummy_cr.mod, newdata = data.frame(cue_range))
cr_trans <- crone::heaviside(cr_pred)*(cr_pred)+(crone::heaviside(cr_pred-1)*(1-cr_pred))
# fit spline function to predicted conversion rate. This increases processing speed
cr_fun <- splinefun(cbind(cue_range, cr_trans))
return(cr_fun)
}
# get dataframe of all permutation of parameter values and their position
par.df <- expand.grid(n = c(1,2,3,4), par = par_seq)
# substitute each value within the 4 parameters with par_seq (generate all iterations)
changed_par <- mapply(function(x, y){
## define original parameter
par_trans <- rep(0.5,4)
## change according to df
par_trans[[x]] <- y
return(par_trans)
}, x = par.df$n, y = par.df$par)
# convert matrix (each column) into a list of parameters
par.ls <- lapply(seq_len(ncol(changed_par)), function(i) changed_par[,i])
#get a list of splines form the transformed parameter lists
spline.ls <- lapply(par.ls, function(x){
get_spline(par = x, cue_range = cue_range)
})
return(spline.ls)
}
spline_par <- function(
par_seq, # range of parameters we want to test
cue_range) # cue_range optimized over
{
get_spline <- function(par, cue_range){
# create dummy model
dummy_y.vals <- rep(0, length(cue_range))
dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
# fit basic cubic spline with no internal knots.
dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(x = cue_range, degree = 3))
dummy_cr.mod$data <- dummy_cr.data
# assign coefficient to be optimized to the dummy conversion rate function
dummy_cr.mod$coefficients <- rep(0.5,4)
# trying heaviside transformation
cr_pred <- predict(dummy_cr.mod, newdata = data.frame(cue_range))
cr_trans <- crone::heaviside(cr_pred)*(cr_pred)+(crone::heaviside(cr_pred-1)*(1-cr_pred))
# fit spline function to predicted conversion rate. This increases processing speed
cr_fun <- splinefun(cbind(cue_range, cr_trans))
return(cr_fun)
}
# get dataframe of all permutation of parameter values and their position
par.df <- expand.grid(n = c(1,2,3,4), par = par_seq)
## paste0 to get id
par.df$id <- paste0(par.df$n, "_", par.df$par)
# substitute each value within the 4 parameters with par_seq (generate all iterations)
changed_par <- mapply(function(x, y){
## define original parameter
par_trans <- rep(0.5,4)
## change according to df
par_trans[[x]] <- y
return(par_trans)
}, x = par.df$n, y = par.df$par)
# convert matrix (each column) into a list of parameters
par.ls <- lapply(seq_len(ncol(changed_par)), function(i) changed_par[,i])
#get a list of splines form the transformed parameter lists
spline.ls <- lapply(par.ls, function(x){
get_spline(par = x, cue_range = cue_range)
})
return(list(spline.ls, par.df))
}
test_spline <- spline_par(par_seq = seq(-10, 10, by = 1), cue_range = test_range)
test_spline
test_spline[[2]]$id
mapply(function(x, y){
df <- data.frame(cue = cue_range, cr = x(cue_range), group = y)
return(df)},
x = test_spline[[1]], y = test_spline[[2]]$id
)
mapply(function(x, y){
df <- as.data.frame(cue = cue_range, cr = x(cue_range), group = y)
return(df)},
x = test_spline[[1]], y = test_spline[[2]]$id
)
mapply(function(x, y){
df <- data.frame(cue = cue_range, cr = x(cue_range), group = y)
return(df)},
x = test_spline[[1]], y = test_spline[[2]]$id
)
test_res <- mapply(function(x, y){
df <- data.frame(cue = cue_range, cr = x(cue_range), group = y)
return(df)},
x = test_spline[[1]], y = test_spline[[2]]$id
)
test_res[[1]]
test_res[1]
test_res <- mapply(function(x, y){
data.frame(cue = cue_range, cr = x(cue_range), group = y)},
x = test_spline[[1]], y = test_spline[[2]]$id
)
test_res[1]
test_res
test_res <- mapply(function(x, y){
cbind(cue = cue_range, cr = x(cue_range), group = y)},
x = test_spline[[1]], y = test_spline[[2]]$id
)
test_res
cue_range <- test_ragne
cue_range <- test_range
test_res <- mapply(function(x, y){
data.frame(cue = cue_range, cr = x(cue_range), group = y)},
x = test_spline[[1]], y = test_spline[[2]]$id
)
test_res
test_res[,1]
do.call(test_res, rbind)
t(test_res)
t(test_res) %>% as_tibble()
test_res
test_res <- mapply(function(x, y){
as.data.frame(data.frame(cue = cue_range, cr = x(cue_range), group = y))},
x = test_spline[[1]], y = test_spline[[2]]$id
)
test_res
test_res <- mapply(function(x, y){
data.frame(cue = cue_range, cr = x(cue_range), group = y)},
x = test_spline[[1]], y = test_spline[[2]]$id
)
test_res
lapply(test_res, function(i) test_res[,i])
length(test_res)
lapply(seq_len(length(test_res)), function(i) test_res[,i])
test_res
ncol(test_res)
lapply(seq_len(ncol(test_res)), function(i) test_res[,i])
test_range <- seq(0, 10^7, by = (10^7)/100)
test_spline <- spline_par(par_seq = seq(-10, 10, by = 1), cue_range = test_range)
test_res <- mapply(function(x, y){
data.frame(cue = cue_range, cr = x(cue_range), group = y)},
x = test_spline[[1]], y = test_spline[[2]]$id
)
lapply(seq_len(ncol(test_res)), function(i) test_res[,i])
df_res <- lapply(seq_len(ncol(test_res)), function(i) test_res[,i])
do.call(df_res, rbind)
do.call(rbind, df_res)
df_res[[1]]
df_res <- lapply(seq_len(ncol(test_res)), function(i){
df <- test_res[,i]
df_cat <- data.frame(cbind(cue = df$cue, cr = df$cr, group = df$group))
return(df_cat)
} )
df_res[[1]]
do.call(rbind, df_res)
spline_par <- function(
par_seq, # range of parameters we want to test
cue_range) # cue_range optimized over
{
get_spline <- function(par, cue_range){
# create dummy model
dummy_y.vals <- rep(0, length(cue_range))
dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
# fit basic cubic spline with no internal knots.
dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(x = cue_range, degree = 3))
dummy_cr.mod$data <- dummy_cr.data
# assign coefficient to be optimized to the dummy conversion rate function
dummy_cr.mod$coefficients <- rep(0.5,4)
# trying heaviside transformation
cr_pred <- predict(dummy_cr.mod, newdata = data.frame(cue_range))
cr_trans <- crone::heaviside(cr_pred)*(cr_pred)+(crone::heaviside(cr_pred-1)*(1-cr_pred))
# fit spline function to predicted conversion rate. This increases processing speed
cr_fun <- splinefun(cbind(cue_range, cr_trans))
return(cr_fun)
}
# get dataframe of all permutation of parameter values and their position
par.df <- expand.grid(n = c(1,2,3,4), par = par_seq)
## paste0 to get id
par.df$id <- paste0(par.df$n, "_", par.df$par)
# substitute each value within the 4 parameters with par_seq (generate all iterations)
changed_par <- mapply(function(x, y){
## define original parameter
par_trans <- rep(0.5,4)
## change according to df
par_trans[[x]] <- y
return(par_trans)
}, x = par.df$n, y = par.df$par)
# convert matrix (each column) into a list of parameters
par.ls <- lapply(seq_len(ncol(changed_par)), function(i) changed_par[,i])
#get a list of splines form the transformed parameter lists
spline.ls <- lapply(par.ls, function(x){
get_spline(par = x, cue_range = cue_range)
})
# convert spline to dataframe
spline_int.ls <- mapply(function(x, y){
data.frame(cue = cue_range, cr = x(cue_range), group = y)},
x = spline.ls[[1]], y = spline.ls[[2]]$id)
# convert to df.ls
df.ls <- lapply(seq_len(ncol(spline_int.ls)), function(i){
df_cat <- data.frame(cbind(cue = df$cue, cr = df$cr, group = df$group))
return(df_cat)
} )
res <- do.call(rbind, df.ls)
return(res)
}
test_spline <- spline_par(par_seq = seq(-10, 10, by = 1), cue_range = test_range)
test_range <- seq(0, 10^7, by = (10^7)/100)
test_spline <- spline_par(par_seq = seq(-10, 10, by = 1), cue_range = test_range)
spline_par <- function(
par_seq, # range of parameters we want to test
cue_range) # cue_range optimized over
{
get_spline <- function(par, cue_range){
# create dummy model
dummy_y.vals <- rep(0, length(cue_range))
dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
# fit basic cubic spline with no internal knots.
dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(x = cue_range, degree = 3))
dummy_cr.mod$data <- dummy_cr.data
# assign coefficient to be optimized to the dummy conversion rate function
dummy_cr.mod$coefficients <- rep(0.5,4)
# trying heaviside transformation
cr_pred <- predict(dummy_cr.mod, newdata = data.frame(cue_range))
cr_trans <- crone::heaviside(cr_pred)*(cr_pred)+(crone::heaviside(cr_pred-1)*(1-cr_pred))
# fit spline function to predicted conversion rate. This increases processing speed
cr_fun <- splinefun(cbind(cue_range, cr_trans))
return(cr_fun)
}
# get dataframe of all permutation of parameter values and their position
par.df <- expand.grid(n = c(1,2,3,4), par = par_seq)
## paste0 to get id
par.df$id <- paste0(par.df$n, "_", par.df$par)
# substitute each value within the 4 parameters with par_seq (generate all iterations)
changed_par <- mapply(function(x, y){
## define original parameter
par_trans <- rep(0.5,4)
## change according to df
par_trans[[x]] <- y
return(par_trans)
}, x = par.df$n, y = par.df$par)
# convert matrix (each column) into a list of parameters
par.ls <- lapply(seq_len(ncol(changed_par)), function(i) changed_par[,i])
#get a list of splines form the transformed parameter lists
spline.ls <- lapply(par.ls, function(x){
get_spline(par = x, cue_range = cue_range)
})
# convert spline to dataframe
spline_int.ls <- mapply(function(x, y){
data.frame(cue = cue_range, cr = x(cue_range), group = y)},
x = spline.ls[[1]], y = par.df[[2]]$id)
# convert to df.ls
df.ls <- lapply(seq_len(ncol(spline_int.ls)), function(i){
df_cat <- data.frame(cbind(cue = df$cue, cr = df$cr, group = df$group))
return(df_cat)
} )
res <- do.call(rbind, df.ls)
return(res)
}
test_spline <- spline_par(par_seq = seq(-10, 10, by = 1), cue_range = test_range)
spline_par <- function(
par_seq, # range of parameters we want to test
cue_range) # cue_range optimized over
{
get_spline <- function(par, cue_range){
# create dummy model
dummy_y.vals <- rep(0, length(cue_range))
dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
# fit basic cubic spline with no internal knots.
dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(x = cue_range, degree = 3))
dummy_cr.mod$data <- dummy_cr.data
# assign coefficient to be optimized to the dummy conversion rate function
dummy_cr.mod$coefficients <- rep(0.5,4)
# trying heaviside transformation
cr_pred <- predict(dummy_cr.mod, newdata = data.frame(cue_range))
cr_trans <- crone::heaviside(cr_pred)*(cr_pred)+(crone::heaviside(cr_pred-1)*(1-cr_pred))
# fit spline function to predicted conversion rate. This increases processing speed
cr_fun <- splinefun(cbind(cue_range, cr_trans))
return(cr_fun)
}
# get dataframe of all permutation of parameter values and their position
par.df <- expand.grid(n = c(1,2,3,4), par = par_seq)
## paste0 to get id
par.df$id <- paste0(par.df$n, "_", par.df$par)
# substitute each value within the 4 parameters with par_seq (generate all iterations)
changed_par <- mapply(function(x, y){
## define original parameter
par_trans <- rep(0.5,4)
## change according to df
par_trans[[x]] <- y
return(par_trans)
}, x = par.df$n, y = par.df$par)
# convert matrix (each column) into a list of parameters
par.ls <- lapply(seq_len(ncol(changed_par)), function(i) changed_par[,i])
#get a list of splines form the transformed parameter lists
spline.ls <- lapply(par.ls, function(x){
get_spline(par = x, cue_range = cue_range)
})
# convert spline to dataframe
spline_int.ls <- mapply(function(x, y){
data.frame(cue = cue_range, cr = x(cue_range), group = y)},
x = spline.ls[[1]], y = par.df$id)
# convert to df.ls
df.ls <- lapply(seq_len(ncol(spline_int.ls)), function(i){
df_cat <- data.frame(cbind(cue = df$cue, cr = df$cr, group = df$group))
return(df_cat)
} )
res <- do.call(rbind, df.ls)
return(res)
}
test_spline <- spline_par(par_seq = seq(-10, 10, by = 1), cue_range = test_range)
spline_par <- function(
par_seq, # range of parameters we want to test
cue_range) # cue_range optimized over
{
get_spline <- function(par, cue_range){
# create dummy model
dummy_y.vals <- rep(0, length(cue_range))
dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
# fit basic cubic spline with no internal knots.
dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(x = cue_range, degree = 3))
dummy_cr.mod$data <- dummy_cr.data
# assign coefficient to be optimized to the dummy conversion rate function
dummy_cr.mod$coefficients <- rep(0.5,4)
# trying heaviside transformation
cr_pred <- predict(dummy_cr.mod, newdata = data.frame(cue_range))
cr_trans <- crone::heaviside(cr_pred)*(cr_pred)+(crone::heaviside(cr_pred-1)*(1-cr_pred))
# fit spline function to predicted conversion rate. This increases processing speed
cr_fun <- splinefun(cbind(cue_range, cr_trans))
return(cr_fun)
}
# get dataframe of all permutation of parameter values and their position
par.df <- expand.grid(n = c(1,2,3,4), par = par_seq)
## paste0 to get id
par.df$id <- paste0(par.df$n, "_", par.df$par)
# substitute each value within the 4 parameters with par_seq (generate all iterations)
changed_par <- mapply(function(x, y){
## define original parameter
par_trans <- rep(0.5,4)
## change according to df
par_trans[[x]] <- y
return(par_trans)
}, x = par.df$n, y = par.df$par)
# convert matrix (each column) into a list of parameters
par.ls <- lapply(seq_len(ncol(changed_par)), function(i) changed_par[,i])
#get a list of splines form the transformed parameter lists
spline.ls <- lapply(par.ls, function(x){
get_spline(par = x, cue_range = cue_range)
})
# convert spline to dataframe
spline_int.ls <- mapply(function(x, y){
data.frame(cue = cue_range, cr = x(cue_range), group = y)},
x = spline.ls, y = par.df$id)
# convert to df.ls
df.ls <- lapply(seq_len(ncol(spline_int.ls)), function(i){
df_cat <- data.frame(cbind(cue = df$cue, cr = df$cr, group = df$group))
return(df_cat)
} )
res <- do.call(rbind, df.ls)
return(res)
}
test_spline <- spline_par(par_seq = seq(-10, 10, by = 1), cue_range = test_range)
spline_par <- function(
par_seq, # range of parameters we want to test
cue_range) # cue_range optimized over
{
get_spline <- function(par, cue_range){
# create dummy model
dummy_y.vals <- rep(0, length(cue_range))
dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
# fit basic cubic spline with no internal knots.
dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(x = cue_range, degree = 3))
dummy_cr.mod$data <- dummy_cr.data
# assign coefficient to be optimized to the dummy conversion rate function
dummy_cr.mod$coefficients <- rep(0.5,4)
# trying heaviside transformation
cr_pred <- predict(dummy_cr.mod, newdata = data.frame(cue_range))
cr_trans <- crone::heaviside(cr_pred)*(cr_pred)+(crone::heaviside(cr_pred-1)*(1-cr_pred))
# fit spline function to predicted conversion rate. This increases processing speed
cr_fun <- splinefun(cbind(cue_range, cr_trans))
return(cr_fun)
}
# get dataframe of all permutation of parameter values and their position
par.df <- expand.grid(n = c(1,2,3,4), par = par_seq)
## paste0 to get id
par.df$id <- paste0(par.df$n, "_", par.df$par)
# substitute each value within the 4 parameters with par_seq (generate all iterations)
changed_par <- mapply(function(x, y){
## define original parameter
par_trans <- rep(0.5,4)
## change according to df
par_trans[[x]] <- y
return(par_trans)
}, x = par.df$n, y = par.df$par)
# convert matrix (each column) into a list of parameters
par.ls <- lapply(seq_len(ncol(changed_par)), function(i) changed_par[,i])
#get a list of splines form the transformed parameter lists
spline.ls <- lapply(par.ls, function(x){
get_spline(par = x, cue_range = cue_range)
})
# convert spline to dataframe
spline_int.ls <- mapply(function(x, y){
data.frame(cue = cue_range, cr = x(cue_range), group = y)},
x = spline.ls, y = par.df$id)
# convert to df.ls
df.ls <- lapply(seq_len(ncol(spline_int.ls)), function(i){
df <- spline_int.ls[,i]
df_cat <- data.frame(cbind(cue = df$cue, cr = df$cr, group = df$group))
return(df_cat)
} )
res <- do.call(rbind, df.ls)
return(res)
}
test_spline <- spline_par(par_seq = seq(-10, 10, by = 1), cue_range = test_range)
test_spline
heaviside_spline <- spline_par(par_seq = seq(-1000, 1000, by = 100), cue_range = seq(0, 100, by = 1))
heaviside_spline
ggplot() +
geom_line(data = heaviside_spline, aes(x = cue, y = cr, color = group)) +
theme_bw()
heaviside_spline
ggplot() +
geom_line(data = heaviside_spline, aes(x = cue, y = cr, color = as.factor(group))) +
theme_bw()
spline_par <- function(
par_seq, # range of parameters we want to test
cue_range) # cue_range optimized over
{
get_spline <- function(par, cue_range){
# create dummy model
dummy_y.vals <- rep(0, length(cue_range))
dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
# fit basic cubic spline with no internal knots.
dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(x = cue_range, degree = 3))
dummy_cr.mod$data <- dummy_cr.data
# assign coefficient to be optimized to the dummy conversion rate function
dummy_cr.mod$coefficients <- rep(0.5,4)
# trying heaviside transformation
cr_pred <- predict(dummy_cr.mod, newdata = data.frame(cue_range))
cr_trans <- crone::heaviside(cr_pred)*(cr_pred)+(crone::heaviside(cr_pred-1)*(1-cr_pred))
# fit spline function to predicted conversion rate. This increases processing speed
cr_fun <- splinefun(cbind(cue_range, cr_trans))
return(cr_fun)
}
# get dataframe of all permutation of parameter values and their position
par.df <- expand.grid(n = c(1,2,3,4), par = par_seq)
## paste0 to get id
par.df$id <- paste0(par.df$n, "_", par.df$par)
# substitute each value within the 4 parameters with par_seq (generate all iterations)
changed_par <- mapply(function(x, y){
## define original parameter
par_trans <- rep(0.5,4)
## change according to df
par_trans[[x]] <- y
return(par_trans)
}, x = par.df$n, y = par.df$par)
# convert matrix (each column) into a list of parameters
par.ls <- lapply(seq_len(ncol(changed_par)), function(i) changed_par[,i])
#get a list of splines form the transformed parameter lists
spline.ls <- lapply(par.ls, function(x){
get_spline(par = x, cue_range = cue_range)
})
# convert spline to dataframe
spline_int.ls <- mapply(function(x, y){
data.frame(cue = cue_range, cr = x(cue_range), group = y)},
x = spline.ls, y = par.df$id)
# convert to df.ls
df.ls <- lapply(seq_len(ncol(spline_int.ls)), function(i){
df <- spline_int.ls[,i]
df_cat <- data.frame(cbind(cue = as.numeric(df$cue), cr = as.numeric(df$cr), group = as.factor(df$group)))
return(df_cat)
} )
res <- do.call(rbind, df.ls)
return(res)
}
