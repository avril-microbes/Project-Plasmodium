res_R <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
limit = limit,
model = chabaudi_ci_clean_R,
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = time_range,
cue_1 = cue_1,
cue_2 = cue_2,
cue_range_1 = cue_range,
cue_range_2 = cue_range,
solver = "vode",
log_cue_1 = log,
log_cue_2 = log)
return(list(res_R))
## no N
res_N <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
limit = limit,
model = chabaudi_ci_clean_N,
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = time_range,
cue_1 = cue_1,
cue_2 = cue_2,
cue_range_1 = cue_range,
cue_range_2 = cue_range,
solver = "vode",
log_cue_1 = log,
log_cue_2 = log)
## no W
res_W <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
limit = limit,
model = chabaudi_ci_clean_W,
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = time_range,
cue_1 = cue_1,
cue_2 = cue_2,
cue_range_1 = cue_range,
cue_range_2 = cue_range,
solver = "vode",
log_cue_1 = log,
log_cue_2 = log)
stopCluster(cl)
# get results
## get last index
index_R <- length(unlist(res_R))/10
index_N <- length(unlist(res_N))/10
index_W <- length(unlist(res_W))/10
## get actual results from last iteration
res_R2 <- unlist(res_R[[1]][[index_R+1]])
res_N2 <- unlist(res_N[[1]][[index_N+1]])
res_W2 <- unlist(res_W[[1]][[index_W+1]])
# reorganize results
res_R3 <- cbind(status = "static_R",
var1 = res_R2[2],
var2 = res_R2[3],
var3 = res_R2[4],
var4 = res_R2[5])
res_N3 <- cbind(status = "no_N",
var1 = res_N2[2],
var2 = res_N2[3],
var3 = res_N2[4],
var4 = res_N2[5])
res_W3 <- cbind(status = "no_W",
var1 = res_W2[2],
var2 = res_W2[3],
var3 = res_W2[4],
var4 = res_W2[5])
# cat results
res_final <- rbind(res_R3, res_N3, res_W3)
write.csv(res_final, paste0(here("data/partition/ci/"), df$id, "_partition.csv"))
}
#import in all functions
source(here("functions/chabaudi_ci_clean_R.R"))
source(here("functions/chabaudi_ci_clean_N.R"))
source(here("functions/chabaudi_ci_clean_W.R"))
source(here("functions/co_infection_opt_alt.R"))
# import in ci opt
ci_opt.df <- read.csv(here("data/ci_opt.csv"))
# left join with cue range
cue_range_ci.df <- read.csv(here("data/cue_range_ci.csv"))
ci_opt.df <- ci_opt.df %>% left_join(select(cue_range_ci.df, low, high, by, id), "id")
# run funciton
lapply(ci_opt.df, partition_ci)
# run function
ci_opt.ls <- split(seq_along(nrow(ci_opt.df)))
# run function
ci_opt.ls <- split(seq(nrow(ci_opt.df)))
# run function
ci_opt.ls <- split(ci_opt.df,seq(nrow(ci_opt.df)))
lapply(ci_opt.ls, partition_ci)
library(dplyr)
library(ggplot2)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
library(stringr)
library(parallel)
library(ggpubr)
library(ppso)
library(Rmpi)
# function to run optimization using 3 different functions (staticR, no N, and noW)
partition_dual <- function(df){
# source all functions
source(here("functions/chabaudi_si_clean.R"))
source(here("functions/chabaudi_si_clean_R.R"))
source(here("functions/chabaudi_si_clean_N.R"))
source(here("functions/chabaudi_si_clean_W.R"))
# get parameters
parameters_tsukushi <- c(R1 = 8.89*(10^6), # slightly higher
lambda = 3.7*(10^5),
mu = 0.025,
p = 8*(10^-6), # doubled form original
alpha = 1,
alphag = 2,
beta = 5.721,
mum = 48,
mug = 4,
I0 = 43.85965,
Ig0 = 0,
a = 150,
b = 100,
sp = 1,
psin = 16.69234,
psiw = 0.8431785,
phin = 0.03520591,
phiw = 550.842,
iota = 2.18*(10^6),
rho = 0.2627156)
# get all characteristics
cue <- df$cue
cue_b <- df$cue_b
log <- ifelse(df$log == "log", "log10", "none")
log_b <- ifelse(df$log_b == "log", "log10", "none")
cue_range <- seq(df$low, df$high, length.out = 500)
cue_range_b <- seq(df$low_b, df$high_b, length.out = 500)
id <- df$id
id_b <- df$id_b
# run optimization with static RBC
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
static_R <- optimParallel(
par = rep(0.5,9), # start at 0.5x4
fn = chabaudi_si_clean_R,
control = list(trace = 6, fnscale = -1),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 1e-3),
cue = cue,
cue_b = cue_b,
cue_range = cue_range,
cue_range_b = cue_range_b,
log_cue = log,
log_cue_b = log_b,
solver = "vode",
gam = "te")
# run optimization with no indiscriminant immunity
no_N <- optimParallel(
par = rep(0.5,9), # start at 0.5x4
fn = chabaudi_si_clean_N,
control = list(trace = 6, fnscale = -1),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 1e-3),
cue = cue,
cue_b = cue_b,
cue_range = cue_range,
cue_range_b = cue_range_b,
log_cue = log,
log_cue_b = log_b,
solver = "vode",
gam = "te")
# run simulation with no targeted immunity (W)
no_W <- optimParallel(
par = rep(0.5,9), # start at 0.5x4
fn = chabaudi_si_clean_W,
control = list(trace = 6, fnscale = -1),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 1e-3),
cue = cue,
cue_b = cue_b,
cue_range = cue_range,
cue_range_b = cue_range_b,
log_cue = log,
log_cue_b = log_b,
solver = "vode",
gam = "te")
stopCluster(cl)
# join together all data
res <- cbind(id = id,
id_b = id_b,
cue = cue,
cue_b = cue,
log = log,
log_b = log_b,
fitness_R = static_R$value,
fitness_N = no_N$value,
fitness_W = no_W$value,
var_R1 = static_R$par[[1]],
var_R2 = static_R$par[[2]],
var_R3 = static_R$par[[3]],
var_R4 = static_R$par[[4]],
var_R5 = static_R$par[[5]],
var_R6 = static_R$par[[6]],
var_R7 = static_R$par[[7]],
var_R8 = static_R$par[[8]],
var_R9 = static_R$par[[9]],
var_N1 = no_N$par[[1]],
var_N2 = no_N$par[[2]],
var_N3 = no_N$par[[3]],
var_N4 = no_N$par[[4]],
var_N5 = no_N$par[[5]],
var_N6 = no_N$par[[6]],
var_N7 = no_N$par[[7]],
var_N8 = no_N$par[[8]],
var_N9 = no_N$par[[9]],
var_W1 = no_W$par[[1]],
var_W2 = no_W$par[[2]],
var_W3 = no_W$par[[3]],
var_W4 = no_W$par[[4]],
var_W5 = no_W$par[[5]],
var_W6 = no_W$par[[6]],
var_W7 = no_W$par[[7]],
var_W8 = no_W$par[[8]],
var_W9 = no_W$par[[9]])
write.csv(res, paste0(here("data/partition/dual/"), id, "_", id_b, "_partition.csv"))
}
si_opt.csv <- read.csv(here("data/si_opt.csv"))
#W get all unique combinations but eliminating all combinations that uses the same cue
dual_cue.df <- expand.grid(si_opt.csv$id, si_opt.csv$id) %>%
filter(Var1 != Var2) %>%
left_join(select(si_opt.csv, cue1 = cue, id), by = c("Var1" = "id")) %>%
left_join(select(si_opt.csv, cue2 = cue, id), by = c("Var2" = "id")) %>%
filter(cue1 != cue2) %>%
mutate(temp = paste(pmin(Var1, Var2), pmax(Var1, Var2))) %>%
distinct(temp, .keep_all = T) # get rid of the same cue combination but just in different orders
# get cue range (500 divisons)
cue_range_alt <- read.csv(here("data/cue_range_si_alt.csv"))
dual_cue.df2 <- dual_cue.df %>%
left_join(cue_range_alt, by = c("Var1" = "id")) %>%
left_join(select(cue_range_alt, cue_b = cue, log_b = log, low_b = low, high_b = high, by_b = by, id_b = id, label_b = label), by = c("Var2" = "id_b"))
dual_cue.ls <- split(dual_cue.df2, seq(nrow(dual_cue.df2)))
lapply(dual_cue.ls, partition_dual)
# function to run optimization using 3 different functions (staticR, no N, and noW)
partition_dual <- function(df){
# source all functions
source(here("functions/chabaudi_si_clean.R"))
source(here("functions/chabaudi_si_clean_R.R"))
source(here("functions/chabaudi_si_clean_N.R"))
source(here("functions/chabaudi_si_clean_W.R"))
# get parameters
parameters_tsukushi <- c(R1 = 8.89*(10^6), # slightly higher
lambda = 3.7*(10^5),
mu = 0.025,
p = 8*(10^-6), # doubled form original
alpha = 1,
alphag = 2,
beta = 5.721,
mum = 48,
mug = 4,
I0 = 43.85965,
Ig0 = 0,
a = 150,
b = 100,
sp = 1,
psin = 16.69234,
psiw = 0.8431785,
phin = 0.03520591,
phiw = 550.842,
iota = 2.18*(10^6),
rho = 0.2627156)
# get all characteristics
cue <- df$cue
cue_b <- df$cue_b
log <- ifelse(df$log == "log", "log10", "none")
log_b <- ifelse(df$log_b == "log", "log10", "none")
cue_range <- seq(df$low, df$high, length.out = 500)
cue_range_b <- seq(df$low_b, df$high_b, length.out = 500)
id <- df$id
id_b <- df$id_b
# run optimization with static RBC
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
static_R <- optimParallel(
par = rep(0.5,9), # start at 0.5x4
fn = chabaudi_si_clean_R,
control = list(trace = 6, fnscale = -1),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 0.01),
cue = cue,
cue_b = cue_b,
cue_range = cue_range,
cue_range_b = cue_range_b,
log_cue = log,
log_cue_b = log_b,
solver = "vode",
gam = "te")
# run optimization with no indiscriminant immunity
no_N <- optimParallel(
par = rep(0.5,9), # start at 0.5x4
fn = chabaudi_si_clean_N,
control = list(trace = 6, fnscale = -1),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 0.01),
cue = cue,
cue_b = cue_b,
cue_range = cue_range,
cue_range_b = cue_range_b,
log_cue = log,
log_cue_b = log_b,
solver = "vode",
gam = "te")
# run simulation with no targeted immunity (W)
no_W <- optimParallel(
par = rep(0.5,9), # start at 0.5x4
fn = chabaudi_si_clean_W,
control = list(trace = 6, fnscale = -1),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 0.01),
cue = cue,
cue_b = cue_b,
cue_range = cue_range,
cue_range_b = cue_range_b,
log_cue = log,
log_cue_b = log_b,
solver = "vode",
gam = "te")
stopCluster(cl)
# join together all data
res <- cbind(id = id,
id_b = id_b,
cue = cue,
cue_b = cue,
log = log,
log_b = log_b,
fitness_R = static_R$value,
fitness_N = no_N$value,
fitness_W = no_W$value,
var_R1 = static_R$par[[1]],
var_R2 = static_R$par[[2]],
var_R3 = static_R$par[[3]],
var_R4 = static_R$par[[4]],
var_R5 = static_R$par[[5]],
var_R6 = static_R$par[[6]],
var_R7 = static_R$par[[7]],
var_R8 = static_R$par[[8]],
var_R9 = static_R$par[[9]],
var_N1 = no_N$par[[1]],
var_N2 = no_N$par[[2]],
var_N3 = no_N$par[[3]],
var_N4 = no_N$par[[4]],
var_N5 = no_N$par[[5]],
var_N6 = no_N$par[[6]],
var_N7 = no_N$par[[7]],
var_N8 = no_N$par[[8]],
var_N9 = no_N$par[[9]],
var_W1 = no_W$par[[1]],
var_W2 = no_W$par[[2]],
var_W3 = no_W$par[[3]],
var_W4 = no_W$par[[4]],
var_W5 = no_W$par[[5]],
var_W6 = no_W$par[[6]],
var_W7 = no_W$par[[7]],
var_W8 = no_W$par[[8]],
var_W9 = no_W$par[[9]])
write.csv(res, paste0(here("data/partition/dual/"), id, "_", id_b, "_partition.csv"))
}
lapply(dual_cue.ls, partition_dual)
dual_cue.ls[[1]]
source('~/.active-rstudio-document')
ci_opt.res1 <- read.csv(here("data/ci_opt_cf/ci_opt_res1.csv"))
library(dplyr)
library(ggplot2)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
# import in all single infection data
si_val.ls <- list.files(path = here("data/si_validation"), pattern = "*.csv", full.names = T)
si_val.df <- lapply(si_val.ls, read.csv)
si_val.df <- lapply(si_val.ls, read.csv)
si_val.df <- do.call(rbind, si_val.df)
# get max fitness from simulation. left join with si_opt
si_opt.df <- read.csv(here("data/si_opt.csv"))
si_val.df %>% group_by(id) %>% summarise(max_fitness = max(V1)) %>%
left_join(si_opt.df, by =c("id" = "id")) %>%
mutate(difference = fitness_20 - max_fitness)
# import in ci optimum for same cue
ci_opt.df <- read.csv(here("data/ci_opt.csv"))
# reclass for better labels
ci_opt.df <- ci_opt.df %>%
mutate(label_1 = case_when(
cue == "I-i" ~ "Asexual iRBC",
cue == "I1+I2" ~ "Total asexual\niRBC",
cue == "Ig-i" ~ "Sexual iRBC",
cue == "Ig1+Ig2" ~ "Total sexual\niRBC",
cue == "sum" ~ "Total iRBC",
cue == "G-i" ~ "Gametocyte",
cue == "G1+G2" ~ "Total\ngametocyte",
cue == "R" ~ "RBC"
)) %>%
mutate(label_2 = case_when(
log == "log" ~ "log10",
log == "none" ~ ""
)) %>%
mutate(label_3 = paste(label_1, label_2),
id = paste0(cue, "_", log))
# left join with cue range df
cue_range.df <- read.csv(here("data/cue_range.csv"))
# left join with cue range df
cue_range.df <- read.csv(here("data/ci_cue_range.csv"))
# left join with cue range df
cue_range_ci.df <- read.csv(here("data/cue_range_ci.csv"))
source(here("functions/validate_ci.R"))
# split into 3 chunks
ci_opt.df1 <- ci_opt.df[1:5,]
# split into 3 chunks
ci_opt.df1 <- ci_opt.df[1:5,]
ci_opt.df1 <- ci_opt.df[1:5,]
ci_opt.df2 <- ci_opt.df[6:10,]
ci_opt.df3 <- ci_opt.df[11:14,]
ci_opt.ls1 <- split(ci_opt.df1, seq(nrow(ci_opt.df1)))
ci_opt.ls2 <- split(ci_opt.df2, seq(nrow(ci_opt.df2)))
ci_opt.ls3 <- split(ci_opt.df3, seq(nrow(ci_opt.df3)))
ci_opt.df <- ci_opt.df %>% left_join(select(cue_range_ci.df, low, high, by, id), by = c("id" = "id"))
ci_opt.df
ci_opt.df1 <- ci_opt.df[1:5,]
ci_opt.df2 <- ci_opt.df[6:10,]
ci_opt.df3 <- ci_opt.df[11:14,]
ci_opt.ls1 <- split(ci_opt.df1, seq(nrow(ci_opt.df1)))
ci_opt.ls2 <- split(ci_opt.df2, seq(nrow(ci_opt.df2)))
ci_opt.ls3 <- split(ci_opt.df3, seq(nrow(ci_opt.df3)))
ci_opt.df
# read in the results file
ci_val.ls <- list.files(here("data/ci_validation/*.csv"), full.names = T)
ci_val.ls2 <- do.call(ci_val.ls, read.csv)
ci_val.ls2 <- do.call(read.csv, ci_val.ls)
# read in the results file
ci_val.ls <- list.files(here("data/ci_validation/*.csv"), full.names = T)
# read in the results file
ci_val.ls <- list.files(here("data/ci_validation/*.csv"), full.names = T)
ci_val.ls2 <- do.call(read.csv, ci_val.ls)
ci_val.ls
# read in the results file
ci_val.ls <- list.files(here("data/ci_validation/*.csv"), full.names = T)
ci_val.ls
# read in the results file
ci_val.ls <- list.files(path = here("data/ci_validation/*.csv"), full.names = T)
ci_val.ls
# read in the results file
ci_val.ls <- list.files(path = here("data/ci_validation"), pattern = "*.csv", full.names = T)
ci_val.ls
ci_val.ls2 <- do.call(read.csv, ci_val.ls)
# read in the results file
ci_val.ls <- list.files(path = here("data/ci_validation"), pattern = "*.csv", full.names = T)
ci_val.ls2 <- do.call(read.csv, ci_val.ls)
ci_val.ls2 <- lapply(read.csv, ci_val.ls)
ci_val.ls2 <- lapply(ci_val.ls, read.csv)
ci_opt.df <- do.call(rbind, ci_val.ls2)
ci_opt.df
# join with ci_opt
ci_opt.df
ci_val.df <- do.call(rbind, ci_val.ls2)
# import in ci optimum for same cue and join with cue range
ci_opt.df <«- read.csv(here("data/ci_opt.csv"))
# import in ci optimum for same cue and join with cue range
ci_opt.df <- read.csv(here("data/ci_opt.csv"))
# join with ci_opt
ci_opt.df
ci_opt.df
ci_val.df
# import in ci optimum for same cue and join with cue range
ci_opt.df <- read.csv(here("data/ci_opt.csv"))
ci_opt.df
# Here, we are competing strain 1 (adopting supposed optimum strategy) with strain 2 adopting a randomized strategy. Hence, we expect fitness difference to be above 1!
ci_val.df
# Here, we are competing strain 1 (adopting supposed optimum strategy) with strain 2 adopting a randomized strategy. Hence, we expect fitness difference to be above 1!
ci_val.df %>%
group_by(label) %>%
summarizes(min_fitness = min(V1))
# Here, we are competing strain 1 (adopting supposed optimum strategy) with strain 2 adopting a randomized strategy. Hence, we expect fitness difference to be above 1!
ci_val.df %>%
group_by(label) %>%
summarize(min_fitness = min(V1))
ci_val.ls <- list.files(path = here("data/ci_validation"), pattern = "*.csv", full.names = T)
ci_val.ls2 <- lapply(ci_val.ls, read.csv)
ci_val.df <- do.call(rbind, ci_val.ls2)
# Here, we are competing strain 1 (adopting supposed optimum strategy) with strain 2 adopting a randomized strategy. Hence, we expect fitness difference to be above 1!
ci_val.df %>%
group_by(label) %>%
summarize(min_fitness = min(V1))
1-(2*(10^-6))
1/(2*10^5)
1/(2*(10^5))
(1-(1/(2*10^5)))
(1-(1/(2*10^5)))*(10^4)
(1-(1/(2*10^5)))*(10^-4)
(10^-4)/(2*10^5)
(10^-6)/(2*10^5)
1/(2*10^5)
(10^-6)^2
(1-(1/(2*10^5)))*(10^-12)
(10^-12)/(2*10^5)
