cue_range =  cue_range,
cue = cue,
log_cue = log,
solver = "vode")
stopCluster(cl)
# join together all data
res <- cbind(id = id,
cue = cue,
log = log,
fitness_R = static_R$value,
fitness_N = no_N$value,
fitness_W = no_W$value,
var_R1 = static_R$par[[1]],
var_R2 = static_R$par[[2]],
var_R3 = static_R$par[[3]],
var_R4 = static_R$par[[4]],
var_N1 = no_N$par[[1]],
var_N2 = no_N$par[[2]],
var_N3 = no_N$par[[3]],
var_N4 = no_N$par[[4]],
var_W1 = no_W$par[[1]],
var_W2 = no_W$par[[2]],
var_W3 = no_W$par[[3]],
var_W4 = no_W$par[[4]])
write.csv(res, paste0(here("data/partition/si/"), id, "_partition.csv"))
}
# import in optimized df
si_opt.df <- read.csv(here("data/si_opt.csv"))
# join with cue_range
cue_range_si.df <- read.csv(here("data/cue_range_si.csv"))
si_opt.df <- si_opt.df %>% left_join(select(cue_range_si.df, low, high, by, id), "id")
# lapply loop
si_opt.ls <- split(si_opt.df, seq(nrow(si_opt.df)))
lapply(si_opt.ls, partition_si)
partition_ci <- function(df){
# get info
limit <- 0.01
time_range <- seq(0, 20, 1e-3)
cue_1 <- df$cue_1
cue_2 <- df$cue_2
log <- ifelse(df$log == "log", "log10", "none")
cue_range <- seq(df$low, df$high, by = df$by)
# perform optimization
## no R
res_R <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
limit = limit,
model = chabaudi_ci_clean_R,
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = time_range,
cue_1 = cue_1,
cue_2 = cue_2,
cue_range_1 = cue_range,
cue_range_2 = cue_range,
solver = "vode",
log_cue_1 = log,
log_cue_2 = log)
return(res_R)
## no N
res_N <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
limit = limit,
model = chabaudi_ci_clean_N,
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = time_range,
cue_1 = cue_1,
cue_2 = cue_2,
cue_range_1 = cue_range,
cue_range_2 = cue_range,
solver = "vode",
log_cue_1 = log,
log_cue_2 = log)
## no W
res_W <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
limit = limit,
model = chabaudi_ci_clean_W,
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = time_range,
cue_1 = cue_1,
cue_2 = cue_2,
cue_range_1 = cue_range,
cue_range_2 = cue_range,
solver = "vode",
log_cue_1 = log,
log_cue_2 = log)
return(list(res_R, res_N, res_W))
}
library(dplyr)
library(ggplot2)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
library(stringr)
library(parallel)
library(ggpubr)
library(ppso)
library(Rmpi)
parameters_tsukushi <- c(R1 = 8.89*(10^6), # slightly higher
lambda = 3.7*(10^5),
mu = 0.025,
p = 8*(10^-6), # doubled form original
alpha = 1,
alphag = 2,
beta = 5.721,
mum = 48,
mug = 4,
I0 = 43.85965,
Ig0 = 0,
a = 150,
b = 100,
sp = 1,
psin = 16.69234,
psiw = 0.8431785,
phin = 0.03520591,
phiw = 550.842,
iota = 2.18*(10^6),
rho = 0.2627156)
I_range_none <- seq(0, 6*(10^6), by = (6*(10^6))/500)
I_range_log <- seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/500)
G_range_none <- seq(0, 6*(10^4), by = (6*(10^4))/500)
G_range_log <- seq(0, log10(6*(10^4)), by = (log10(6*(10^4)))/500)
R_range_log <- seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000)
partition_ci <- function(df){
# get info
limit <- 0.01
time_range <- seq(0, 20, 1e-3)
cue_1 <- df$cue_1
cue_2 <- df$cue_2
log <- ifelse(df$log == "log", "log10", "none")
cue_range <- seq(df$low, df$high, by = df$by)
# perform optimization
## no R
res_R <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
limit = limit,
model = chabaudi_ci_clean_R,
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = time_range,
cue_1 = cue_1,
cue_2 = cue_2,
cue_range_1 = cue_range,
cue_range_2 = cue_range,
solver = "vode",
log_cue_1 = log,
log_cue_2 = log)
return(list(res_R))
## no N
res_N <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
limit = limit,
model = chabaudi_ci_clean_N,
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = time_range,
cue_1 = cue_1,
cue_2 = cue_2,
cue_range_1 = cue_range,
cue_range_2 = cue_range,
solver = "vode",
log_cue_1 = log,
log_cue_2 = log)
## no W
res_W <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
limit = limit,
model = chabaudi_ci_clean_W,
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = time_range,
cue_1 = cue_1,
cue_2 = cue_2,
cue_range_1 = cue_range,
cue_range_2 = cue_range,
solver = "vode",
log_cue_1 = log,
log_cue_2 = log)
stopCluster(cl)
# get results
## get last index
index_R <- length(unlist(res_R))/10
index_N <- length(unlist(res_N))/10
index_W <- length(unlist(res_W))/10
## get actual results from last iteration
res_R2 <- unlist(res_R[[1]][[index_R+1]])
res_N2 <- unlist(res_N[[1]][[index_N+1]])
res_W2 <- unlist(res_W[[1]][[index_W+1]])
# reorganize results
res_R3 <- cbind(status = "static_R",
var1 = res_R2[2],
var2 = res_R2[3],
var3 = res_R2[4],
var4 = res_R2[5])
res_N3 <- cbind(status = "no_N",
var1 = res_N2[2],
var2 = res_N2[3],
var3 = res_N2[4],
var4 = res_N2[5])
res_W3 <- cbind(status = "no_W",
var1 = res_W2[2],
var2 = res_W2[3],
var3 = res_W2[4],
var4 = res_W2[5])
# cat results
res_final <- rbind(res_R3, res_N3, res_W3)
write.csv(res_final, paste0(here("data/partition/ci/"), df$id, "_partition.csv"))
}
#import in all functions
source(here("functions/chabaudi_ci_clean_R.R"))
source(here("functions/chabaudi_ci_clean_N.R"))
source(here("functions/chabaudi_ci_clean_W.R"))
source(here("functions/co_infection_opt_alt.R"))
# import in ci opt
ci_opt.df <- read.csv(here("data/ci_opt.csv"))
# left join with cue range
cue_range_ci.df <- read.csv(here("data/cue_range_ci.csv"))
ci_opt.df <- ci_opt.df %>% left_join(select(cue_range_ci.df, low, high, by, id), "id")
# run funciton
lapply(ci_opt.df, partition_ci)
# run function
ci_opt.ls <- split(seq_along(nrow(ci_opt.df)))
# run function
ci_opt.ls <- split(seq(nrow(ci_opt.df)))
# run function
ci_opt.ls <- split(ci_opt.df,seq(nrow(ci_opt.df)))
lapply(ci_opt.ls, partition_ci)
library(dplyr)
library(ggplot2)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
library(stringr)
library(parallel)
library(ggpubr)
library(ppso)
library(Rmpi)
# function to run optimization using 3 different functions (staticR, no N, and noW)
partition_dual <- function(df){
# source all functions
source(here("functions/chabaudi_si_clean.R"))
source(here("functions/chabaudi_si_clean_R.R"))
source(here("functions/chabaudi_si_clean_N.R"))
source(here("functions/chabaudi_si_clean_W.R"))
# get parameters
parameters_tsukushi <- c(R1 = 8.89*(10^6), # slightly higher
lambda = 3.7*(10^5),
mu = 0.025,
p = 8*(10^-6), # doubled form original
alpha = 1,
alphag = 2,
beta = 5.721,
mum = 48,
mug = 4,
I0 = 43.85965,
Ig0 = 0,
a = 150,
b = 100,
sp = 1,
psin = 16.69234,
psiw = 0.8431785,
phin = 0.03520591,
phiw = 550.842,
iota = 2.18*(10^6),
rho = 0.2627156)
# get all characteristics
cue <- df$cue
cue_b <- df$cue_b
log <- ifelse(df$log == "log", "log10", "none")
log_b <- ifelse(df$log_b == "log", "log10", "none")
cue_range <- seq(df$low, df$high, length.out = 500)
cue_range_b <- seq(df$low_b, df$high_b, length.out = 500)
id <- df$id
id_b <- df$id_b
# run optimization with static RBC
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
static_R <- optimParallel(
par = rep(0.5,9), # start at 0.5x4
fn = chabaudi_si_clean_R,
control = list(trace = 6, fnscale = -1),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 1e-3),
cue = cue,
cue_b = cue_b,
cue_range = cue_range,
cue_range_b = cue_range_b,
log_cue = log,
log_cue_b = log_b,
solver = "vode",
gam = "te")
# run optimization with no indiscriminant immunity
no_N <- optimParallel(
par = rep(0.5,9), # start at 0.5x4
fn = chabaudi_si_clean_N,
control = list(trace = 6, fnscale = -1),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 1e-3),
cue = cue,
cue_b = cue_b,
cue_range = cue_range,
cue_range_b = cue_range_b,
log_cue = log,
log_cue_b = log_b,
solver = "vode",
gam = "te")
# run simulation with no targeted immunity (W)
no_W <- optimParallel(
par = rep(0.5,9), # start at 0.5x4
fn = chabaudi_si_clean_W,
control = list(trace = 6, fnscale = -1),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 1e-3),
cue = cue,
cue_b = cue_b,
cue_range = cue_range,
cue_range_b = cue_range_b,
log_cue = log,
log_cue_b = log_b,
solver = "vode",
gam = "te")
stopCluster(cl)
# join together all data
res <- cbind(id = id,
id_b = id_b,
cue = cue,
cue_b = cue,
log = log,
log_b = log_b,
fitness_R = static_R$value,
fitness_N = no_N$value,
fitness_W = no_W$value,
var_R1 = static_R$par[[1]],
var_R2 = static_R$par[[2]],
var_R3 = static_R$par[[3]],
var_R4 = static_R$par[[4]],
var_R5 = static_R$par[[5]],
var_R6 = static_R$par[[6]],
var_R7 = static_R$par[[7]],
var_R8 = static_R$par[[8]],
var_R9 = static_R$par[[9]],
var_N1 = no_N$par[[1]],
var_N2 = no_N$par[[2]],
var_N3 = no_N$par[[3]],
var_N4 = no_N$par[[4]],
var_N5 = no_N$par[[5]],
var_N6 = no_N$par[[6]],
var_N7 = no_N$par[[7]],
var_N8 = no_N$par[[8]],
var_N9 = no_N$par[[9]],
var_W1 = no_W$par[[1]],
var_W2 = no_W$par[[2]],
var_W3 = no_W$par[[3]],
var_W4 = no_W$par[[4]],
var_W5 = no_W$par[[5]],
var_W6 = no_W$par[[6]],
var_W7 = no_W$par[[7]],
var_W8 = no_W$par[[8]],
var_W9 = no_W$par[[9]])
write.csv(res, paste0(here("data/partition/dual/"), id, "_", id_b, "_partition.csv"))
}
si_opt.csv <- read.csv(here("data/si_opt.csv"))
#W get all unique combinations but eliminating all combinations that uses the same cue
dual_cue.df <- expand.grid(si_opt.csv$id, si_opt.csv$id) %>%
filter(Var1 != Var2) %>%
left_join(select(si_opt.csv, cue1 = cue, id), by = c("Var1" = "id")) %>%
left_join(select(si_opt.csv, cue2 = cue, id), by = c("Var2" = "id")) %>%
filter(cue1 != cue2) %>%
mutate(temp = paste(pmin(Var1, Var2), pmax(Var1, Var2))) %>%
distinct(temp, .keep_all = T) # get rid of the same cue combination but just in different orders
# get cue range (500 divisons)
cue_range_alt <- read.csv(here("data/cue_range_si_alt.csv"))
dual_cue.df2 <- dual_cue.df %>%
left_join(cue_range_alt, by = c("Var1" = "id")) %>%
left_join(select(cue_range_alt, cue_b = cue, log_b = log, low_b = low, high_b = high, by_b = by, id_b = id, label_b = label), by = c("Var2" = "id_b"))
dual_cue.ls <- split(dual_cue.df2, seq(nrow(dual_cue.df2)))
lapply(dual_cue.ls, partition_dual)
# function to run optimization using 3 different functions (staticR, no N, and noW)
partition_dual <- function(df){
# source all functions
source(here("functions/chabaudi_si_clean.R"))
source(here("functions/chabaudi_si_clean_R.R"))
source(here("functions/chabaudi_si_clean_N.R"))
source(here("functions/chabaudi_si_clean_W.R"))
# get parameters
parameters_tsukushi <- c(R1 = 8.89*(10^6), # slightly higher
lambda = 3.7*(10^5),
mu = 0.025,
p = 8*(10^-6), # doubled form original
alpha = 1,
alphag = 2,
beta = 5.721,
mum = 48,
mug = 4,
I0 = 43.85965,
Ig0 = 0,
a = 150,
b = 100,
sp = 1,
psin = 16.69234,
psiw = 0.8431785,
phin = 0.03520591,
phiw = 550.842,
iota = 2.18*(10^6),
rho = 0.2627156)
# get all characteristics
cue <- df$cue
cue_b <- df$cue_b
log <- ifelse(df$log == "log", "log10", "none")
log_b <- ifelse(df$log_b == "log", "log10", "none")
cue_range <- seq(df$low, df$high, length.out = 500)
cue_range_b <- seq(df$low_b, df$high_b, length.out = 500)
id <- df$id
id_b <- df$id_b
# run optimization with static RBC
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
static_R <- optimParallel(
par = rep(0.5,9), # start at 0.5x4
fn = chabaudi_si_clean_R,
control = list(trace = 6, fnscale = -1),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 0.01),
cue = cue,
cue_b = cue_b,
cue_range = cue_range,
cue_range_b = cue_range_b,
log_cue = log,
log_cue_b = log_b,
solver = "vode",
gam = "te")
# run optimization with no indiscriminant immunity
no_N <- optimParallel(
par = rep(0.5,9), # start at 0.5x4
fn = chabaudi_si_clean_N,
control = list(trace = 6, fnscale = -1),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 0.01),
cue = cue,
cue_b = cue_b,
cue_range = cue_range,
cue_range_b = cue_range_b,
log_cue = log,
log_cue_b = log_b,
solver = "vode",
gam = "te")
# run simulation with no targeted immunity (W)
no_W <- optimParallel(
par = rep(0.5,9), # start at 0.5x4
fn = chabaudi_si_clean_W,
control = list(trace = 6, fnscale = -1),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 0.01),
cue = cue,
cue_b = cue_b,
cue_range = cue_range,
cue_range_b = cue_range_b,
log_cue = log,
log_cue_b = log_b,
solver = "vode",
gam = "te")
stopCluster(cl)
# join together all data
res <- cbind(id = id,
id_b = id_b,
cue = cue,
cue_b = cue,
log = log,
log_b = log_b,
fitness_R = static_R$value,
fitness_N = no_N$value,
fitness_W = no_W$value,
var_R1 = static_R$par[[1]],
var_R2 = static_R$par[[2]],
var_R3 = static_R$par[[3]],
var_R4 = static_R$par[[4]],
var_R5 = static_R$par[[5]],
var_R6 = static_R$par[[6]],
var_R7 = static_R$par[[7]],
var_R8 = static_R$par[[8]],
var_R9 = static_R$par[[9]],
var_N1 = no_N$par[[1]],
var_N2 = no_N$par[[2]],
var_N3 = no_N$par[[3]],
var_N4 = no_N$par[[4]],
var_N5 = no_N$par[[5]],
var_N6 = no_N$par[[6]],
var_N7 = no_N$par[[7]],
var_N8 = no_N$par[[8]],
var_N9 = no_N$par[[9]],
var_W1 = no_W$par[[1]],
var_W2 = no_W$par[[2]],
var_W3 = no_W$par[[3]],
var_W4 = no_W$par[[4]],
var_W5 = no_W$par[[5]],
var_W6 = no_W$par[[6]],
var_W7 = no_W$par[[7]],
var_W8 = no_W$par[[8]],
var_W9 = no_W$par[[9]])
write.csv(res, paste0(here("data/partition/dual/"), id, "_", id_b, "_partition.csv"))
}
lapply(dual_cue.ls, partition_dual)
dual_cue.ls[[1]]
