---
title: "R Notebook"
output: html_notebook
---

# Dual cue troubleshooting
This week, I will attempt to troubleshoot dual cue optimization to minimize the difference in fitness between dual cue and single cue. Logically, dual cue should achieve roughly the same fitness or higher that is comparable to single cue (if one cue is uninformative). However, previous attempt using ti interactions only led to the majority of dual cue having lower optimized fitness compared to single cue.

```{r}
library(dplyr)
library(ggplot2)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
library(stringr)
library(parallel)
library(ggpubr)
library(ppso)
library(Rmpi)
library(ggrepel)
library(forcats)

source(here("functions/chabaudi_si_clean.R"))

# importing in test function that contains full main effect interation
source(here("functions/test.R"))
```

```{r}
parameters_tsukushi <- c(R1 = 8.89*(10^6), # slightly higher
                lambda = 3.7*(10^5),
                mu = 0.025, 
                p = 8*(10^-6), # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156)

I_range_none <- seq(0, 6*(10^6), by = (6*(10^6))/500)
I_range_log <- seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/500)
G_range_none <- seq(0, 6*(10^4), by = (6*(10^4))/500)
G_range_log <- seq(0, log10(6*(10^4)), by = (log10(6*(10^4)))/500)
R_range_log <- seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000)
```

#------------------------------------------#
# testing out te effect
#------------------------------------------#
# get dual cue df
```{r}
si_opt.csv <- read.csv(here("data/si_opt.csv"))

#W get all unique combinations but eliminating all combinations that uses the same cue
dual_cue.df <- expand.grid(si_opt.csv$id, si_opt.csv$id) %>% 
  filter(Var1 != Var2) %>% 
  left_join(select(si_opt.csv, cue1 = cue, id), by = c("Var1" = "id")) %>% 
  left_join(select(si_opt.csv, cue2 = cue, id), by = c("Var2" = "id")) %>% 
  filter(cue1 != cue2) %>% 
  mutate(temp = paste(pmin(Var1, Var2), pmax(Var1, Var2))) %>% 
  distinct(temp, .keep_all = T) # get rid of the same cue combination but just in different orders


# get cue range (500 divisons)
cue_range_alt <- read.csv(here("data/cue_range_si_alt.csv"))
dual_cue.df2 <- dual_cue.df %>% 
  left_join(cue_range_alt, by = c("Var1" = "id")) %>% 
  left_join(select(cue_range_alt, cue_b = cue, log_b = log, low_b = low, high_b = high, by_b = by, id_b = id, label_b = label), by = c("Var2" = "id_b"))
```

# optimization function with test
```{r}
te_test <- function(df){
  # process cues
  cue <- df$cue
  cue_b <- df$cue_b
  
  # process log
  log <- ifelse(str_detect("log", df$log), "log10", "none")
  log_b <- ifelse(str_detect("log", df$log_b), "log10", "none")
  
  # process cue_range. cannot use by to ensure that both cue ranges are of the same length
  cue_range <- seq(df$low, df$high, length.out = 500)
  cue_range_b <- seq(df$low_b, df$high_b, length.out = 500)
  
  # optimization
  cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
  
  # start optimization LFBGS with inital value of 0.5x5
  res <- optimParallel(
    par = rep(0.5, 9),
    fn = test, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, 0.01),
    cue = cue,
    cue_b = cue_b,
    cue_range = cue_range,
    cue_range_b = cue_range_b,
    log_cue = log,
    log_cue_b = log_b,
    solver = "vode")

  

  # close cluster
  stopCluster(cl)
  
  # get model output
  fitness <- res$value ## fitness difference between mutant and residence
  par <- res$par ## optimized parameters of mutant
  
  # produce output
  output <- cbind.data.frame(id = df$Var1, id_b = df$Var2, 
                             label = df$label, label_b = df$label_b,
                             fitness = fitness,
                             par1 = par[1], par2 = par[2], par3 = par[3], par4 = par[4], par5 = par[5])
  
  write.csv(output, here(paste0("data/test/", df$Var1, "_", df$Var2, ".csv")))
  return(output)
  
}
```

# check first set using L-BFGS optimization very minimum improvement lol. optimizer does not move very far
```{r}
te_test(dual_cue.df2[1,])
```

# trying partical swarming
```{r}
ppso_test <- function(df){
  # process cues
  cue <- df$cue
  cue_b <- df$cue_b
  
  # process log
  log <- ifelse(str_detect("log", df$log), "log10", "none")
  log_b <- ifelse(str_detect("log", df$log_b), "log10", "none")
  
  # process cue_range. cannot use by to ensure that both cue ranges are of the same length
  cue_range <- seq(df$low, df$high, length.out = 500)
  cue_range_b <- seq(df$low_b, df$high_b, length.out = 500)
  
  # start optimization LFBGS with inital value of 0.5x5
  res <- ppso::optim_dds(
    max_number_function_calls=1000,
    objective_function = test, 
    number_of_parameters = 9,
    initial_estimates = rep(0.5, 5),
    parameter_bounds = cbind(c(-1, rep(-500, 4)), c(1, rep(500, 4))),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, 0.01),
    cue = cue,
    cue_b = cue_b,
    cue_range = cue_range,
    cue_range_b = cue_range_b,
    log_cue = log,
    log_cue_b = log_b,
    solver = "vode",
    neg = T)
  
  # get model output
  fitness <- res$value ## fitness difference between mutant and residence
  par <- res$par ## optimized parameters of mutant
  
  # produce output
  output <- cbind.data.frame(id = df$Var1, id_b = df$Var2, 
                             label = df$label, label_b = df$label_b,
                             fitness = fitness,
                             par1 = par[1], par2 = par[2], par3 = par[3], par4 = par[4], par5 = par[5])
  
  write.csv(output, here(paste0("data/test/", df$Var1, "_", df$Var2, ".csv")))
  return(output)
  
}
```

# dds with 500 max iterations (te full interations) gives highest fitness of 7.63. Not bad but also not great! 

# Here, let's try out just ti and see whether that improves stuff. Doing ppso with 1000 max iterations. pretty band at 2.28
```{r}
ppso_test(dual_cue.df2[1,])
```


# bound determination for te
lower bound order should be c(-10, -500, -500, -500, -100, -500, -500, -100, -100)
upper bound order should be c(1, 500, 500, 500, 100, 500 ,500, 100, 100)
```{r}
# list of values to expand bounds on
bounds <- c(-50000, -10000, -5000, -1000, -500, -100, -10, -1, 1, 100, 1000, 500, 5000, 10000, 50000)
bounds.df <- expand.grid(par = bounds, index = seq(1,9,1))

# cycle to get all combinations of 5 parameters with these substituted in
par.ls <- lapply(split(bounds.df, seq(nrow(bounds.df))), function(x){
  # default pardameter list with 5x0.5
  par <- rep(0.5, 9)
  #A substitute in the bounds
  par[[x$index]] <- x$par
  return(data.frame(
    par1 = par[[1]],
    par2 = par[[2]],
    par3 = par[[3]],
    par4 = par[[4]],
    par5 = par[[5]],
    par6 = par[[6]],
    par7 = par[[7]],
    par8 = par[[8]],
    par9 = par[[9]],
    id = paste0(x$index, "_", x$par)))
})

par.df <- do.call(rbind, par.ls)


# make graphs
source(here("functions/par_to_hm_te.R"))

# get heatmap dataframe for all par
par_res.ls <- mclapply(par.ls,
                     function(x){
                       res <- par_to_hm_te(par = c(x$par1, x$par2, x$par3, x$par4, x$par5, x$par6, x$par7, x$par8, x$par9),
                                 cue_range = seq(1, 100, 1),
                                 cue_range_b = seq(1, 100, 1))
                       res2 <- cbind(id = x$id, res)
                       return(res2)
                     }
)
par_res.df <- do.call(rbind, par_res.ls)

# divide into 5 parameters
par_res.df1 <- par_res.df %>% filter(str_detect(id, "1_"))
par_res.df2 <- par_res.df %>% filter(str_detect(id, "2_"))
par_res.df3 <- par_res.df %>% filter(str_detect(id, "3_"))
par_res.df4 <- par_res.df %>% filter(str_detect(id, "4_"))
par_res.df5 <- par_res.df %>% filter(str_detect(id, "5_"))
par_res.df6 <- par_res.df %>% filter(str_detect(id, "6_"))
par_res.df7 <- par_res.df %>% filter(str_detect(id, "7_"))
par_res.df8 <- par_res.df %>% filter(str_detect(id, "8_"))
par_res.df9 <- par_res.df %>% filter(str_detect(id, "9_"))

# par 1. -10 and 1 is sufficient
ggplot() +
  geom_raster(data = par_res.df1, aes(x = cue_range, y = cue_range_b, fill = cr)) +
  facet_wrap(~id)

# par2. -500 to 500
ggplot() +
  geom_raster(data = par_res.df2, aes(x = cue_range, y = cue_range_b, fill = cr)) +
  facet_wrap(~id)

# par 3.-500 to 500
ggplot() +
  geom_raster(data = par_res.df3, aes(x = cue_range, y = cue_range_b, fill = cr)) +
  facet_wrap(~id)

# par 4. -500 to 500
ggplot() +
  geom_raster(data = par_res.df4, aes(x = cue_range, y = cue_range_b, fill = cr)) +
  facet_wrap(~id)

# par 5. -100 to 100
ggplot() +
  geom_raster(data = par_res.df5, aes(x = cue_range, y = cue_range_b, fill = cr)) +
  facet_wrap(~id)

# par 6. -500 to 500
ggplot() +
  geom_raster(data = par_res.df6, aes(x = cue_range, y = cue_range_b, fill = cr)) +
  facet_wrap(~id)

# par 7. -500 to 500
ggplot() +
  geom_raster(data = par_res.df7, aes(x = cue_range, y = cue_range_b, fill = cr)) +
  facet_wrap(~id)

# par 8. -100 to 100
ggplot() +
  geom_raster(data = par_res.df8, aes(x = cue_range, y = cue_range_b, fill = cr)) +
  facet_wrap(~id)

# par 9. -100 to 100
ggplot() +
  geom_raster(data = par_res.df9, aes(x = cue_range, y = cue_range_b, fill = cr)) +
  facet_wrap(~id)

```

#----------------------------#
Te optimization with dds
#----------------------------#
```{r}
source(here("functions/chabaudi_si_clean.R"))
```

# optimzation function
lower bound order should be c(-10, -500, -500, -500, -100, -500, -500, -100, -100)
upper bound order should be c(1, 500, 500, 500, 100, 500 ,500, 100, 100)
```{r}
ppso_opt <- function(df){
  # process cues
  cue <- df$cue
  cue_b <- df$cue_b
  
  # process log
  log <- ifelse(str_detect("log", df$log), "log10", "none")
  log_b <- ifelse(str_detect("log", df$log_b), "log10", "none")
  
  # process cue_range. cannot use by to ensure that both cue ranges are of the same length
  cue_range <- seq(df$low, df$high, length.out = 500)
  cue_range_b <- seq(df$low_b, df$high_b, length.out = 500)
  
  # start optimization using dds
  res <- ppso::optim_dds(
    max_number_function_calls = 1000,
    objective_function = chabaudi_si_clean, 
    number_of_parameters = 9,
    initial_estimates = rep(0.5, 9),
    parameter_bounds = cbind(c(-10, -500, -500, -500, -100, -500, -500, -100, -100),
                             c(1, 500, 500, 500, 100, 500 ,500, 100, 100)),
    projectfile = here(paste0("log/", df$Var1, "_", df$Var2, ".pro")),
    logfile = here(paste0("log/", df$Var1, "_", df$Var2, ".log")),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, 0.01),
    cue = cue,
    cue_b = cue_b,
    cue_range = cue_range,
    cue_range_b = cue_range_b,
    log_cue = log,
    log_cue_b = log_b,
    solver = "vode",
    neg = T,
    gam = "te")
  
  # get model output
  fitness <- res$value ## fitness difference between mutant and residence
  par <- res$par ## optimized parameters of mutant
  
  # produce output
  output <- cbind.data.frame(id = df$Var1, id_b = df$Var2, 
                             label = df$label, label_b = df$label_b,
                             fitness = fitness,
                             par1 = par[1], par2 = par[2], par3 = par[3], par4 = par[4], par5 = par[5], par6 = par[6], par7 = par[7], par8 = par[8], par9 = par[9])
  
  write.csv(output, here(paste0("data/dual_cue_opt_dds/", df$Var1, "_", df$Var2, ".csv")))
  return(output)
  
}
```

# get running df
```{r}
si_opt.csv <- read.csv(here("data/si_opt.csv"))

#W get all unique combinations but eliminating all combinations that uses the same cue
dual_cue.df <- expand.grid(si_opt.csv$id, si_opt.csv$id) %>% 
  filter(Var1 != Var2) %>% 
  left_join(select(si_opt.csv, cue1 = cue, id), by = c("Var1" = "id")) %>% 
  left_join(select(si_opt.csv, cue2 = cue, id), by = c("Var2" = "id")) %>% 
  filter(cue1 != cue2) %>% 
  mutate(temp = paste(pmin(Var1, Var2), pmax(Var1, Var2))) %>% 
  distinct(temp, .keep_all = T) # get rid of the same cue combination but just in different orders


# get cue range (500 divisons)
cue_range_alt <- read.csv(here("data/cue_range_si_alt.csv"))
dual_cue.df2 <- dual_cue.df %>% 
  left_join(cue_range_alt, by = c("Var1" = "id")) %>% 
  left_join(select(cue_range_alt, cue_b = cue, log_b = log, low_b = low, high_b = high, by_b = by, id_b = id, label_b = label), by = c("Var2" = "id_b"))
```

# run. overall does not seem to do much
```{r}
dual_cue.ls <- split(dual_cue.df2, seq(nrow(dual_cue.df2)))

mclapply(dual_cue.ls, ppso_opt, mc.cores = 20)
```


# redo local optimization with te
```{r}
dual_cue_opt <- function(df){
  # process cues
  cue <- df$cue
  cue_b <- df$cue_b
  
  # process log
  log <- ifelse(str_detect("log", df$log), "log10", "none")
  log_b <- ifelse(str_detect("log", df$log_b), "log10", "none")
  
  # process cue_range. cannot use by to ensure that both cue ranges are of the same length
  cue_range <- seq(df$low, df$high, length.out = 500)
  cue_range_b <- seq(df$low_b, df$high_b, length.out = 500)
  
  # optimization
  cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
  
  # start optimization LFBGS with inital value of 0.5x5
  res <- optimParallel(
    par = rep(0.5, 9),
    fn = chabaudi_si_clean, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, 0.01),
    cue = cue,
    cue_b = cue_b,
    cue_range = cue_range,
    cue_range_b = cue_range_b,
    log_cue = log,
    log_cue_b = log_b,
    solver = "vode",
    gam = "te")

  

  # close cluster
  stopCluster(cl)
  
  # get model output
  fitness <- res$value ## fitness difference between mutant and residence
  par <- res$par ## optimized parameters of mutant
  
  # produce output
  output <- cbind.data.frame(id = df$Var1, id_b = df$Var2, 
                             label = df$label, label_b = df$label_b,
                             fitness = fitness,
                             par1 = par[1], par2 = par[2], par3 = par[3], par4 = par[4], par5 = par[5], par6 = par[6], par7 = par[7], par8 = par[8], par9 = par[9])
  
  write.csv(output, here(paste0("data/dual_cue_opt4/", df$Var1, "_", df$Var2, ".csv")))
  return(output)
  
}
```

```{r}
lapply(dual_cue.ls, dual_cue_opt)
```

# processing dual cue optimization
we attempted two approaches: L-BFGS with ti model and te model. Now we are going to see which approach yielded higher fitness and whether those fitness are higher than individual cues. 

I found that te performed better in all combination 
```{r}
# read in the dataframe
ti_ls <- list.files(here("data/dual_cue_archive/dual_cue_opt"), pattern = "*.csv", full.names = T)
te_ls <- list.files(here("data/dual_cue_opt4"), pattern = "*.csv", full.names = T)

ti_ls2 <- lapply(ti_ls, read.csv)
te_ls2 <- lapply(te_ls, read.csv)

ti.df <- do.call(rbind, ti_ls2)
te.df <- do.call(rbind, te_ls2)

# compare fitness between ti and te. te performs almost comparable or better in all cases. we are going with te then!
left_join(select(ti.df, id, id_b, fitness_ti = fitness),
          select(te.df, id, id_b, fitness_te = fitness),
          by = c("id", "id_b")) %>% 
  mutate(diff = fitness_ti - fitness_te) %>% 
  ggplot() +
  geom_histogram(aes(x = diff)) +
  theme_bw()

te.df
```

# compare te with single cue optimization. 20 days non-resolved. vast majority cases better
```{r}
si_opt.df <- read.csv(here("data/si_opt.csv"))

# left join
te.df %>% 
  filter(fitness > 1) %>% 
  left_join(select(si_opt.df, id, fitness_si = fitness_20), by = c("id" = "id")) %>% 
  left_join(select(si_opt.df, id, fitness_si_b = fitness_20), by = c("id_b" = "id")) %>% 
  mutate(fitness_si_max = ifelse(fitness_si > fitness_si_b, fitness_si, fitness_si_b),
         fitness_dual_diff = fitness - fitness_si_max) %>% 
  ggplot() +
  geom_histogram(aes(x = fitness_dual_diff)) +
  theme_bw()

```


# sanity check. check fitness values manually. Looks good! everything processed fine
```{r}
te.df[1,]
# 9.666523 vs 9.666518	
res <- chabaudi_si_clean(
    parameters_cr = c(-2.805455,	3.667669,	-8.820523,	-4.768623,	-1.423754,	12.89147,	-1.247569,4.172313,	-9.4581),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, 0.01),
    cue = "G",
    cue_b = "I",
    cue_range = seq(0, log10(6*(10^4)), length.out = 500),
    cue_range_b = seq(0, log10(6*(10^6)), length.out = 500),
    log_cue = "log10",
    log_cue_b = "log10",
    solver = "vode",
    gam = "te")

# 9.525032 vs 9.525034	
te.df[2,]
res <- chabaudi_si_clean(
    parameters_cr = c(1.561287,	0.3340383,	1.46051,	-2.407999	,0.811395,	-0.4740528,	-1.263089,	3.056522,	-0.8416895),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, 0.01),
    cue = "G",
    cue_b = "I",
    cue_range = seq(0, log10(6*(10^4)), length.out = 500),
    cue_range_b = seq(0, 6*(10^6), length.out = 500),
    log_cue = "log10",
    log_cue_b = "none",
    solver = "vode",
    gam = "te")

# 8.566738 vs 8.566742
te.df[10,]
res <- chabaudi_si_clean(
    parameters_cr = c(13.69579,	-40.12598,	4.76825,	-8.054731,	28.40739,	-8.643984,	16.95231,	-14.9772,	-5.633644),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, 0.01),
    cue = "G",
    cue_b = "I",
    cue_range = seq(0, 6*(10^4), length.out = 500),
    cue_range_b = seq(0, 6*(10^6), length.out = 500),
    log_cue = "none",
    log_cue_b = "none",
    solver = "vode",
    gam = "te")



```


# get better fitness values. simulate dual cue for 30 days with same time step of 0.001
```{r}
dual_cue_dyn <- function(df){
  # process cues
  cue <- df$cue
  cue_b <- df$cue_b
  
  # process log
  log <- ifelse(str_detect(df$id, "log"), "log10", "none")
  log_b <- ifelse(str_detect(df$id_b, "log"), "log10", "none")
  
  # process cue_range. ensure that both cue ranges are of the same length
  cue_range <- seq(df$low, df$high, length.out = 500)
  cue_range_b <- seq(df$low_b, df$high_b, length.out = 500)
  
  # get parameter set
  par <- c(df$par1, df$par2, df$par3, df$par4, df$par5, df$par6, df$par7, df$par8, df$par9)
  
  # simulate dynamics
  dyn <- chabaudi_si_clean(
    parameters_cr = par,
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 30, 0.001),
    cue = cue,
    cue_b = cue_b,
    cue_range = cue_range,
    cue_range_b = cue_range_b,
    log_cue = log,
    log_cue_b = log_b,
    solver = "vode",
    gam = "te",
    dyn = T)
  
  # return 
  dyn2 <- cbind(id = df$id, id_b = df$id_b, 
                label = df$label, label_b = df$label_b,
                cue = cue, cue_b = cue_b, dyn)
  
  write_parquet(dyn2, here(paste0("data/dual_cue_dyn/", df$id, "_", df$id_b, ".parquet")))
  
}
```

# get dataframe for simulation
```{r}
cue_range_alt <- read.csv(here("data/cue_range_si_alt.csv"))
cue_range_alt
te.df2 <- te.df %>% 
  left_join(select(cue_range_alt, cue, id, low, high), by = "id") %>% 
  left_join(select(cue_range_alt, cue_b = cue, id_b = id, low_b = low, high_b = high), by = "id_b")
```

# run dynamics
```{r}
te_df.ls <- split(te.df2, seq(nrow(te.df2)))

mclapply(te_df.ls, dual_cue_dyn, mc.cores = 2)

# re run dyanmics only for those with I+Ig
te_df.ls2 <- split(te.df2 %>% filter(cue == "I+Ig" | cue_b == "I+Ig"), seq(nrow(te.df2 %>% filter(cue == "I+Ig" | cue_b == "I+Ig"))))
mclapply(te_df.ls2, dual_cue_dyn, mc.cores = 2)
```

#--------------------------------#
# figure creation
#--------------------------------#
# -----------------------#
comparing fitness of dual cue with best single cue
#------------------------#
# process data
```{r}
# get single infection best fitness
si_dyn <- read_parquet(here("data/si_dyn/si_dyn_30.parquet"))

si_fitness <- si_dyn %>% 
  filter(time == 30 & variable == "tau_cum")

si_fitness_20 <- si_dyn %>% 
  filter(time == 20 & variable == "tau_cum")

# get dual cue infection best fitness
dual_dyn.ls <- list.files(here("data/dual_cue_dyn/"), pattern = "*.parquet", full.names = T)
dual_dyn.ls2 <- lapply(dual_dyn.ls, read_parquet)

# get max fitness
dual.fitness_20 <- lapply(dual_dyn.ls2, function(x){
  # rename column
  names(x) <- c("id", "id_b", "label", "label_b", "cue", "cue_b", "time","variable", "value")
  df <- x %>% filter(time == 20 & variable == "tau_cum")
  return(df)
})

dual_fitness_20.df <- do.call(rbind, dual.fitness_20)
#write.csv(dual_fitness.df, here("data/dual_cue_opt4/dual_cue_fitness.csv"))
write.csv(dual_fitness_20.df, here("data/dual_cue_opt4/dual_cue_fitness_20.csv"))
dual_fitness_20.df <- read.csv(here("data/dual_cue_opt4/dual_cue_fitness_20.csv"))

# save dynamics parquet
dual_cue.dyn <- do.call(rbind, 
lapply(dual_dyn.ls2,
  function(x){
  # rename column
  names(x) <- c("id", "id_b", "label", "label_b", "cue", "cue_b", "time","variable", "value")
  return(x)}))

write_parquet(dual_cue.dyn, here("data/dual_cue_dyn/dual_cue_dyn.parquet"))
```

# plot 30 days fitness
majority of time, single cues perform better when optimized for 20 dayss
```{r}
# filter out low values
dual_fitness.df2 <- dual_fitness.df %>% filter(value > 2)

# left join with si 
dual_si.fitness <- dual_fitness.df2 %>% 
  left_join(select(si_fitness, id, si_fitness = value), by = "id") %>% 
  left_join(select(si_fitness, id_b = id, si_fitness_b = value), by = "id_b") %>% 
  mutate(si_fitness_max = ifelse(si_fitness > si_fitness_b, si_fitness, si_fitness_b),
         dual_label = paste(label, "+", label_b))

# plot
ggplot() +
  geom_point(data = dual_si.fitness, aes(y = forcats::fct_reorder(dual_label, value), x = value, color = "Dual cue"), size = 2.5, alpha = 0.7) +
  geom_point(data = dual_si.fitness, aes(y = forcats::fct_reorder(dual_label, value), x = si_fitness_max, color= "Best single cue"), size = 2.5, alpha = 0.7) +
  labs(x = "Fitness (30 days)", y = "Dual cue", color = "Cue") +
  scale_color_manual(values=c("#fc8d59", "#4575b4")) +
  theme_bw()
```

 # 20 days
 better relative dual-cue performance for 20 days
```{r}
# filter out low values
dual_fitness_20.df2 <- dual_fitness_20.df %>% filter(value > 2)

# left join with si 
dual_si_20.fitness <- dual_fitness_20.df2 %>% 
  left_join(select(si_fitness_20, id, si_fitness = value), by = "id") %>% 
  left_join(select(si_fitness_20, id_b = id, si_fitness_b = value), by = "id_b") %>% 
  mutate(si_fitness_max = ifelse(si_fitness > si_fitness_b, si_fitness, si_fitness_b),
         max_si_id = ifelse(si_fitness > si_fitness_b, id, id_b),
         max_si_label = ifelse(si_fitness > si_fitness_b, label, label_b),
         dual_label =  paste(label, "+", label_b))
# plot
dual_20_fitness.pl <- ggplot() +
  geom_point(data = dual_si_20.fitness, aes(y = forcats::fct_reorder(dual_label, value), x = value, color = "Dual cue"), size = 2.5, alpha = 0.7) +
  geom_point(data = dual_si_20.fitness, aes(y = forcats::fct_reorder(dual_label, value), x = si_fitness_max, color= "Best single cue"), size = 2.5, alpha = 0.7) +
  labs(x = "Fitness (20 days)", y = "Dual cue", color = "Cue") +
  scale_color_manual(values=c("#fc8d59", "#4575b4")) +
  geom_vline(xintercept = 9.883602) +
  theme_bw()
```
#--------------------------------#
# controls for spline flexibility
#--------------------------------#
We see that dual cue performed better than single cue. One can argue that the higher amount of coefficients we allow in the model is what accounts for the higher fitness (higher flexibility) in conversion rate shape and form.

Hence, we should perform optimization of high performing single cue model using a high degree of spline flexibility (k = 8 for 9 coefficients).

For many of the cues, increasing number of parameter coefficients to 9 led to an increase in fitness that makes them comparable to the dual cue. However, the exception is R log vs I log where none of the cue can come close to it (except when we optimize with regards to time).
```{r}
# get functions that allow higher spline flexibility
source(here("functions/chabaudi_si_clean_high.R"))

# I+Ig log with higher amount flexibility
# 9.634148 
# 1.6063738  6.8276921 11.7133803  4.0752217 -7.9723275 -7.1263479  2.9175874 -0.9805917 -5.6119974
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
I_Ig_high.opt <- optimParallel(
    par = rep(0.5,9), # start at 0.5x4
    fn = chabaudi_si_clean_high, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 1e-3),
    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
    cue = "Ig+I",
    log_cue = "log10",
    solver = "vode",
    k = 8)
stopCluster(cl)


# I log
# 9.517763 
# 1.296675  3.544034  4.907484  2.174249 -3.238309 -5.181614 -1.645072  1.834302  1.581011
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
I_high.opt <- optimParallel(
    par = rep(0.5,9), # start at 0.5x4
    fn = chabaudi_si_clean_high, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 1e-3),
    cue_range =  seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
    cue = "I",
    log_cue = "log10",
    solver = "vode",
    k = 8)
stopCluster(cl)

# Ig log
# 2.008560 -3.284691 -6.122977 -2.641527  2.254999 -4.656014 -7.612234  2.092484  5.665307
# 9.693066
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
Ig_high.opt <- optimParallel(
    par = rep(0.5,9), # start at 0.5x4
    fn = chabaudi_si_clean_high, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 1e-3),
    cue_range =  seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
    cue = "Ig",
    log_cue = "log10",
    solver = "vode",
    k = 8)
stopCluster(cl)

# G log
# 1.5255085 -6.1534877 -0.4957473 -1.0672087 -0.9055635 -2.8081859 -5.0503345 -1.5444946 2.6449283
# 9.631911
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
G_high.opt <- optimParallel(
    par = rep(0.5,9), # start at 0.5x4
    fn = chabaudi_si_clean_high, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 1e-3),
    cue_range =  seq(0, log10(6*(10^4)), by = (log10(6*(10^4)))/5000),
    cue = "G",
    log_cue = "log10",
    solver = "vode",
    k = 8)
stopCluster(cl)

# R log
# 8.243898 
# 5.0340348   0.5846168   0.3749648   0.6842673   2.4748107  10.9036034  16.8246316 -24.8690971 1.8007238
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
R_high.opt <- optimParallel(
    par = rep(0.5,9), # start at 0.5x4
    fn = chabaudi_si_clean_high, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 1e-3),
    cue_range =  seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000),
    cue = "R",
    log_cue = "log10",
    solver = "vode",
    k = 8)
stopCluster(cl)
R_high.opt
```


#--------------------------------#
# time series conversion rate
#_-------------------------------#
# process data
```{r}
# get time series conversion rate of the top 42cues, first for 30 days fitness, last for 20 days fitness
top2 <- dual_si_20.fitness %>% 
  filter(dual_label %in% c("G log + Ig log", "R log + I log"))

## get time-series conversion rate
## dual cue
dual.cr <- lapply(dual_dyn.ls2,
  function(x){
  # rename column
  names(x) <- c("id", "id_b", "label", "label_b", "cue", "cue_b", "time","variable", "value")
  df <- x %>% filter(variable == "cr")
  return(df)}
)
```

# get perfect dynamic (time as cue optimization)
```{r}
## perfect dynamic when parasite can sense time
## 20 days
## 4.55386 -13.0056 4.15466 -11.9424. fitness: 9.787899 
# reoptimize using 2x4 because lower fitness than R log + I log 4.55622 -13.0131 4.158 -11.9506 (9.787899)
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
time_20.cr <- optimParallel(
    par = rep(2,4), # start at 0.5x4
    fn = chabaudi_si_clean, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 1e-3),
    cue_range =  seq(0, 20, by = 1e-3),
    cue = "t",
    solver = "vode")
stopCluster(cl)

## trying global optimization
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
max_20.fitness <- DEoptim::DEoptim(fn = chabaudi_si_clean,
                 control = list(trace = 1, parallelType = 1, itermax = 1000),
                 lower = c(-1, -100, -1000, -5000),
                 upper = c(1, 100, 1000, 5000),
                 immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 1e-3),
    cue_range =  seq(0, 20, by = 1e-3),
    cue = "t",
    solver = "vode",
    neg = T)
stopCluster(cl)

## 30 days
## fitness: 13.663812 (much higher, which is expected)
##1.352203 -5.776961  2.321642 -3.720546
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
time_30.cr <- optimParallel(
    par = rep(0.5,4), # start at 0.5x4
    fn = chabaudi_si_clean, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 30, by = 1e-3),
    cue_range =  seq(0, 30, by = 1e-3),
    cue = "t",
    solver = "vode")
stopCluster(cl)

## using higher spline flexibility. k = 8 to take 9 parameters
# $par 9.154314  -7.570829 -22.506638   3.382405 -13.453519 -17.011485   3.678181 -12.851895 -26.115158
# 9.883602
source(here("functions/chabaudi_si_clean_high.R"))
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
time_high.cr <- optimParallel(
    par = rep(0.5,9), # start at 0.5x4
    fn = chabaudi_si_clean_high, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 1e-3),
    cue_range =  seq(0, 20, by = 1e-3),
    cue = "t",
    solver = "vode")
stopCluster(cl)

# get time series conversion rate dynamics
## 20 days
time_20.cr <- chabaudi_si_clean_high(
  parameters_cr = c(9.154314,  -7.570829, -22.506638 ,  3.382405 ,-13.453519 ,-17.011485  , 3.678181, -12.851895 ,-26.115158),
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = seq(0, 20, by = 1e-3),
  cue_range =  seq(0, 20, by = 1e-3),
  cue = "t",
  solver = "vode",
  dyn = T)

## 30 days
time_30.cr <- chabaudi_si_clean(
  parameters_cr = c(1.352203, -5.776961,  2.321642, -3.720546),
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = seq(0, 30, by = 1e-3),
  cue_range =  seq(0, 30, by = 1e-3),
  cue = "t",
  solver = "vode",
  dyn = T)

## process to match
time_20.cr2 <- time_20.cr %>% filter(variable == "cr") %>% mutate(label_new = "Time") %>% select(-variable)

time_30.cr2 <- time_30.cr %>% filter(variable == "cr") %>% mutate(label_new = "Time") %>% select(-variable)
```

# get dynamics of I log with more parameters
## control for parameter coefficients
```{r}
I_high_20.cr <- chabaudi_si_clean_high(
  parameters_cr = c(1.296675,  3.544034 , 4.907484,  2.174249, -3.238309 ,-5.181614 ,-1.645072 , 1.834302 , 1.581011),
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = seq(0, 20, by = 1e-3),
  cue_range =  seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
  cue = "I",
  log_cue = "log10",
  solver = "vode",
  dyn = T)

# process
I_high_20.cr2 <- I_high_20.cr %>% filter(variable == "cr") %>% mutate(label_new = "I log high") %>% select(-variable)
```

# get dual cue and single cue dynamics
```{r}
## keep only top 1 fir each. 
dual.cr2 <- do.call(rbind, dual.cr)
dual.cr3 <- dual.cr2 %>% 
  mutate(dual_label = paste(label, "+", label_b)) %>% 
  filter(dual_label %in% top2$dual_label)

# get corresponding conversion rate for best single infection cue
single.cr <- si_dyn %>% 
  filter(variable == "cr" & id %in% top2$max_si_id) %>% 
  left_join(select(top2, max_si_id, dual_label, max_si_label), by = c("id" = "max_si_id"))

# left join dual and single cue dynamics
dual_single.cr <- left_join(select(dual.cr3, dual_label, time, dual_cr = value), select(single.cr, time, single_cr = value, id, dual_label, max_si_label), by = c("time", "dual_label"))

# make long
dual_single.cr2 <- tidyr::pivot_longer(dual_single.cr, cols = c("dual_cr", "single_cr")) %>% 
  mutate(label_new = ifelse(name == "dual_cr", dual_label, max_si_label),
         status = ifelse(dual_label == "G log + Ig log", "Best 30 days dual cue", "Best 20 days dual cue")) 

# filter out the 20 days and 30 days
dual_single_cr.20 <- dual_single.cr2 %>% 
  filter(status == "Best 20 days dual cue") %>% 
  select(time, label_new, value) %>% 
  rbind(time_20.cr2, I_high_20.cr2) %>% 
  mutate(label_new2 = case_when(
    label_new == "R log + I log" ~ "RBC logged + asexual iRBC log10",
    label_new == "I log" ~ "Asexual iRBC log10",
    label_new == "Time" ~ "Time",
    label_new == "I log high" ~ "Asexual iRBC log10 flexible"
  ))
```

# plot time series conversion rate
```{r}
# 20 days
dual_time_cr.pl <- ggplot() +
  geom_line(data = dual_single_cr.20, aes(color =label_new2, x = time, y = value), size = 1) +
  labs(x = "Time (days)", y = "Conversion rate", color = "Cue") +
  xlim(0, 20) +
  scale_color_manual(values = c("#4575b4", "#91bfdb","#fc8d59","#fdcb44")) +
  theme_bw() +
  theme(legend.position="bottom") +
  guides(color = guide_legend(nrow = 2, byrow = TRUE))
```

#--------------------------#
# heatmap of conversion rate
#--------------------------#
```{r}
# get heat map of best cues
source(here("functions/par_to_hm_te.R"))

R_I.hm <- par_to_hm_te(par = c(4.446192033,	10.97518275,	1.38762817,	23.3059254,	-3.452052371,	-18.0070692,	39.66614226,	-3.545193141,	18.78350799),
             cue_range = seq(6,	7, length.out = 500),
             cue_range_b = seq(0,	6.77815125, length.out = 500))

# get dynamics
dual.dyn <- lapply(dual_dyn.ls2,
  function(x){
  # rename column
  names(x) <- c("id", "id_b", "label", "label_b", "cue", "cue_b", "time","variable", "value")
  df <- x %>% filter(variable %in% c("R", "I"))
  return(df)}
)

dual.dyn2 <- do.call(rbind, dual.dyn)

## R_I dynamics
R_I.dyn <- dual.dyn2 %>% 
  filter(label == "R log" & label_b == "I log") %>% 
  tidyr::pivot_wider(names_from = variable, values_from = value) %>% 
  mutate(log_R = log10(R),
         log_I = log10(I))
  
# plot
## 20 days best cue
ri_hm.pl <- ggplot() +
  geom_raster(data = R_I.hm, aes(x = cue_range_b, y = cue_range, fill = cr)) +
  scale_fill_viridis_c() +
  geom_path(data = R_I.dyn, aes(x = log_I, y = log_R), color = "white", arrow = arrow(angle = 30, length = unit(0.1, "inches"))) +
  geom_point(data = R_I.dyn %>% filter(row_number() %% 1000 == 1 & time <= 20), aes(x = log_I, y = log_R), color = "white") +
  xlim(0.99*min(hablar::s(R_I.dyn$log_I), na.rm = T), 1.01* max(hablar::s(R_I.dyn$log_I), na.rm = T)) +
  ylim(0.99*min(hablar::s(R_I.dyn$log_R), na.rm = T),1.01* max(hablar::s(R_I.dyn$log_R), na.rm = T)) +
  labs(y = "RBC log10", x = "Asexual iRBC log10", fill = "Conversion rate") +
  theme_dark()
```


#--------- assemble final figure---------#
```{r}
cr_hm.pl <- ggarrange(dual_time_cr.pl, ri_hm.pl, ncol = 1, labels = c("B", "C"))

ggarrange(dual_20_fitness.pl, cr_hm.pl, ncol = 2, labels = c("A", ""))
ggsave(here("figures/report22/dual_cue_final.png"), width = 11, height = 7)
```


#--------------------------------------#
# Malaria dynamics figure
#--------------------------------------#
This figure contains the disease curve and tried to give readers a sense of the consequences of adopting good cues and bad cues. What are the consequences for parasite virulence? What sort of differential response is responsible for parasite dynamics difference (immunity, RBC limitation...)

#------- getting drivers of best cue -----------#
to get why some cues are better than others, assessing time series conversion rate and dynamics is one thing. To truely see how parasites are doing better, we have to look at how parasites are addressing the threats it is facing. These include 
1) targetted immunity
2) indiscriminant immunity
3) RBC limitation

# Sanity checking all new scripts 
```{r}
# RBC is constant
source(here("functions/chabaudi_si_clean_R.R"))
## running random dynamic. R should be constant! Everything checks out
R_sc <- chabaudi_si_clean_R(
  parameters_cr = rep(0.5, 4),
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = seq(0, 20, by = 1e-3),
  cue_range =  R_range_log,
  cue = "R",
  log_cue = "log10",
  solver = "vode",
  dyn = T)

ggplot() +
  geom_line(data = R_sc, aes(x = time, y = value)) +
  facet_wrap(~variable, scales = "free")

# no indiscriminant immunity 
source(here("functions/chabaudi_si_clean_N.R"))
N_sc <- chabaudi_si_clean_N(
  parameters_cr = rep(0.5, 4),
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = seq(0, 20, by = 1e-3),
  cue_range =  R_range_log,
  cue = "R",
  log_cue = "log10",
  solver = "vode",
  dyn = T)

ggplot() +
  geom_line(data = N_sc, aes(x = time, y = value)) +
  facet_wrap(~variable, scales = "free")

# no targeted immunity
source(here("functions/chabaudi_si_clean_W.R"))
W_sc <- chabaudi_si_clean_W(
  parameters_cr = rep(0.5, 4),
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = seq(0, 20, by = 1e-3),
  cue_range =  R_range_log,
  cue = "R",
  log_cue = "log10",
  solver = "vode",
  dyn = T)

ggplot() +
  geom_line(data = W_sc, aes(x = time, y = value)) +
  facet_wrap(~variable, scales = "free")


# no targeted and indiscriminant immunity
source(here("functions/chabaudi_si_clean_NW.R"))
NW_sc <- chabaudi_si_clean_NW(
  parameters_cr = rep(0.5, 4),
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = seq(0, 20, by = 1e-3),
  cue_range =  R_range_log,
  cue = "R",
  log_cue = "log10",
  solver = "vode",
  dyn = T)

ggplot() +
  geom_line(data = W_sc, aes(x = time, y = value, color = "W")) +
  geom_line(data = NW_sc, aes(x = time, y = value, color = "NW")) +
  facet_wrap(~variable, scales = "free")
```

#---------- single infection -----------#
Note: all calculations done for 20 days optimization

# single infection function
```{r}
partition_si <- function(df){
  # source all functions
  source(here("functions/chabaudi_si_clean.R"))
  source(here("functions/chabaudi_si_clean_R.R"))
  source(here("functions/chabaudi_si_clean_N.R"))
  source(here("functions/chabaudi_si_clean_W.R"))
  source(here("functions/chabaudi_si_clean_NW.R"))
  
  # get parameters
  parameters_tsukushi <- c(R1 = 8.89*(10^6), # slightly higher
                lambda = 3.7*(10^5),
                mu = 0.025, 
                p = 8*(10^-6), # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156)
  
  # get all characteristics
  cue <- df$cue
  log <- ifelse(df$log == "log", "log10", "none")
  par <- c(df$var1, df$var2, df$var3, df$var4)
  cue_range <- seq(df$low, df$high, by = df$by)
  id <- df$id
  
  # run simulation with default function
  default <- chabaudi_si_clean(
  parameters_cr = par,
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = seq(0, 20, by = 1e-3),
  cue_range =  cue_range,
  cue = cue,
  log_cue = log,
  solver = "vode")
  
  # run simulation with static RBC
  static_R <- chabaudi_si_clean_R(
  parameters_cr = par,
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = seq(0, 20, by = 1e-3),
  cue_range =  cue_range,
  cue = cue,
  log_cue = log,
  solver = "vode")
  
  # run simulation with no indiscriminant immunity (N)
  no_N <- chabaudi_si_clean_N(
  parameters_cr = par,
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = seq(0, 20, by = 1e-3),
  cue_range =  cue_range,
  cue = cue,
  log_cue = log,
  solver = "vode")
  
  # run simulation with no targeted immunity (W)
  no_W <- chabaudi_si_clean_W(
  parameters_cr = par,
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = seq(0, 20, by = 1e-3),
  cue_range =  cue_range,
  cue = cue,
  log_cue = log,
  solver = "vode")
  
  # runs imulation with no indiscriminant and targeted immunity
  no_NW <- chabaudi_si_clean_NW(
  parameters_cr = par,
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = seq(0, 20, by = 1e-3),
  cue_range =  cue_range,
  cue = cue,
  log_cue = log,
  solver = "vode")
  
  # join together all data
  res <- cbind(id = id,
               cue = cue,
               log = log,
               fitness = as.numeric(default),
               fitness_R = as.numeric(static_R),
               fitness_N = as.numeric(no_N),
               fitness_W = as.numeric(no_W),
               fitness_NW = as.numeric(no_NW))
  
  return(res)
}
  
```

# run single infection function
```{r}
# import in optimized df
si_opt.df <- read.csv(here("data/si_opt.csv"))

# join with cue_range
cue_range_si.df <- read.csv(here("data/cue_range_si.csv"))
si_opt.df <- si_opt.df %>% left_join(select(cue_range_si.df, low, high, by, id), "id")

# mclapply loop
si_opt.ls <- split(si_opt.df, seq(nrow(si_opt.df)))
partition_si.res <- mclapply(si_opt.ls, partition_si, mc.cores = 5)

# save results
partition_si.df <- as.data.frame(do.call(rbind, partition_si.res))
write.csv(partition_si.df, here("data/partition/si_partition.csv"))
```

# analyze
Unexpected results. higher cv when we remove these constraints. Some strategies even suffered when we kept RBC constant! Might need to optimize
```{r}
partition_si.df2 <- partition_si.df %>% 
  tidyr::pivot_longer(cols = -c(id, cue, log), names_to = "fitness_status") %>% 
  mutate(value = as.numeric(value))

partition_si.df2 <- partition_si.df2 %>% left_join(select(partition_si.df, id, fitness), by = "id")

ggplot() +
  geom_point(data = partition_si.df2, aes(y = fct_reorder(id, fitness), x = value, color = fitness_status)) +
  theme_bw()
```

#-------------------------------------#
# optimization to partition what makes a cue goood
#-------------------------------------#
# preliminary testing with the best cue and the worst cue for single infection.
# previously, we have a difference of 1.4. Now we have a difference of 1. Maybe smaller? So targeted immunity. Overall, this approach is promising
```{r}
# 12.063539 
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
Ig_log_W.opt <- optimParallel(
    par = rep(0.5,4), # start at 0.5x4
    fn = chabaudi_si_clean_W, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 1e-3),
    cue_range =  I_range_log,
    cue = "Ig",
    log_cue = "log10",
    solver = "vode")
stopCluster(cl)

# 11.059974 
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
R_log_W.opt <- optimParallel(
    par = rep(0.5,4), # start at 0.5x4
    fn = chabaudi_si_clean_W, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 1e-3),
    cue_range =  R_range_log,
    cue = "R",
    log_cue = "log10",
    solver = "vode")
stopCluster(cl)

R_log_W.opt$value
```

# function to run optimization using 3 different functions (staticR, no N, and noW)
```{r}
partition_si <- function(df){
  # source all functions
  source(here("functions/chabaudi_si_clean.R"))
  source(here("functions/chabaudi_si_clean_R.R"))
  source(here("functions/chabaudi_si_clean_N.R"))
  source(here("functions/chabaudi_si_clean_W.R"))
  
  # get parameters
  parameters_tsukushi <- c(R1 = 8.89*(10^6), # slightly higher
                lambda = 3.7*(10^5),
                mu = 0.025, 
                p = 8*(10^-6), # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156)
  
  # get all characteristics
  cue <- df$cue
  log <- ifelse(df$log == "log", "log10", "none")
  cue_range <- seq(df$low, df$high, by = df$by)
  id <- df$id
  
  # run optimization with static RBC
  cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
  static_R <- optimParallel(
    par = rep(0.5,4), # start at 0.5x4
    fn = chabaudi_si_clean_R, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 1e-3),
    cue_range =  cue_range,
    cue = cue,
    log_cue = log,
    solver = "vode")

  
  # run optimization with no indiscriminant immunity
  no_N <- optimParallel(
    par = rep(0.5,4), # start at 0.5x4
    fn = chabaudi_si_clean_N, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 1e-3),
    cue_range =  cue_range,
    cue = cue,
    log_cue = log,
    solver = "vode")
  
  # run simulation with no targeted immunity (W)
  no_W <- optimParallel(
    par = rep(0.5,4), # start at 0.5x4
    fn = chabaudi_si_clean_W, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 1e-3),
    cue_range =  cue_range,
    cue = cue,
    log_cue = log,
    solver = "vode")
  
  stopCluster(cl)
  
  # join together all data
  res <- cbind(id = id,
               cue = cue,
               log = log,
               fitness_R = static_R$value,
               fitness_N = no_N$value,
               fitness_W = no_W$value,
               var_R1 = static_R$par[[1]],
               var_R2 = static_R$par[[2]], 
               var_R3 = static_R$par[[3]],
               var_R4 = static_R$par[[4]],
               var_N1 = no_N$par[[1]],
               var_N2 = no_N$par[[2]], 
               var_N3 = no_N$par[[3]],
               var_N4 = no_N$par[[4]],
               var_W1 = no_W$par[[1]],
               var_W2 = no_W$par[[2]], 
               var_W3 = no_W$par[[3]],
               var_W4 = no_W$par[[4]])
  
  write.csv(res, paste0(here("data/partition/si/"), id, "_partition.csv"))
}
```

# run function
```{r}
# import in optimized df
si_opt.df <- read.csv(here("data/si_opt.csv"))

# join with cue_range
cue_range_si.df <- read.csv(here("data/cue_range_si.csv"))
si_opt.df <- si_opt.df %>% left_join(select(cue_range_si.df, low, high, by, id), "id")

# lapply loop
si_opt.ls <- split(si_opt.df, seq(nrow(si_opt.df)))
lapply(si_opt.ls, partition_si)

```

#-----------------------------------------#
# partition co-infection
#-----------------------------------------#
```{r}
partition_ci <- function(df){
  # get info
  limit <- 0.01
  time_range <- seq(0, 20, 1e-3)
  cue_1 <- df$cue_1
  cue_2 <- df$cue_2
  log <- ifelse(df$log == "log", "log10", "none")
  cue_range <- seq(df$low, df$high, by = df$by)
  
# perform optimization
## no R
  res_R <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
    limit = limit,
    model = chabaudi_ci_clean_R,
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = time_range,
    cue_1 = cue_1,
    cue_2 = cue_2,
    cue_range_1 = cue_range,
    cue_range_2 = cue_range,
    solver = "vode",
    log_cue_1 = log,
    log_cue_2 = log)
  
  return(list(res_R))
  
## no N
  res_N <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
    limit = limit,
    model = chabaudi_ci_clean_N,
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = time_range,
    cue_1 = cue_1,
    cue_2 = cue_2,
    cue_range_1 = cue_range,
    cue_range_2 = cue_range,
    solver = "vode",
    log_cue_1 = log,
    log_cue_2 = log)
  
## no W
  res_W <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
    limit = limit,
    model = chabaudi_ci_clean_W,
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = time_range,
    cue_1 = cue_1,
    cue_2 = cue_2,
    cue_range_1 = cue_range,
    cue_range_2 = cue_range,
    solver = "vode",
    log_cue_1 = log,
    log_cue_2 = log)
  
  stopCluster(cl)
  
  # get results
  ## get last index
  index_R <- length(unlist(res_R))/10
  index_N <- length(unlist(res_N))/10
  index_W <- length(unlist(res_W))/10
  
  ## get actual results from last iteration
  res_R2 <- unlist(res_R[[1]][[index_R+1]])
  res_N2 <- unlist(res_N[[1]][[index_N+1]])
  res_W2 <- unlist(res_W[[1]][[index_W+1]])
  
  # reorganize results
  res_R3 <- cbind(status = "static_R",
                  var1 = res_R2[2],
                  var2 = res_R2[3],
                  var3 = res_R2[4],
                  var4 = res_R2[5])
  
  res_N3 <- cbind(status = "no_N",
                  var1 = res_N2[2],
                  var2 = res_N2[3],
                  var3 = res_N2[4],
                  var4 = res_N2[5])
                  
  res_W3 <- cbind(status = "no_W",
                  var1 = res_W2[2],
                  var2 = res_W2[3],
                  var3 = res_W2[4],
                  var4 = res_W2[5])
  
  # cat results
  res_final <- rbind(res_R3, res_N3, res_W3)
  write.csv(res_final, paste0(here("data/partition/ci/"), df$id, "_partition.csv"))
  
}

```

# run function
```{r}
#import in all functions
source(here("functions/chabaudi_ci_clean_R.R"))
source(here("functions/chabaudi_ci_clean_N.R"))
source(here("functions/chabaudi_ci_clean_W.R"))
source(here("functions/co_infection_opt_alt.R"))

# import in ci opt
ci_opt.df <- read.csv(here("data/ci_opt.csv"))

# left join with cue range
cue_range_ci.df <- read.csv(here("data/cue_range_ci.csv"))
ci_opt.df <- ci_opt.df %>% left_join(select(cue_range_ci.df, low, high, by, id), "id")

# test
test <- partition_ci(ci_opt.df[1,])
length(lapply(test, unlist))
n <- length(unlist(test))/10

test2 <- unlist(test[[1]][[n+1]])
test3 <- cbind(status = "no_W",
                  var1 = test2[2],
                  var2 = test2[3],
                  var3 = test2[4],
                  var4 = test2[5])

ci_opt.df[1,]

paste0(here("data/partition/ci/"), "I-i_none", ".csv")
```

#---------------------------#
# partitioning dual cue
#---------------------------#
```{r}
# function to run optimization using 3 different functions (staticR, no N, and noW)
partition_dual <- function(df){
  # source all functions
  source(here("functions/chabaudi_si_clean.R"))
  source(here("functions/chabaudi_si_clean_R.R"))
  source(here("functions/chabaudi_si_clean_N.R"))
  source(here("functions/chabaudi_si_clean_W.R"))
  
  # get parameters
  parameters_tsukushi <- c(R1 = 8.89*(10^6), # slightly higher
                lambda = 3.7*(10^5),
                mu = 0.025, 
                p = 8*(10^-6), # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156)
  
  # get all characteristics
  cue <- df$cue
  cue_b <- df$cue_b
  log <- ifelse(df$log == "log", "log10", "none")
  log_b <- ifelse(df$log_b == "log", "log10", "none")
  cue_range <- seq(df$low, df$high, length.out = 500)
  cue_range_b <- seq(df$low_b, df$high_b, length.out = 500)
  id <- df$id
  id_b <- df$id_b
  
  # run optimization with static RBC
  cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
  static_R <- optimParallel(
    par = rep(0.5,9), # start at 0.5x4
    fn = chabaudi_si_clean_R, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 0.01),
    cue = cue,
    cue_b = cue_b,
    cue_range = cue_range,
    cue_range_b = cue_range_b,
    log_cue = log,
    log_cue_b = log_b,
    solver = "vode",
    gam = "te")

  
  # run optimization with no indiscriminant immunity
  no_N <- optimParallel(
    par = rep(0.5,9), # start at 0.5x4
    fn = chabaudi_si_clean_N, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 0.01),
    cue = cue,
    cue_b = cue_b,
    cue_range = cue_range,
    cue_range_b = cue_range_b,
    log_cue = log,
    log_cue_b = log_b,
    solver = "vode",
    gam = "te")
  
  # run simulation with no targeted immunity (W)
  no_W <- optimParallel(
    par = rep(0.5,9), # start at 0.5x4
    fn = chabaudi_si_clean_W, 
    control = list(trace = 6, fnscale = -1),
    immunity = "tsukushi",
    parameters = parameters_tsukushi,
    time_range = seq(0, 20, by = 0.01),
    cue = cue,
    cue_b = cue_b,
    cue_range = cue_range,
    cue_range_b = cue_range_b,
    log_cue = log,
    log_cue_b = log_b,
    solver = "vode",
    gam = "te")
  
  stopCluster(cl)
  
  # join together all data
  res <- cbind(id = id,
               id_b = id_b,
               cue = cue,
               cue_b = cue,
               log = log,
               log_b = log_b,
               fitness_R = static_R$value,
               fitness_N = no_N$value,
               fitness_W = no_W$value,
               var_R1 = static_R$par[[1]],
               var_R2 = static_R$par[[2]], 
               var_R3 = static_R$par[[3]],
               var_R4 = static_R$par[[4]],
               var_R5 = static_R$par[[5]],
               var_R6 = static_R$par[[6]],
               var_R7 = static_R$par[[7]],
               var_R8 = static_R$par[[8]],
               var_R9 = static_R$par[[9]],
               var_N1 = no_N$par[[1]],
               var_N2 = no_N$par[[2]], 
               var_N3 = no_N$par[[3]],
               var_N4 = no_N$par[[4]],
               var_N5 = no_N$par[[5]],
               var_N6 = no_N$par[[6]],
               var_N7 = no_N$par[[7]],
               var_N8 = no_N$par[[8]],
               var_N9 = no_N$par[[9]],
               var_W1 = no_W$par[[1]],
               var_W2 = no_W$par[[2]], 
               var_W3 = no_W$par[[3]],
               var_W4 = no_W$par[[4]],
               var_W5 = no_W$par[[5]],
               var_W6 = no_W$par[[6]],
               var_W7 = no_W$par[[7]],
               var_W8 = no_W$par[[8]],
               var_W9 = no_W$par[[9]])
  
  write.csv(res, paste0(here("data/partition/dual/"), id, "_", id_b, "_partition.csv"))
}
```

# get running df
```{r}
si_opt.csv <- read.csv(here("data/si_opt.csv"))

#W get all unique combinations but eliminating all combinations that uses the same cue
dual_cue.df <- expand.grid(si_opt.csv$id, si_opt.csv$id) %>% 
  filter(Var1 != Var2) %>% 
  left_join(select(si_opt.csv, cue1 = cue, id), by = c("Var1" = "id")) %>% 
  left_join(select(si_opt.csv, cue2 = cue, id), by = c("Var2" = "id")) %>% 
  filter(cue1 != cue2) %>% 
  mutate(temp = paste(pmin(Var1, Var2), pmax(Var1, Var2))) %>% 
  distinct(temp, .keep_all = T) # get rid of the same cue combination but just in different orders


# get cue range (500 divisons)
cue_range_alt <- read.csv(here("data/cue_range_si_alt.csv"))
dual_cue.df2 <- dual_cue.df %>% 
  left_join(cue_range_alt, by = c("Var1" = "id")) %>% 
  left_join(select(cue_range_alt, cue_b = cue, log_b = log, low_b = low, high_b = high, by_b = by, id_b = id, label_b = label), by = c("Var2" = "id_b"))

dual_cue.ls <- split(dual_cue.df2, seq(nrow(dual_cue.df2)))
```

 # run function
```{r}
lapply(dual_cue.ls, partition_dual)
```







