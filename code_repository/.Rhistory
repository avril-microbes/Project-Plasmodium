library(dplyr)
library(ggplot2)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
# for single infections
source(here("functions/opt_local.R"))
source(here("functions/chabaudi_si_clean.R"))
source(here("functions/validate_si.R"))
# for co-infections
source(here("functions/co_infection_opt_alt.R"))
source(here("functions/co_infection_opt_do.R"))
source(here("functions/chabaudi_ci_clean.R"))
source(here("functions/validate_ci.R"))
# Import in the list of single infection optimization results
si_opt.df2 <- read.csv(here("data/si_opt.csv"))
# split into individual tables
si_opt.ls <- split(si_opt.df, seq(nrow(si_opt.df)))
# import in all single infection data
si_val.ls <- list.files(path = here("data/si_validation"), pattern = "*.csv", full.names = T)
# get max fitness from simulation. left join with si_opt
si_opt.df <- read.csv(here("data/si_opt.csv"))
# import in ci optimum for same cue and join with cue range
ci_opt.df <- read.csv(here("data/ci_opt.csv"))
cue_range.df <- read.csv(here("data/cue_range_ci.csv"))
# read in the results file
ci_val.ls <- list.files(path = here("data/ci_validation"), pattern = "*.csv", full.names = T)
ci_val.ls2 <- lapply(ci_val.ls, read.csv)
ci_val.df <- do.call(rbind, ci_val.ls2)
# Here, we are competing strain 1 (adopting supposed optimum strategy) with strain 2 adopting a randomized strategy. Hence, we expect fitness difference to be above 1!
ci_val.df %>%
group_by(label) %>%
summarize(min_fitness = min(V1))
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
source("~/.active-rstudio-document")
# for dual cue
source(here("functions/dual_cue_opt.R"))
here()
# for dual cue
source(here("functions/dual_cue_opt.R"))
library(dplyr)
library(ggplot2)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
# for dual cue
source(here("functions/dual_cue_opt.R"))
here()
library(dplyr)
library(ggplot2)
library(forcats)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
library(stringr)
library(parallel)
library(ggpubr)
library(dplyr)
library(ggplot2)
library(forcats)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
library(stringr)
library(parallel)
library(ggpubr)
# single infection dynamics, reaction norms, and rugs
si_dyn.df <- read_parquet(here("data/si_dyn/si_dyn_30.parquet"))
si_rn.df <- read_parquet(here("data/si_dyn/si_rn.parquet"))
si_rug.df <- read_parquet(here("data/si_dyn/si_rug.parquet"))
here()
here::here()
here::here()
library(dplyr)
library(ggplot2)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
library(parallel)
# for single infections
source(here("code_repository/functions/opt_local.R"))
source(here("code_repository/functions/chabaudi_si_clean.R"))
source(here("code_repository/functions/validate_si.R"))
# for co-infections
source(here("code_repository/functions/co_infection_opt_alt.R"))
source(here("code_repository/functions/co_infection_opt_do.R"))
source(here("code_repository/functions/chabaudi_ci_clean.R"))
source(here("code_repository/functions/validate_ci.R"))
# for dual cue
source(here("code_repository/functions/dual_cue_opt.R"))
# for static competition
source(here("code_repository/functions/ci_comp_static.R"))
# for invasive competition
source(here("code_repository/functions/ci_invasion_analysis.R"))
# for partitioning analysis
source(here("code_repository/functions/partition_si.R"))
# for semi-stochastic single infection model
source(here("code_repository/functions/mc_all.R"))
source(here("code_repository/functions/mc_single.R"))
mc_I_log.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(5.463558,   2.383948, -17.757281,   4.571835),
cue = "I",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)},
mc.cores = 8)
# import in posterior distribution. Note that id = 1 is the reference!
posterior <- read.csv(here("code_repository/data/posterior.csv"))
# get list of dataframes split by row
posterior.ls <- split(posterior, seq(nrow(posterior)))
mc_I_log.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(5.463558,   2.383948, -17.757281,   4.571835),
cue = "I",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)},
mc.cores = 8)
# Sexual iRBC
mc_Ig.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(0.05234791,  -46.03368629, 1897.61313455,   70.57689145),
cue = "Ig",
cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
log= "none",
rand_df = x)},
mc.cores = 8)
mc_Ig_log.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(1.74633, -1.78582, -5.52834, 1.57344 ),
cue = "Ig",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)},
mc.cores = 8)
# all iRBC
mc_I_Ig.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(0.3159297,  -46.1104558, 1250.7529081,   -6.1982093),
cue = "I+Ig",
cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
log= "none",
rand_df = x)},
mc.cores = 8)
mc_I_Ig_log.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(3.594042,   4.157744, -13.530672,   2.599905),
cue = "I+Ig",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)},
mc.cores = 8)
# gametocyte
MC_G.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(0.04061288,   -9.31445958,   74.13015506, -431.59843638),
cue = "G",
cue_range = seq(0, 6*(10^4), (6*(10^4))/5000),
log= "none",
rand_df = x)},
mc.cores = 8)
mc_G_log.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(1.211521, -3.936778,-1.312944, -1.285713),
cue = "G",
cue_range = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000),
log= "log10",
rand_df = x)},
mc.cores = 8)
# RBC
mc_R.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(7.0976026,  30.1295151, -28.0565613,  -0.2788713),
cue = "R",
cue_range = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000),
log= "none",
rand_df = x)},
mc.cores = 8)
mc_R_log.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(48.70772, 105.18882, -81.80625, -44.60051),
cue = "R",
cue_range = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000),
log= "log10",
rand_df = x)},
mc.cores = 8)
# Asexual iRBC
mclapply(posterior.ls[1:8], function(x){
mc_single(par = c(0.1135384,  -39.0585154, 1941.9082813,  119.8228980),
cue = "I",
cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
log= "none",
rand_df = x)},
mc.cores = 8)
mclapply(posterior.ls, function(x){
mc_single(par = c(5.463558,   2.383948, -17.757281,   4.571835),
cue = "I",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)},
mc.cores = 8)
length(posterior.ls)
posterior
mc_I_log.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(5.463558,   2.383948, -17.757281,   4.571835),
cue = "I",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)},
mc.cores = 8)
mc_all
lapply(posterior.ls[1:5], function(x){
mc_all(par = c(5.463558,   2.383948, -17.757281,   4.571835),
cue = "I",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)})
posterior.ls[[1]]
posterior.ls[1:5]
lapply(posterior.ls[[1:5]], function(x){
mc_all(par = c(5.463558,   2.383948, -17.757281,   4.571835),
cue = "I",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)})
posterior.ls[1:5]
lapply(posterior.ls[1:5], function(x){
mc_all(par = c(5.463558,   2.383948, -17.757281,   4.571835),
cue = "I",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)})
class(posterior.ls[[1]])
posterior
class(posterior.ls[[2]])
posterior.ls[[2]]
posterior
posterior.ls[[1.5]]
posterior.ls[1.5]
posterior.ls[1,5]
posterior.ls[1,5]
posterior.ls[1:5]
lapply(posterior.ls[1:5], function(x){
mc_all(par = c(5.463558,   2.383948, -17.757281,   4.571835),
cue = "I",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)})
# import in posterior distribution. Note that id = 1 is the reference!
posterior <- utils::read.csv(here("code_repository/data/posterior.csv"))
# get list of dataframes split by row
posterior.ls <- split(posterior, seq(nrow(posterior)))
mc_all(par = c(5.463558,   2.383948, -17.757281,   4.571835),
cue = "I",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)})
lapply(posterior.ls[1:5], function(x){
mc_all(par = c(5.463558,   2.383948, -17.757281,   4.571835),
cue = "I",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)})
source(here("code_repository/mc_all.R"))
source(here("code_repository/functions/mc_all.R"))
source(here("code_repository/functions/mc_all.R"))
mc_all(par = c(5.463558,   2.383948, -17.757281,   4.571835),
cue = "I",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)})
lapply(posterior.ls[1:5], function(x){
mc_all(par = c(5.463558,   2.383948, -17.757281,   4.571835),
cue = "I",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)})
install_arrow()
mc_all(par = c(5.463558,   2.383948, -17.757281,   4.571835),
cue = "I",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)})
lapply(posterior.ls[1:5], function(x){
mc_all(par = c(5.463558,   2.383948, -17.757281,   4.571835),
cue = "I",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)})
