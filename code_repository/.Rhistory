id, id_b, fitness_lc = fitness,
par1_lc = par1, par2_lc = par2, par3_lc = par3, par4_lc = par4, par5_lc = par5, par6_lc = par6,
par7_lc = par7, par8_lc = par8, par9_lc = par9), by = c("id", "id_b")
) %>% ## rename columns and join global and local optimization fitness dataframes
mutate(
fitness = ifelse(fitness_glb > fitness_lc, fitness_glb, fitness_lc),
par1 = ifelse(fitness_glb > fitness_lc, par1_glb, par1_lc),
par2 = ifelse(fitness_glb > fitness_lc, par2_glb, par2_lc),
par3 = ifelse(fitness_glb > fitness_lc, par3_glb, par3_lc),
par4 = ifelse(fitness_glb > fitness_lc, par4_glb, par4_lc),
par5 = ifelse(fitness_glb > fitness_lc, par5_glb, par5_lc),
par6 = ifelse(fitness_glb > fitness_lc, par6_glb, par6_lc),
par7 = ifelse(fitness_glb > fitness_lc, par7_glb, par7_lc),
par8 = ifelse(fitness_glb > fitness_lc, par8_glb, par8_lc),
par9 = ifelse(fitness_glb > fitness_lc, par9_glb, par9_lc)
) ## the columns are assigned based on which strategy produced the highest fitness
## write csv
write.csv(dual_cue_f_final.df, here("code_repository/data/dual_cue_fitness_final.csv"))
## write csv
dual_cue_f_final.df
dual_cue_f_final.df %>%
select(id, id_b, label, label_b, fitness_dual = fitness) %>%
left_join(select(si_opt.df, id, fitness_si = fitness_20), by = "id") %>% ## get fitness of single cue model based on first cue
left_join(select(si_opt.df, id_b = id, fitness_si_b = fitness_20), by = "id_b") %>%  ## get fitness of single cue model based on second cue
mutate(fitness_si_final = ifelse(fitness_si > fitness_si_b, fitness_si, fitness_si_b),
label_comb = paste(label, "&", label_b))
dual_si_fitness.df <- dual_cue_f_final.df %>%
select(id, id_b, label, label_b, fitness_dual = fitness) %>%
left_join(select(si_opt.df, id, fitness_si = fitness_20), by = "id") %>% ## get fitness of single cue model based on first cue
left_join(select(si_opt.df, id_b = id, fitness_si_b = fitness_20), by = "id_b") %>%  ## get fitness of single cue model based on second cue
mutate(fitness_si_final = ifelse(fitness_si > fitness_si_b, fitness_si, fitness_si_b),
label_comb = paste(label, "&", label_b)) ## select the highest single cue model fitness
dual_fitness.pl <- ggplot(dual_si_fitness.df) +
geom_segment(aes(y = fct_reorder(label_comb, fitness_dual), yend = fct_reorder(label_comb, fitness_dual), x = fitness_dual, xend = fitness_si_final)) + ## line segment connecting the cue values
geom_point(aes(y = fct_reorder(label_comb, fitness_dual), x = fitness_dual, color = "Dual cue", shape = "Dual cue"),
size = 2.5) + ## dual cue fitness
geom_point(aes(y = fct_reorder(label_comb, fitness_dual), x = fitness_si_final, color = "Best single cue", shape = "Best single cue"), size = 2.5) + ## best single cue fitness
scale_color_manual(values=c("#fc8d59", "#4575b4")) +
geom_vline(xintercept = 9.883602, linetype = "dashed") + ## ideal fitness value based on time
labs(x = "Fitness", y = "Dual cue combinations", colour = "Legend", shape = "Legend") +
theme_classic() +
theme(legend.position = "top")
ggplot(dual_si_fitness.df) +
geom_segment(aes(y = fct_reorder(label_comb, fitness_dual), yend = fct_reorder(label_comb, fitness_dual), x = fitness_dual, xend = fitness_si_final)) + ## line segment connecting the cue values
geom_point(aes(y = fct_reorder(label_comb, fitness_dual), x = fitness_dual, color = "Dual cue", shape = "Dual cue"),
size = 2.5) + ## dual cue fitness
geom_point(aes(y = fct_reorder(label_comb, fitness_dual), x = fitness_si_final, color = "Best single cue", shape = "Best single cue"), size = 2.5) + ## best single cue fitness
scale_color_manual(values=c("#fc8d59", "#4575b4")) +
geom_vline(xintercept = 9.883602, linetype = "dashed") + ## ideal fitness value based on time
labs(x = "Fitness", y = "Dual cue combinations", colour = "Legend", shape = "Legend") +
theme_classic() +
theme(legend.position = "top")
## best dual cue model: I log and R log
Rlog_Ilog.cr <- chabaudi_si_clean(
parameters_cr = c(4.446192033,	10.97518275,	1.38762817,	23.3059254,	-3.452052371,	-18.0070692,	39.66614226,	-3.545193141,	18.78350799),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 1e-3),
cue_range =  seq(6, 7, by = 1/500),
cue_range_b = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/500),
cue = "R",
cue_b = "I",
log_cue = "log10",
log_cue_b = "log10",
solver = "vode",
dyn = T
)
## when time is used as a cue (9 parameters). chabaudi_si_clean_high is simply a variation of chabaudi_si_clean that makes a more flexible spline!
time_high.cr <- chabaudi_si_clean_high(
parameters_cr = c(9.154314,  -7.570829, -22.506638 ,  3.382405 ,-13.453519 ,-17.011485  , 3.678181, -12.851895 ,-26.115158),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 1e-3),
cue_range =  seq(0, 20, by = 1e-3),
cue = "t",
solver = "vode",
dyn = T)
## when asexual iRBC is used as a cue (high flexibility)
I_high.cr <- chabaudi_si_clean_high(
parameters_cr = c(1.296675,  3.544034 , 4.907484,  2.174249, -3.238309 ,-5.181614 ,-1.645072 , 1.834302 , 1.581011),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 1e-3),
cue_range =  seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
cue = "I",
log_cue = "log10",
solver = "vode",
dyn = T)
## when RBC is used as cue (high flexibility)
R_high.cr <- chabaudi_si_clean_high(
parameters_cr = c(5.0340348 ,  0.5846168 ,  0.3749648 ,  0.6842673  , 2.4748107 , 10.9036034 , 16.8246316, -24.8690971 ,1.8007238),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 1e-3),
cue_range =  seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000),
cue = "R",
log_cue = "log10",
solver = "vode",
dyn = T)
# process
I_high.cr_p <- I_high.cr %>% filter(variable == "cr") %>% mutate(label_new = "I log10 (df=9)") %>% select(-variable)
R_high.cr_p <- R_high.cr %>% filter(variable == "cr") %>% mutate(label_new = "R log10 (df=9)") %>% select(-variable)
time_high.cr_p <- time_high.cr %>% filter(variable == "cr") %>% mutate(label_new = "Time (df=9)") %>% select(-variable)
Rlog_Ilog.cr_p <- Rlog_Ilog.cr %>% filter(variable == "cr") %>% mutate(label_new = "R log10 & I log10\n(df=9)") %>% select(-variable)
## combine
dual_selected_cr.df <- rbind(I_high.cr_p, R_high.cr_p, time_high.cr_p, Rlog_Ilog.cr_p)
write_parquet(dual_selected_cr.df, here("code_repository/data/dual_selected_cr.parquet"))
gplot() +
geom_line(data = dual_selected_cr.df, aes(color = label_new, x = time, y = value), size = 1) +
geom_point(data = dual_selected_cr.df %>% filter(time%%1 == 0), aes(color = label_new, x = time, y = value, shape = label_new), size = 3) +
labs(x = "Time (days)", y = "Conversion rate", color = "Cue(s)", shape = "Cue(s)") +
xlim(0, 20) +
scale_color_manual(values = c("#fc8d59","#fdcb44","black", "#4575b4")) +
theme_classic() +
theme(legend.position="right",
plot.margin = margin(t = 40, r = 0, b = 0, l = 0, unit = "pt")) +
guides(color = guide_legend(nrow = 4, byrow = TRUE))
ggplot() +
geom_line(data = dual_selected_cr.df, aes(color = label_new, x = time, y = value), size = 1) +
geom_point(data = dual_selected_cr.df %>% filter(time%%1 == 0), aes(color = label_new, x = time, y = value, shape = label_new), size = 3) +
labs(x = "Time (days)", y = "Conversion rate", color = "Cue(s)", shape = "Cue(s)") +
xlim(0, 20) +
scale_color_manual(values = c("#fc8d59","#fdcb44","black", "#4575b4")) +
theme_classic() +
theme(legend.position="right",
plot.margin = margin(t = 40, r = 0, b = 0, l = 0, unit = "pt")) +
guides(color = guide_legend(nrow = 4, byrow = TRUE))
dual_selected_cr.pl <- ggplot() +
geom_line(data = dual_selected_cr.df, aes(color = label_new, x = time, y = value), size = 1) +
geom_point(data = dual_selected_cr.df %>% filter(time%%1 == 0), aes(color = label_new, x = time, y = value, shape = label_new), size = 3) +
labs(x = "Time (days)", y = "Conversion rate", color = "Cue(s)", shape = "Cue(s)") +
xlim(0, 20) +
scale_color_manual(values = c("#fc8d59","#fdcb44","black", "#4575b4")) +
theme_classic() +
theme(legend.position="right",
plot.margin = margin(t = 40, r = 0, b = 0, l = 0, unit = "pt")) +
guides(color = guide_legend(nrow = 4, byrow = TRUE))
# make heatmap data.frame
Rlog_Ilog.hm <- par_to_hm_te(par = c(4.446192033,	10.97518275,	1.38762817,	23.3059254,	-3.452052371,	-18.0070692,	39.66614226,	-3.545193141,	18.78350799),
cue_range = seq(6,	7, length.out = 500),
cue_range_b = seq(0,	6.77815125, length.out = 500))
# process dynamics
Rlog_Ilog.dyn <- Rlog_Ilog.cr %>%
tidyr::pivot_wider(names_from = variable, values_from = value) %>%
mutate(log_R = log10(R),
log_I = log10(I))
# process dynamics
dual_selected_cr.df
# process dynamics
dual_selected_cr.df %>% filter(label_new == "R log + I log")
unique(dual_selected_cr.df$label_new)
# process dynamics
dual_selected_cr.df %>% filter(label_new == "R log10 & I log10\n(df=9)")
# process dynamics
Rlog_Ilog.dyn <- dual_selected_cr.df %>%
filter(label_new == "R log10 & I log10\n(df=9)") %>%
tidyr::pivot_wider(names_from = variable, values_from = value) %>%
mutate(log_R = log10(R),
log_I = log10(I))
## best dual cue model: I log and R log
Rlog_Ilog.cr <- chabaudi_si_clean(
parameters_cr = c(4.446192033,	10.97518275,	1.38762817,	23.3059254,	-3.452052371,	-18.0070692,	39.66614226,	-3.545193141,	18.78350799),
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, by = 1e-3),
cue_range =  seq(6, 7, by = 1/500),
cue_range_b = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/500),
cue = "R",
cue_b = "I",
log_cue = "log10",
log_cue_b = "log10",
solver = "vode",
dyn = T
)
# make heatmap data.frame
Rlog_Ilog.hm <- par_to_hm_te(par = c(4.446192033,	10.97518275,	1.38762817,	23.3059254,	-3.452052371,	-18.0070692,	39.66614226,	-3.545193141,	18.78350799),
cue_range = seq(6,	7, length.out = 500),
cue_range_b = seq(0,	6.77815125, length.out = 500))
# process dynamics
Rlog_Ilog.dyn <- Rlog_Ilog.cr %>%
tidyr::pivot_wider(names_from = variable, values_from = value) %>%
mutate(log_R = log10(R),
log_I = log10(I))
Rlog_Ilog_rn.pl <- ggplot() +
geom_raster(data = Rlog_Ilog.hm, aes(x = cue_range_b, y = cue_range, fill = cr)) +
scale_fill_viridis_c() +
geom_path(data = Rlog_Ilog.dyn, aes(x = log_I, y = log_R), color = "white", arrow = arrow(angle = 30, length = unit(0.1, "inches"))) +
geom_point(data = Rlog_Ilog.dyn %>% filter(row_number() %% 1000 == 1 & time <= 20), aes(x = log_I, y = log_R), color = "white") +
xlim(0.99*min(hablar::s(Rlog_Ilog.dyn$log_I), na.rm = T), 1.01* max(hablar::s(Rlog_Ilog.dyn$log_I), na.rm = T)) +
ylim(0.99*min(hablar::s(Rlog_Ilog.dyn$log_R), na.rm = T),1.01* max(hablar::s(Rlog_Ilog.dyn$log_R), na.rm = T)) +
labs(y = "RBC log10", x = "Asexual iRBC log10", fill = "Conversion\nrate") +
theme_classic() +
theme(legend.position = "right")
# assemble panel B and C
dual_main.BC <- ggarrange(dual_selected_cr.pl, Rlog_Ilog_rn.pl, align = "v", ncol = 1, labels = c("B", "C"))
# assemble panel A
ggarrange(dual_fitness.pl, dual_main.BC, ncol = 2, labels = c("A", ""), widths = c(1.1,1))
ggsave(here("code_repository/figures/dual_main_intermediate.tiff"), units = "px", width = 2250, height = 1400, scale = 1.3, dpi=300,  bg = "white")
dual_cue_dyn <- function(df){
## process cues
cue <- df$cue
cue_b <- df$cue_b
## process log
log <- ifelse(str_detect(df$id, "log"), "log10", "none")
log_b <- ifelse(str_detect(df$id_b, "log"), "log10", "none")
# process cue_range. ensure that both cue ranges are of the same length
cue_range <- seq(df$low, df$high, length.out = 500)
cue_range_b <- seq(df$low_b, df$high_b, length.out = 500)
# get parameter set
par <- c(df$par1, df$par2, df$par3, df$par4, df$par5, df$par6, df$par7, df$par8, df$par9)
# simulate dynamics
dyn <- chabaudi_si_clean(
parameters_cr = par,
immunity = "tsukushi",
parameters = parameters_tsukushi,
time_range = seq(0, 20, 0.01),
cue = cue,
cue_b = cue_b,
cue_range = cue_range,
cue_range_b = cue_range_b,
log_cue = log,
log_cue_b = log_b,
solver = "vode",
gam = "te",
dyn = T)
# return
dyn2 <- cbind(id = df$id, id_b = df$id_b,
label = df$label, label_b = df$label_b,
cue = cue, cue_b = cue_b, dyn)
write_parquet(dyn2, here(paste0("code_repository/data/dual_cue_dyn/", df$id, "_", df$id_b, ".parquet")))
}
## For the dual cue fitness dataframe, add the cue range for each individual cue
dual_cue_f_final.df_p <- dual_cue_f_final.df %>%
left_join(select(cue_range_si_alt.df, id, cue, low, high), by = "id") %>%
left_join(select(cue_range_si_alt.df, id_b = id, cue_b = cue, low_b = low, high_b = high), by = "id_b")
## Split dataframes
dual_cue_f_final.ls <- split(dual_cue_f_final.df_p, seq(nrow(dual_cue_f_final.df_p)))
## Run function
mclapply(dual_cue_f_final.ls, dual_cue_dyn, mc.cores = 6)
## Concat all files
dual_cue_dyn.ls <- list.files(path = here("code_repository/data/dual_cue_dyn"), pattern = "*.parquet", full.names = T)
dual_cue_dyn.df <- do.call(rbind, lapply(dual_cue_dyn.ls, read_parquet))
write_parquet(dual_cue_dyn.df, here("code_repository/data/dual_cue_dyn.parquet"))
## filter out only conversion rate and attach fitness values
dual_cue_cr.df <- dual_cue_dyn.df %>%
filter(variable == "cr") %>%
left_join(select(dual_cue_f_final.df, id, id_b, fitness), by = c("id", "id_b")) %>%
mutate(label_comb = paste(label, "&", label_b))
## Sanity check that the dynamics produced the same fitness as the optimized values. Yes!
dual_cue_dyn.df %>%
filter(variable == "tau_cum") %>%
filter(time == 20) %>%
distinct(id, id_b, value) %>%
left_join(select(dual_cue_f_final.df, id, id_b, fitness), by = c("id", "id_b")) %>%
mutate(diff = value-fitness)
ggplot(data = dual_cue_cr.df, aes(x = time, y = fct_reorder(label_comb, fitness), fill = value)) +
geom_raster() +
scale_fill_viridis_c() +
xlim(1, 20) +
labs(x = "Time (days)", y = "Dual cue combination", fill = "Conversion rate") +
theme_classic()
ggsave(here("code_repository/figures/dual_cue_cr.tiff"), units = "px", width = 2000, height = 1500, dpi=300,  bg = "white")
dual_cue_f_final.df
dual_cue_f_final.df
ggplot(data = dual_cue_cr.df, aes(x = time, y = fct_reorder(label_comb, fitness), fill = value)) +
geom_raster() +
scale_fill_viridis_c() +
xlim(1, 20) +
labs(x = "Time (days)", y = "Dual cue combination", fill = "Conversion rate") +
theme_classic()
ggsave(here("code_repository/figures/dual_cue_cr.tiff"), units = "px", width = 2000, height = 1500, dpi=300,  bg = "white")
names(exp_ss.df) <- c("X", "Day", "Mouse", "RBC", "iRBC", "Gametocyte", "Dose", "Strain", "Study", "Study_strain", "id")
## prepare a list of variable combinations we want to plot
exp_var.comb <- tidyr::expand_grid(x = c("RBC", "iRBC", "Gametocyte"),
y = c("RBC", "iRBC", "Gametocyte")) %>% ## get all pairwise combinations of variables
filter(x != y) %>% ## remove incidences where the 2 variables are the same
mutate(tmp = paste0(pmin(x, y), pmax(x, y))) %>% ## eliminate same variable but different order
slice_head(n = 1, by = tmp) %>%
select(-tmp)
## x and y axis are not logged!
exp_xy.pl_ls <- map2(exp_var.comb$x, exp_var.comb$y, ~ {
x_col <- .x
y_col <- .y
ggplot(exp_ss.df, aes_string(x = x_col, y = y_col)) +
geom_path(aes(colour = Day, group = id), arrow = arrow(type = "closed", angle = 10, length = unit(0, "inches"))) +
theme_classic() +
scale_color_viridis_c(limits = c(3, 21)) +
labs(color = "Days post-infection")  +
scale_y_continuous(labels = function(x) format(x, scientific = TRUE)) +
scale_x_continuous(labels = label_scientific(digits = 1))
}
)
## x-axis is logged
exp_xlogy.pl_ls <- map2(exp_var.comb$x, exp_var.comb$y, ~ {
x_col <- .x
y_col <- .y
ggplot(exp_ss.df, aes_string(x = sprintf("log10(%s)", x_col), y = y_col)) +
geom_path(aes(colour = Day, group = id), arrow = arrow(type = "closed", angle = 10, length = unit(0, "inches"))) +
theme_classic() +
scale_color_viridis_c(limits = c(3, 21)) +
labs(color = "Days post-infection", x = paste(x_col, "log"))  +
scale_y_continuous(labels = function(x) format(x, scientific = TRUE))
}
)
## y-axis logged
exp_xylog.pl_ls <- map2(exp_var.comb$x, exp_var.comb$y, ~ {
x_col <- .x
y_col <- .y
ggplot(exp_ss.df, aes_string(x = x_col, y = sprintf("log10(%s)", y_col))) +
geom_path(aes(colour = Day, group = id), arrow = arrow(type = "closed", angle = 10, length = unit(0, "inches"))) +
theme_classic() +
scale_color_viridis_c(limits = c(3, 21)) +
labs(color = "Days post-infection", y = paste(y_col, "log"))   +
scale_x_continuous(labels = label_scientific(digits = 1))
}
)
## both x and y axis is logged
exp_xlogylog.pl_ls <- map2(exp_var.comb$x, exp_var.comb$y, ~ {
x_col <- .x
y_col <- .y
ggplot(exp_ss.df, aes_string(x = sprintf("log10(%s)", x_col), y = sprintf("log10(%s)", y_col))) +
geom_path(aes(colour = Day, group = id), arrow = arrow(type = "closed", angle = 10, length = unit(0, "inches"))) +
theme_classic() +
scale_color_viridis_c(limits = c(3, 21)) +
labs(color = "Days post-infection", x = paste(x_col, "log"), y = paste(y_col, "log"))
}
)
## plot together
ggarrange(plotlist = c(exp_xy.pl_ls, exp_xlogy.pl_ls, exp_xylog.pl_ls, exp_xlogylog.pl_ls),
common.legend = T, align = "hv")
ggsave(here("code_repository/figures/exp_disease-curve.tiff"), units = "px", width = 2250, height = 1500, scale = 1.4, dpi=300,  bg = "white")
## list apply all dataframes
cue_cue_rn_pl.ls <- lapply(dual_cue_rn.ls,
function(x){
## get names of columns used in the x and y axis
axis_cols <- setdiff(names(x), c("time", "id", "id_b", "cr"))
## ggplot
ggplot() +
geom_path(data = x, aes_string(x = axis_cols[[1]], y = axis_cols[[2]], color = "cr"),
arrow = arrow(length = unit(c(rep(0, nrow(x) - 2), 0.25), "inches")),
size = 1.5) +
geom_point(data = x %>% filter(time %% 1 == 0),
aes_string(x = axis_cols[[1]], y = axis_cols[[2]]), size = 1.5, shape = 1) +
theme_classic() +
scale_color_viridis_c(limits = c(0, 1)) +
labs(color = "Conversion rate", x = gsub("_", " ", axis_cols[[1]]), y = gsub("_", " ", axis_cols[[2]])) +
scale_x_continuous(labels = label_scientific(digits = 1)) +
scale_y_continuous(labels = label_scientific(digits = 1))
})
## split dual dynamics dataframe into list grouped by the dual cues
dual_cue_dyn.ls <- dual_cue_dyn.df %>% group_split(id, id_b)
## run function across list
dual_cue_rn.ls <- mclapply(dual_cue_dyn.ls, get_dual_rn, mc.cores = 6)
## sanity checks that we are actually summing iRBCs. Rings out
max(dual_cue_rn.ls[[2]]$Total_iRBC)
get_dual_rn <- function(df){
## assign the two cues
cue <- unique(df$cue)
cue_b <- unique(df$cue_b)
## assign log status
log <- ifelse(str_detect(unique(df$id), "log"), "log", "none")
log_b <- ifelse(str_detect(unique(df$id_b), "log"), "log", "none")
## assign which cues are going to be logged
if(log == "log" & log_b == "none"){logged_cue <- cue}
if(log == "none" & log_b == "log"){logged_cue <- cue_b}
if(log == "log" & log_b == "log"){logged_cue <- c(cue, cue_b)}
if(log == "none" & log_b == "none"){logged_cue <- c()}
## keep variables that corresponds to the cue used
### for dataframes that does not involve combined variables such as I+Ig
if(isTRUE(str_detect(cue, "\\+", negate = T)) & isTRUE(str_detect(cue_b, "\\+", negate = T))){
df_f <- df %>%
filter(variable %in% c(cue, cue_b, "cr")) %>%
mutate(value = case_when(
variable %in% logged_cue ~ log10(value),
TRUE ~ value
)) %>% ## log transform values only when they match with the logged cue list
filter(value >= 0) ## filter out values <0, these happen due to stiffness of models but are not relevant
} else{
### assign both cues to a list
cue_ls <- c(cue, cue_b)
### pick the cue that has the "+" sign
combined_cue <- cue_ls[grepl("\\+", cue_ls)]
non_combined_cue <- cue_ls[!grepl("\\+", cue_ls)] ### this is the none combined cue
### unlist the cues
cue_unlist <- unlist(str_split(combined_cue, "\\+"))
### get filtered dataset containing only non-combine cue
df_f1 <- df %>%
filter(variable %in% c(non_combined_cue, "cr"))
### get filtered dataset containing combined cue. These will be summed up and bound back to the previous
df_f2 <- df %>%
filter(variable %in% cue_unlist) %>% ## keep only variables that we will combine
group_by(time) %>% ## for each time point, group the variables
mutate(value = sum(value, na.rm = T),
variable = combined_cue) %>% ## recalculate the value as sum of the values and reassign variable!
distinct(time, .keep_all = T) ## note that because we are mutating we must dedeuplicate the records
#### combine the two and log transform if necessary
df_f <- rbind(df_f1, df_f2) %>%
mutate(value = ifelse(variable %in% logged_cue, log10(value), value)) %>% ## log transform values only when they match with the logged cue list
filter(value >= 0)
}
## Convert dataframes wider such that the different variables have their own columns
df_fp <- df_f %>%
mutate(variable_id = ifelse(variable == cue, paste0(variable, "_", log), paste0(variable, "_", log_b))) %>%  ### assign a unique variable id that could later be used to assign labels
left_join(select(ez_label, id, long_label), by = c("variable_id" = "id")) %>%
mutate(long_label = ifelse(variable == "cr", "cr", long_label)) %>% ## manually add cr
mutate(long_label = gsub(" ", "_", long_label)) %>%  ## convert spaces to _ for plotting
pivot_wider(names_from = long_label, values_from = value, id_cols = c(time, id, id_b)) %>%
filter(time >= 1) %>% ## filter out day 0->1 because all cr = 0 before that
arrange(time) ## this is needed to prevent geom_path from joining the first and last data point
## assign NAs (meaning no stuff is produced yet to 0)
df_fp[is.na(df_fp)] <- 0
return(df_fp)
}
## split dual dynamics dataframe into list grouped by the dual cues
dual_cue_dyn.ls <- dual_cue_dyn.df %>% group_split(id, id_b)
## run function across list
dual_cue_rn.ls <- mclapply(dual_cue_dyn.ls, get_dual_rn, mc.cores = 6)
## sanity checks that we are actually summing iRBCs. Rings out
max(dual_cue_rn.ls[[2]]$Total_iRBC)
max(dual_cue_rn.ls[[4]]$Asexual_iRBC)
max(dual_cue_rn.ls[[6]]$Sexual_iRBC)
max(dual_cue_rn.ls[[10]]$Total_iRBC)
max(dual_cue_rn.ls[[12]]$Asexual_iRBC)
max(dual_cue_rn.ls[[14]]$Sexual_iRBC)
## list apply all dataframes
cue_cue_rn_pl.ls <- lapply(dual_cue_rn.ls,
function(x){
## get names of columns used in the x and y axis
axis_cols <- setdiff(names(x), c("time", "id", "id_b", "cr"))
## ggplot
ggplot() +
geom_path(data = x, aes_string(x = axis_cols[[1]], y = axis_cols[[2]], color = "cr"),
arrow = arrow(length = unit(c(rep(0, nrow(x) - 2), 0.25), "inches")),
size = 1.5) +
geom_point(data = x %>% filter(time %% 1 == 0),
aes_string(x = axis_cols[[1]], y = axis_cols[[2]]), size = 1.5, shape = 1) +
theme_classic() +
scale_color_viridis_c(limits = c(0, 1)) +
labs(color = "Conversion rate", x = gsub("_", " ", axis_cols[[1]]), y = gsub("_", " ", axis_cols[[2]])) +
scale_x_continuous(labels = label_scientific(digits = 1)) +
scale_y_continuous(labels = label_scientific(digits = 1))
})
## arrange together
cue_cue_rn.pl <- ggarrange(plotlist = cue_cue_rn_pl.ls, ncol = 5, nrow = 8, common.legend = T, align = "hv")
ggsave(here("code_repository/figures/sim_disease-curve.tiff"), units = "px", width = 2250, height = 2500, scale = 2, dpi=300,  bg = "white")
ggplot(data = dual_cue_cr.df, aes(x = time, y = fct_reorder(label_comb, fitness), fill = value)) +
geom_raster() +
scale_fill_viridis_c() +
xlim(1, 20) +
labs(x = "Time (days)", y = "Dual cue combination", fill = "Conversion rate") +
theme_classic()
ggsave(here("code_repository/figures/dual_cue_cr.tiff"), units = "px", width = 2000, height = 1500, dpi=300,  bg = "white")
## import in the posterior datasbase
posterior <- utils::read.csv(here("code_repository/data/posterior.csv"))
## move the burst (decision attributes to last column)
posterior <- posterior %>% select(-burst, burst)
## make into decision table. Here we are going to make burst size a decision attributes (a class that we definitely wants representation)
posterior.rs <- SF.asDecisionTable(dataset = posterior[,-1], decision.attr = 6)
## apply instance reduction with standard parameters
posterior.rd <- IS.FRIS.FRST(posterior.rs)
## get representative subset
posterior.rep <- SF.applyDecTable(posterior.rs, posterior.rd)
## write
write.csv(posterior.rep, here("code_repository/data/posterior_rep.csv"))
posterior.rep
posterior.rep
si_dyn.df
si_dyn.df %>% filter(id == "time")
## get the perfect dynamic (time-based)
time_dym.df <- si_dyn.df %>% filter(id == "time")
time_dym.df
time_dym.df %>% filter(variable == "R")
time_dym.df
time_dym.df %>% pivot_wider(id_cols = time)
time_dym.df %>% pivot_wider(id_cols = time, values_from = value, names_from = variable)
## get the perfect dynamic (time-based)
time_dyn.df <- si_dyn.df %>% filter(id == "time")
## convert to wide
time_dyn.wide <- time_dyn.df %>% pivot_wider(id_cols = time, values_from = value, names_from = variable)
time_dyn.wide
si_rn.df
##
time_dyn.wide
unique(time_dyn.wide$I)
par_to_df(par = c(0.1135384,	-39.0585154,	1941.908281,	119.822898), cue_range = unique(time_dyn.wide$I))
unique(time_dyn.wide$I)
arrange(unique(time_dyn.wide$I))
sort(unique(time_dyn.wide$I))
par_to_df(par = c(0.1135384,	-39.0585154,	1941.908281,	119.822898), cue_range = sort(unique(time_dyn.wide$I)))
par_to_df(par = c(0.1135384,	-39.0585154,	1941.908281,	119.822898), cue_range = seq(0,100,1))
par_to_df(par = c(0.1135384,-39.0585154,1941.908281,119.822898), cue_range = seq(1,100,1))
library(dplyr)
library(ggplot2)
library(forcats)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
library(stringr)
library(parallel)
library(ggpubr)
library(scales)
library(bayestestR)
library(purrr)
library(tidyr)
library(splines2)
install.packages("splines2")
install.packages("splines2")
library(splines2)
