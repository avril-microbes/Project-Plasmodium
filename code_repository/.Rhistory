cue = "Ig",
cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
log= "none",
rand_df = x)},
mc.cores = 8)
mc_Ig_log.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(1.74633, -1.78582, -5.52834, 1.57344 ),
cue = "Ig",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)},
mc.cores = 8)
# all iRBC
mc_I_Ig.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(0.3159297,  -46.1104558, 1250.7529081,   -6.1982093),
cue = "I+Ig",
cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
log= "none",
rand_df = x)},
mc.cores = 8)
mc_I_Ig_log.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(3.594042,   4.157744, -13.530672,   2.599905),
cue = "I+Ig",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)},
mc.cores = 8)
# gametocyte
MC_G.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(0.04061288,   -9.31445958,   74.13015506, -431.59843638),
cue = "G",
cue_range = seq(0, 6*(10^4), (6*(10^4))/5000),
log= "none",
rand_df = x)},
mc.cores = 8)
mc_G_log.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(1.211521, -3.936778,-1.312944, -1.285713),
cue = "G",
cue_range = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000),
log= "log10",
rand_df = x)},
mc.cores = 8)
# RBC
mc_R.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(7.0976026,  30.1295151, -28.0565613,  -0.2788713),
cue = "R",
cue_range = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000),
log= "none",
rand_df = x)},
mc.cores = 8)
mc_R_log.res <- mclapply(posterior.ls, function(x){
mc_all(par = c(48.70772, 105.18882, -81.80625, -44.60051),
cue = "R",
cue_range = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000),
log= "log10",
rand_df = x)},
mc.cores = 8)
# Asexual iRBC
mclapply(posterior.ls, function(x){
mc_single(par = c(0.1135384,  -39.0585154, 1941.9082813,  119.8228980),
cue = "I",
cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
log= "none",
rand_df = x)},
mc.cores = 8)
mclapply(posterior.ls, function(x){
mc_single(par = c(5.463558,   2.383948, -17.757281,   4.571835),
cue = "I",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)},
mc.cores = 8)
# Sexual iRBC
mclapply(posterior.ls, function(x){
mc_single(par = c(0.05234791,  -46.03368629, 1897.61313455,   70.57689145),
cue = "Ig",
cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
log= "none",
rand_df = x)},
mc.cores = 8)
mclapply(posterior.ls, function(x){
mc_single(par = c(1.74633, -1.78582, -5.52834, 1.57344 ),
cue = "Ig",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)},
mc.cores = 8)
# all iRBC
mclapply(posterior.ls, function(x){
mc_single(par = c(0.3159297,  -46.1104558, 1250.7529081,   -6.1982093),
cue = "I+Ig",
cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
log= "none",
rand_df = x)},
mc.cores = 8)
mclapply(posterior.ls, function(x){
mc_single(par = c(3.594042,   4.157744, -13.530672,   2.599905),
cue = "I+Ig",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
log= "log10",
rand_df = x)},
mc.cores = 8)
# for single infections
source(here("code_repository/functions/opt_local.R"))
source(here("code_repository/functions/opt_global.R"))
source(here("code_repository/functions/chabaudi_si_clean.R"))
source(here("code_repository/functions/validate_si.R"))
# for co-infections
source(here("code_repository/functions/co_infection_opt_alt.R"))
source(here("code_repository/functions/co_infection_opt_do.R"))
source(here("code_repository/functions/chabaudi_ci_clean.R"))
source(here("code_repository/functions/validate_ci.R"))
# for dual cue
source(here("code_repository/functions/dual_cue_opt.R"))
# for static competition
source(here("code_repository/functions/ci_comp_static.R"))
# for invasive competition
source(here("code_repository/functions/ci_invasion_analysis.R"))
# for partitioning analysis
source(here("code_repository/functions/partition_si.R"))
# for semi-stochastic single infection model
source(here("code_repository/functions/mc_all.R"))
source(here("code_repository/functions/mc_single.R"))
# I
I_glb.op <- opt_global(
cue = "I",
log = "none",
cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))
# parameters used to simulate malaria intrahost  dynamics
parameters_tsukushi <- c(R1 = 8.89*10^6,
lambda = 3.7*10^5,
mu = 0.025,
p = 8*10^-6,
alpha = 1,
alphag = 2,
beta = 5.721,
mum = 48,
mug = 4,
I0 = 43.85965,
Ig0 = 0,
a = 150,
b = 100,
sp = 1,
psin = 16.69234,
psiw = 0.8431785,
phin = 0.03520591,
phiw = 550.842,
iota = 2.18*(10^6),
rho = 0.2627156)
# time range and time step at which the model will be simulated
time_range <- seq(0, 20, by = 1e-3)
time_range_l <- seq(0, 20, by = 1e-2)
# smallest fitness difference for co-infection optimization script to exit
limit <- 0.01
# different cue_range
I_range_none <- seq(0, 6*(10^6), by = (6*(10^6))/5000)
I_range_log <- seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000)
G_range_none <- seq(0, 6*(10^4), by = (6*(10^4))/5000)
G_range_log <- seq(0, log10(6*(10^4)), by = (log10(6*(10^4)))/5000)
# I
I_loc.op <- opt_local(par = rep(0.5, 4),
cue = "I",
log = "none",
cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))
# I
I_glb.op <- opt_global(
cue = "I",
log = "none",
cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))
stopCluster(cl)
# I
I_glb.op <- opt_global(
cue = "I",
log = "none",
cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))
install.packages("DEoptim")
install.packages("DEoptim")
library(dplyr)
library(ggplot2)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
library(parallel)
# for single infections
source(here("code_repository/functions/opt_local.R"))
source(here("code_repository/functions/opt_global.R"))
source(here("code_repository/functions/chabaudi_si_clean.R"))
source(here("code_repository/functions/validate_si.R"))
# for co-infections
source(here("code_repository/functions/co_infection_opt_alt.R"))
source(here("code_repository/functions/co_infection_opt_do.R"))
source(here("code_repository/functions/chabaudi_ci_clean.R"))
source(here("code_repository/functions/validate_ci.R"))
# for dual cue
source(here("code_repository/functions/dual_cue_opt.R"))
# for static competition
source(here("code_repository/functions/ci_comp_static.R"))
# for invasive competition
source(here("code_repository/functions/ci_invasion_analysis.R"))
# for partitioning analysis
source(here("code_repository/functions/partition_si.R"))
# for semi-stochastic single infection model
source(here("code_repository/functions/mc_all.R"))
source(here("code_repository/functions/mc_single.R"))
# Time (ideal case)
t_glb.op <- opt_global(
cue = "t",
log = "none",
cue_range = time_range)
# parameters used to simulate malaria intrahost  dynamics
parameters_tsukushi <- c(R1 = 8.89*10^6,
lambda = 3.7*10^5,
mu = 0.025,
p = 8*10^-6,
alpha = 1,
alphag = 2,
beta = 5.721,
mum = 48,
mug = 4,
I0 = 43.85965,
Ig0 = 0,
a = 150,
b = 100,
sp = 1,
psin = 16.69234,
psiw = 0.8431785,
phin = 0.03520591,
phiw = 550.842,
iota = 2.18*(10^6),
rho = 0.2627156)
# time range and time step at which the model will be simulated
time_range <- seq(0, 20, by = 1e-3)
# smallest fitness difference for co-infection optimization script to exit
limit <- 0.01
# different cue_range
I_range_none <- seq(0, 6*(10^6), by = (6*(10^6))/5000)
I_range_log <- seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000)
G_range_none <- seq(0, 6*(10^4), by = (6*(10^4))/5000)
G_range_log <- seq(0, log10(6*(10^4)), by = (log10(6*(10^4)))/5000)
# Time (ideal case)
t_glb.op <- opt_global(
cue = "t",
log = "none",
cue_range = time_range)
source(here("code_repository/functions/opt_global.R"))
# Time (ideal case)
t_glb.op <- opt_global(
cue = "t",
log = "none",
cue_range = time_range)
# I
I_glb.op <- opt_global(
cue = "I",
log = "none",
cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))
source(here("code_repository/functions/opt_global.R"))
# Time (ideal case)
t_glb.op <- opt_global(
cue = "t",
log = "none",
cue_range = time_range)
time_range
# Time (ideal case)
t_loc.op <- opt_local(par = c(4.553093,  -13.002437,    4.148638,  -11.930721),
cue = "t",
log = "none",
cue_range = time_range)
source(here("code_repository/functions/opt_global.R"))
# I
I_glb.op <- opt_global(
cue = "I",
log = "none",
cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))
# I logged
I_log_glb.op <- opt_global(
cue = "I",
log = "log10",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))
# Ig
Ig_glb.op <- opt_global(
cue = "Ig",
log = "none",
cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))
# Ig logged
Ig_log_glb.op <- opt_global(
cue = "Ig",
log = "log10",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))
# I + Ig
I_Ig_glb.op <- opt_global(
cue = "I+Ig",
log = "none",
cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))
# I+Ig logged
I_Ig_log_glb.op <- opt_global(
cue = "Ig+I",
log = "log10",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))
# I logged
I_log_glb.op <- opt_global(
cue = "I",
log = "log10",
cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))
# RBC
R_glb.op <- opt_global(
cue = "R",
log = "none",
cue_range = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000))
# RBC logged
R_glb_log.op <- opt_global(
cue = "R",
log = "log10",
cue_range = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000))
# G
G_glb.op <- opt_global(
cue = "G",
log = "none",
cue_range = seq(0, 6*(10^4), (6*(10^4))/5000))
# G logged
G_log_glb.op <- opt_global(
cue = "G",
log = "log10",
cue_range = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000))
4.553093  -13.002437    4.148638  -11.930721
I_glb.op
t_glb.op
I_glb.op
I_log_glb.op
Ig_glb.op
Ig_log_glb.op
I_Ig_glb.op
I_Ig_log_glb.op
I_log_glb.op
R_glb.op
R_glb_log.op
G_glb.op
G_log_glb.op
R_glb.op
R_glb_log.op
# Import in the list of single infection optimization results
si_opt.df2 <- read.csv(here("code_repository/data/si_opt.csv"))
# split into individual tables
si_opt.ls <- split(si_opt.df, seq(nrow(si_opt.df)))
# Import in the list of single infection optimization results
si_opt.df <- read.csv(here("code_repository/data/si_opt.csv"))
# split into individual tables
si_opt.ls <- split(si_opt.df, seq(nrow(si_opt.df)))
si_opt.ls
si_opt.ls[7:8]
source(here("code_repository/functions/validate_si.R"))
# cluster initialization. This will write the results to a data/si_validation folder
surveillance::plapply(si_opt.ls[7:8], validate_si)
# cluster initialization. This will write the results to a data/si_validation folder
surveillance::plapply(si_opt.ls[[7:8]], validate_si)
validate_si(si_opt.ls[[7]])
# Import in the list of single infection optimization results
si_opt.df <- read.csv(here("code_repository/data/si_opt.csv"))
# split into individual tables
si_opt.ls <- split(si_opt.df, seq(nrow(si_opt.df)))
si_opt.ls
library(dplyr)
library(ggplot2)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
library(parallel)
# for single infections
source(here("code_repository/functions/opt_local.R"))
source(here("code_repository/functions/opt_global.R"))
source(here("code_repository/functions/chabaudi_si_clean.R"))
source(here("code_repository/functions/validate_si.R"))
# for co-infections
source(here("code_repository/functions/co_infection_opt_alt.R"))
source(here("code_repository/functions/co_infection_opt_do.R"))
source(here("code_repository/functions/chabaudi_ci_clean.R"))
source(here("code_repository/functions/validate_ci.R"))
# for dual cue
source(here("code_repository/functions/dual_cue_opt.R"))
# for static competition
source(here("code_repository/functions/ci_comp_static.R"))
# for invasive competition
source(here("code_repository/functions/ci_invasion_analysis.R"))
# for partitioning analysis
source(here("code_repository/functions/partition_si.R"))
# for semi-stochastic single infection model
source(here("code_repository/functions/mc_all.R"))
source(here("code_repository/functions/mc_single.R"))
# parameters used to simulate malaria intrahost  dynamics
parameters_tsukushi <- c(R1 = 8.89*10^6,
lambda = 3.7*10^5,
mu = 0.025,
p = 8*10^-6,
alpha = 1,
alphag = 2,
beta = 5.721,
mum = 48,
mug = 4,
I0 = 43.85965,
Ig0 = 0,
a = 150,
b = 100,
sp = 1,
psin = 16.69234,
psiw = 0.8431785,
phin = 0.03520591,
phiw = 550.842,
iota = 2.18*(10^6),
rho = 0.2627156)
# time range and time step at which the model will be simulated
time_range <- seq(0, 20, by = 1e-3)
# smallest fitness difference for co-infection optimization script to exit
limit <- 0.01
# different cue_range
I_range_none <- seq(0, 6*(10^6), by = (6*(10^6))/5000)
I_range_log <- seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000)
G_range_none <- seq(0, 6*(10^4), by = (6*(10^4))/5000)
G_range_log <- seq(0, log10(6*(10^4)), by = (log10(6*(10^4)))/5000)
# cluster initialization. This will write the results to a data/si_validation folder
surveillance::plapply(si_opt.ls, validate_si)
df <- si_opt.ls[[1]]
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
registerDoParallel(cl)
registerDoRNG(137)
res <- foreach(i= 1:1000, .verbose = T, .packages = c("doParallel", "doRNG", "deSolve", "splines2", "stringr", "dplyr", "tidyr", "crone", "here")) %dorng% {
# generate random par, bounds for parameters based on previous determined bounds
par1 <- runif(1, -5, 5)
par2 <- runif(1, -500, 500)
par3 <- runif(1, -500, 500)
par4 <- runif(1, -500, 500)
# get random parameters
par_rand <- c(par1, par2, par3, par4)
# get log
if(df$log == "log"){log = "log10"}
if(df$log == "none"){log = "none"}
# get cue_range
cue_range <- seq(df$low, df$high, by = df$by)
# get fitness. 20 days simulation to cut down on computation time
fitness <- chabaudi_si_clean(parameters_cr = par_rand,
parameters= parameters_tsukushi,
immunity = "tsukushi",
time_range = seq(0,30,0.001),
cue = df$cue,
log_cue = log,
cue_range = cue_range,
dyn = F)
print(fitness)
}
## get fitness.df
fitness.df <- do.call("rbind", res)
## rbind
fitness.df <- as.data.frame(cbind(fitness.df,
cue = rep(df$cue, nrow(fitness.df)),
log = rep(df$log, nrow(fitness.df)),
id = rep(df$id, nrow(fitness.df))))
filename <- paste0("si_", df$id, "_cf.csv")
## write.csv
write.csv(fitness.df, here(paste0("code_repository/data/si_validation/", filename)))
res <- foreach(i= 1:1000, .verbose = T, .packages = c("doParallel", "doRNG", "deSolve", "splines2", "stringr", "dplyr", "tidyr", "crone", "here")) %dorng% {
# generate random par, bounds for parameters based on previous determined bounds
par1 <- runif(1, -5, 5)
par2 <- runif(1, -500, 500)
par3 <- runif(1, -500, 500)
par4 <- runif(1, -500, 500)
# get random parameters
par_rand <- c(par1, par2, par3, par4)
# get log
if(df$log == "log"){log = "log10"}
if(df$log == "none"){log = "none"}
# get cue_range
cue_range <- seq(df$low, df$high, by = df$by)
# get fitness. 20 days simulation to cut down on computation time
fitness <- chabaudi_si_clean(parameters_cr = par_rand,
parameters= parameters_tsukushi,
immunity = "tsukushi",
time_range = seq(0,30,0.001),
cue = df$cue,
log_cue = log,
cue_range = cue_range,
dyn = F)
return(fitness)
}
# generate random par, bounds for parameters based on previous determined bounds
par1 <- runif(1, -5, 5)
par2 <- runif(1, -500, 500)
par3 <- runif(1, -500, 500)
par4 <- runif(1, -500, 500)
# get random parameters
par_rand <- c(par1, par2, par3, par4)
# get log
if(df$log == "log"){log = "log10"}
if(df$log == "none"){log = "none"}
# get cue_range
cue_range <- seq(df$low, df$high, by = df$by)
# Import in the list of single infection optimization results
si_opt.df <- read.csv(here("code_repository/data/si_opt.csv"))
# split into individual tables
si_opt.ls <- split(si_opt.df, seq(nrow(si_opt.df)))
# cluster initialization. This will write the results to a data/si_validation folder
surveillance::plapply(si_opt.ls, validate_si)
chabaudi_si_clean
install.packages("doSNOW")
install.packages("doParallel")
install.packages("doParallel")
install.packages("doMPI")
