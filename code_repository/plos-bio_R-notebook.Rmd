---
title: "Code Base for Cue perception underlies malaria life history and infection dynamics"
output: html_notebook
---
# Introduction
This R Notebook will take you through the entirety of the modelling process of simulating and optimizing Plasmodium chabaudi intrahost dynamics. It will be roughly split into the following sections:

- single infection optimization
- dual cue optimization
- phase mapping of laboratory mice infections
- partitioning the drivers of infection outcomes
- semi-stochastic single infection model

# Preparation
### Load libraries
```{r results='hide', message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
library(parallel)
```

### Load scripts
```{r warning=FALSE}
# for single cues
source(here("code_repository/functions/opt_local.R"))
source(here("code_repository/functions/opt_global.R"))
source(here("code_repository/functions/chabaudi_si_clean.R"))
source(here("code_repository/functions/validate_si.R"))

# for optimization of static conversion rate
source(here("code_repository/functions/chabaudi_si_static.R"))

# for dual cue
source(here("code_repository/functions/dual_cue_opt.R"))
source(here("code_repository/functions/dual_cue_opt_global.R"))

# for semi-stochastic single infection model
source(here("code_repository/functions/mc_all.R"))
source(here("code_repository/functions/mc_single.R"))
source(here("code_repository/functions/mc_all_dual.R"))
source(here("code_repository/functions/mc_single_dual.R"))
source(here("code_repository/functions/opt_local_beta.R"))
```

### Load datasets
```{r}
## single infection optimization values
si_opt.df <- read.csv(here("code_repository/data/si_opt.csv"))

## posterior distribution of parameters for MC
posterior.df <- read.csv(here("code_repository/data/posterior.csv"))
```


### Load parameters
```{r}
# parameters used to simulate malaria intrahost  dynamics
parameters_tsukushi <- c(R1 = 8.89*10^6, 
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, 
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156)

# time range and time step at which the model will be simulated
time_range <- seq(0, 20, by = 1e-3)

# smallest fitness difference for co-infection optimization script to exit
limit <- 0.01

# different cue_range
I_range_none <- seq(0, 6*(10^6), by = (6*(10^6))/5000)
I_range_log <- seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000)
G_range_none <- seq(0, 6*(10^4), by = (6*(10^4))/5000)
G_range_log <- seq(0, log10(6*(10^4)), by = (log10(6*(10^4)))/5000)
```

# Single infection optimization
The purpose of numerical optimization is to identify the basis-spline coefficients that maximizes the cumulative transmission potential of the model. Here, model optimization is performed using the L-BFGS-B algorithm implemented in optimParallel. Model optimization is performed using the opt_local wrapper function, which works around the chabaudi_si_clean.R script, which simulates the single infection dynamics of P. chabaudi. We will perform optimization for each cue separately.

### Model optimization (local)
```{r}
# Time (ideal case)
t_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "t",
                            log = "none",
                            cue_range = time_range)


# I 
I_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "I",
                            log = "none",
                            cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))

# I logged
I_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "I",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

# Ig
Ig_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "Ig",
                            log = "none",
                            cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))


# Ig logged
Ig_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "Ig",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

# I + Ig
I_Ig_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "I+Ig",
                            log = "none",
                            cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))

# I+Ig logged
I_Ig_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "Ig+I",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

# I logged
I_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "I",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

# RBC 
R_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "R",
                            log = "none",
                            cue_range = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000))

# RBC logged
R_loc_log.op <- opt_local(par = rep(0.5, 4),
                            cue = "R",
                            log = "log10",
                            cue_range = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000))

# G
G_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "G",
                            log = "none",
                            cue_range = seq(0, 6*(10^4), (6*(10^4))/5000))

# G logged 
G_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "G",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000))
```

### Model optimization (global)
```{r}
# Time (ideal case)
t_glb.op <- opt_global(
                            cue = "t",
                            log = "none",
                            cue_range = time_range)

# I 
I_glb.op <- opt_global(
                            cue = "I",
                            log = "none",
                            cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))

# I logged
I_log_glb.op <- opt_global(
                            cue = "I",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

# Ig
Ig_glb.op <- opt_global(
                            cue = "Ig",
                            log = "none",
                            cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))


# Ig logged
Ig_log_glb.op <- opt_global(
                            cue = "Ig",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

# I + Ig
I_Ig_glb.op <- opt_global(
                            cue = "I+Ig",
                            log = "none",
                            cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))

# I+Ig logged
I_Ig_log_glb.op <- opt_global(
                            cue = "Ig+I",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

# I logged
I_log_glb.op <- opt_global(
                            cue = "I",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

# RBC 
R_glb.op <- opt_global(
                            cue = "R",
                            log = "none",
                            cue_range = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000))

# RBC logged
R_glb_log.op <- opt_global(
                            cue = "R",
                            log = "log10",
                            cue_range = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000))

# G
G_glb.op <- opt_global(
                            cue = "G",
                            log = "none",
                            cue_range = seq(0, 6*(10^4), (6*(10^4))/5000))

# G logged 
G_log_glb.op <- opt_global(
                            cue = "G",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000))
```

### Optimize static conversion rate
```{r}
# get list of cr to scan
cr_ls <- seq(0, 1, by = 0.01)

# run dynamics and append fitness
si_static_opt.ls <- mclapply(cr_ls, function(x){
  fitness <- chabaudi_si_static(
  cr = x,
  immunity = "tsukushi",
  parameters = parameters_tsukushi,
  time_range = seq(0, 20, by = 1e-3),
  solver = "vode",
  dyn = F)
  
  ## append to df
  df <- data.frame(cr = x, fitness = fitness)
  return(df)
}, mc.cores = 6)

# combine dataframes
si_static_opt.df <- do.call(rbind, si_static_opt.ls)

# look at cr that leads to highest fitness: 0.43
si_static_opt.df %>% arrange(desc(fitness))

# visualization
ggplot(si_static_opt.df, aes(x = cr, y = fitness)) +
  geom_line()
```


### Model validation
To ensure that we have obtained a result near the global optimum, we need to validate each of the results. This can be done by randomly simulating 1000 parameter sets and seeing whether those random parameters produces a higher cumulative transmission results compared to our optimized set. Here, we are using the validate_si package to generate 1000 random parameters (these parameter values are generated within a empirically determined bound that should encapsulate most spline flexibility).

```{r results='hide', message=FALSE, warning=FALSE}
# Import in the list of single infection optimization results
si_opt.df <- read.csv(here("code_repository/data/si_opt.csv"))

# split into individual tables
si_opt.ls <- split(si_opt.df, seq(nrow(si_opt.df)))

# cluster initialization. This will write the results to a data/si_validation folder
source(here("code_repository/functions/validate_si.R"))
surveillance::plapply(si_opt.ls, validate_si)

# import in all single infection data
si_val.ls <- list.files(path = here("code_repository/data/si_validation"), pattern = "*.csv", full.names = T)

si_val.df <- lapply(si_val.ls, read.csv)
si_val.df <- do.call(rbind, si_val.df)

# get max fitness from simulation. left join with si_opt
si_opt.df <- read.csv(here("code_repository/data/si_opt.csv"))

# we can see that all of the randomly simulated models have a fitness value that is less than the optimized model
si_val.df %>% group_by(id) %>% summarise(max_fitness = max(V1)) %>% 
  left_join(si_opt.df, by =c("id" = "id")) %>% 
  mutate(difference = fitness_20 - max_fitness)
```

# Dual cue optimization
```{r}
# import in single infection optimization dataframe
si_opt.csv <- read.csv(here("code_repository/data/si_opt.csv"))

#W get all unique combinations but eliminating all combinations that uses the same cue
dual_cue.df <- expand.grid(si_opt.csv$id, si_opt.csv$id) %>% 
  filter(Var1 != Var2) %>% 
  left_join(select(si_opt.csv, cue1 = cue, id), by = c("Var1" = "id")) %>% 
  left_join(select(si_opt.csv, cue2 = cue, id), by = c("Var2" = "id")) %>% 
  filter(cue1 != cue2) %>% 
  mutate(temp = paste(pmin(Var1, Var2), pmax(Var1, Var2))) %>% 
  distinct(temp, .keep_all = T) # get rid of the same cue combination but just in different orders

# get cue range (500 divisons)
cue_range_alt <- read.csv(here("code_repository/data/cue_range_si_alt.csv")) 
dual_cue.df2 <- dual_cue.df %>% 
  left_join(cue_range_alt, by = c("Var1" = "id")) %>% 
  left_join(select(cue_range_alt, cue_b = cue, log_b = log, low_b = low, high_b = high, by_b = by, id_b = id, label_b = label), by = c("Var2" = "id_b")) 

# split table into rows
dual_cue.ls <- split(dual_cue.df2, seq(nrow(dual_cue.df2)))

# run optimization (local)
lapply(dual_cue.ls, dual_cue_opt)
dual_cue_opt(dual_cue.ls[[39]])

# run optimization (global)
source(here("code_repository/functions/dual_cue_opt_global.R"))
lapply(dual_cue.ls, dual_cue_opt_global)
```

# Phase-mapping of laboratory mice infection
### Importing in data downloaded from Dryad
```{r}
# import in https://academic.oup.com/emph/article/2018/1/127/5045871?login=true
## (2018 published in EMPH)
emph_2018 <- readxl::read_xls(here("experimental_data/Huijben_2018_EMPH.xls"), sheet = 1)

# import in https://onlinelibrary.wiley.com/doi/10.1111/j.1558-5646.2010.01068.x
## (2010 published in Evolution)
evo_2010 <- readxl::read_xls(here("experimental_data/Huijben_2010_evolution.xls"), sheet = 1)

# import in https://journals.plos.org/plospathogens/article?id=10.1371/journal.ppat.1003578#:~:text=The%20philosophy%20is%20that%20aggressive,longer%20feel%20sick%20%5B13%5D.
## (2013 in PLoS pathogen)
plos_2013_1 <- readxl::read_xlsx(here("experimental_data/Huijben_2013_PLoS.xlsx"), sheet = 2)

plos_2013_2 <- readxl::read_xlsx(here("experimental_data/Huijben_2013_PLoS.xlsx"), sheet = 3)

# import in https://onlinelibrary.wiley.com/doi/10.1111/j.1420-9101.2011.02369.x
## (2011 in Journal of Evolutionary Biology)
eseb_2011 <- readxl::read_xls(here("experimental_data/Huijben_2011_eseb.xls"), sheet = 1)

# PRIVATE database!! This will not  be available! import in https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3939351/
## (2011 in Journal of American naturalist)
amna_2011 <- readxl::read_xls(here("experimental_data/Pollitt_2011_naturalist.xls"), sheet = 1)
```

### clean data for single infection
```{r}
## for EMPH 2018 study, include only infection series without drugs were R-inoculum is administered by itself, which includes 6, 7, 8, 9, 10. Box 6 has a starting inoculum number of 10^6, which is most similar to other studies. Filtering between day 3-21 because those are the days where we have single day data.
emph_2018_ss.df <- emph_2018 %>% 
  filter(Box %in% seq(6, 10) &
         dplyr::between(Day, 3, 21)) %>% 
  mutate(dose = case_when(
    Box == 6 ~ 10^6,
    Box == 7 ~ 10^5,
    Box == 8 ~ 10^3,
    Box == 9 | Box == 10 ~ 10^1
  )) %>% 
  mutate(strain = "As6p",
         study = "emph2018",
         study_strain = paste0(strain, study),
         id = paste0(study, strain, Box, Mouse, 1),
         RBC = RBC * (10^6)) %>%
  select(day = Day,
         mouse = Mouse, 
         RBC, 
         asex = Rasex,
         gam = Rgam,
         dose,
         strain,
         study,
         study_strain,
         id)

## for 2011 eseb, only day 3-17 data are analyzed because those are the days where gametocyte data are available
eseb_2011_ss.df <- eseb_2011 %>% 
  filter(Clones == "R" & between(Day, 3, 17) &
           Drugs == "N") %>% 
  mutate(dose = 10^6,
         strain = "As8p",
         study = "eseb2011",
         study_strain = paste0(strain, study),
         RBC = RBC*(10^6),
         id = paste0(study, strain, Box, Mouse, 2)) %>% 
  select(day = Day,
         mouse = Mouse,
         RBC,
         asex = R.asex,
         gam = R.gam,
         dose,
         strain,
         study,
         study_strain,
         id)

## for evolution_2010, single infection data for both resistant and susceptible clones are available without drug treatment
evolution_2010_ss.df <- evo_2010 %>% 
  filter(Clone == "R" | Clone == "S") %>%
  filter(between(Day, 3, 21) &
           Drugs == "nodrugs") %>% 
  mutate(asex = R.asex + S.asex,
         gam = R.gam + S.gam,
         dose = 10^6,
         RBC = RBC*(10^6),
         study = "evol2011",
         strain = ifelse(Clone == "R", "As12", "AJ51"),
         study_strain = paste0(strain, "_", study),
         id = paste0(study, strain, Box, Mouse, 3)) %>% 
  select(day = Day,
         mouse = Mouse,
         RBC,
         asex,
         gam,
         dose,
         strain,
         study,
         study_strain,
         id)

## for amnat 2011, get single infection data. Filter out any mice that have missing data. Set negative asexual data ot 0
amna_2011_ss.df <-  amna_2011 %>% 
  filter(treat %in% c("AJ", "AS", "ER", "CR", "CW", "DK")) %>% 
  mutate(asex = tot.para - tot.gcyte,
         gam = tot.gcyte,
         dose = 10^6,
         study = "amna_2011",
         RBC = rbc/(10^6),
         study_strain = paste0(treat, "_", study),
         id = paste0(study, treat, div, mouse, 4)) %>% 
  mutate(asex = ifelse(asex < 0, 0, asex)) # sometimes total parasite is less than gametocyte so need to correct for this

### check for NA by groups
amna_na.id <- amna_2011_ss.df %>% 
  filter_at(vars(asex, gam, RBC), all_vars(is.na(.))) %>% 
  distinct(id) %>% 
  select(id)

amna_2011_ss.df2 <- amna_2011_ss.df %>% 
  filter(!(id %in% amna_na.id$id)) %>% 
  select(day,
         mouse,
         RBC,
         asex,
         gam,
         dose,
         strain = treat,
         study,
         study_strain,
         id)

# rbind
exp_ss.df <- rbind(emph_2018_ss.df, eseb_2011_ss.df, evolution_2010_ss.df, amna_2011_ss.df2)

# correct RBC to actual density (in unit of RBC/uL)
exp_ss_dose.df <- exp_ss.df %>% filter(dose == 10^6) 

# add logged parameters
exp_ss_dose.df <- exp_ss_dose.df %>% 
  mutate(log10_asex = log10(asex+1),
         log10_RBC = log10(RBC+1),
         log10_gam = log10(gam+1))

# get dataset with only resistance strain
exp_ss_R.df <- exp_ss_dose.df %>% filter(strain != "AJ51")
```

# Semi-stochastic single infection model
Here, we are going to perform 5000 Monte Carlo simulations where the parasite is adopting the optimal single infection strategy with all six random variables. For each run, the values of these random variables is drawn from the posterior distribution of the variables. Thus, while the variable value remains constant through out the simulation, each run will likely have a different set of parameters describing host immunity, parasite burst size, and RBC regeneration speed. To partition the contribution of each random variable to the overall effect on infection outcomes, we will perform Monte Carlo simulations where only one random variable is present during each run. 

### All six parameters vary
```{r}
# import in posterior distribution. Note that id = 1 is the reference!
posterior <- utils::read.csv(here("code_repository/data/posterior.csv"))

# get list of dataframes split by row. only do the first 1000!
posterior.ls <- split(posterior, seq(nrow(posterior)))[1:1000]

# time
mc_time.res <- mclapply(posterior.ls, function(x){
  mc_all(par = c(4.55386,	-13.0056,	4.15466,	-11.9424),
                    cue = "t",
                    cue_range = seq(0, 20, 1e-2),
                    log= "none",
         rand_df = x)},
  mc.cores = 8)

# Asexual iRBC
mc_I.res <- mclapply(posterior.ls, function(x){
  mc_all(par = c(0.1135384,  -39.0585154, 1941.9082813,  119.8228980),
                    cue = "I",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none",
                   rand_df = x)},
  mc.cores = 8)

mc_I_log.res <- mclapply(posterior.ls, function(x){
  mc_all(par = c(5.463558,   2.383948, -17.757281,   4.571835),
                    cue = "I",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10",
                   rand_df = x)},
  mc.cores = 8)


# Sexual iRBC
mc_Ig.res <- mclapply(posterior.ls, function(x){
  mc_all(par = c(0.05234791,  -46.03368629, 1897.61313455,   70.57689145),
                    cue = "Ig",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none",
         rand_df = x)},
  mc.cores = 8)

mc_Ig_log.res <- mclapply(posterior.ls, function(x){
  mc_all(par = c(1.74633, -1.78582, -5.52834, 1.57344 ),
                    cue = "Ig",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10",
         rand_df = x)},
  mc.cores = 8)

# all iRBC
mc_I_Ig.res <- mclapply(posterior.ls, function(x){
  mc_all(par = c(0.3159297,  -46.1104558, 1250.7529081,   -6.1982093),
                    cue = "I+Ig",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none",
         rand_df = x)},
  mc.cores = 8)

mc_I_Ig_log.res <- mclapply(posterior.ls, function(x){
  mc_all(par = c(3.594042,   4.157744, -13.530672,   2.599905),
                    cue = "I+Ig",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10",
         rand_df = x)},
  mc.cores = 8)

# gametocyte
MC_G.res <- mclapply(posterior.ls, function(x){
  mc_all(par = c(0.04061288,   -9.31445958,   74.13015506, -431.59843638),
                    cue = "G",
                    cue_range = seq(0, 6*(10^4), (6*(10^4))/5000),
                    log= "none",
         rand_df = x)},
  mc.cores = 8)

mc_G_log.res <- mclapply(posterior.ls, function(x){
  mc_all(par = c(1.211521, -3.936778,-1.312944, -1.285713),
                    cue = "G",
                    cue_range = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000),
                    log= "log10",
         rand_df = x)},
  mc.cores = 8)


# RBC
mc_R.res <- mclapply(posterior.ls, function(x){
  mc_all(par = c(-4.912371,	45.345566,	-16.844173,	11.91522),
                    cue = "R",
                    cue_range = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000),
                    log= "none",
         rand_df = x)},
  mc.cores = 8)

mc_R_log.res <- mclapply(posterior.ls, function(x){
  mc_all(par = c(3.460017,	203.970669,	-45.649759,	1.691582),
                    cue = "R",
                    cue_range = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000),
                    log= "log10",
         rand_df = x)},
  mc.cores = 8)

# I log and R log (dual cue model)
mc_R_log_I_log.res <- mclapply(posterior.ls, function(x){
  mc_all_dual(par = c(4.446192033,	10.97518275,	1.38762817,	23.3059254,	-3.452052371,	-18.0070692	,39.66614226,	-3.545193141,	18.78350799),
                    cue = "R",
         cue_b = "I",
                    cue_range = seq(log10(10^6), log10(10^7), length.out = 500),
         cue_range_b = seq(0, log10(6*(10^6)), length.out = 500),
                    log= "log10",
                    log_b = "log10",
         rand_df = x)},
  mc.cores = 8)

# R and I log
mc_R_I_log.res <- mclapply(posterior.ls[1201:length(posterior.ls)], function(x){
  mc_all_dual(par = c(-9.518084898,	-439.4342135,	85.99834201,	118.6093975,	-244.108158,	33.24560006,	-30.89681964,	-24.84888061,	-88.60274223),
                    cue = "R",
         cue_b = "I",
                    cue_range = seq((10^6), (10^7), length.out = 500),
         cue_range_b = seq(0, log10(6*(10^6)), length.out = 500),
                    log= "none",
                    log_b = "log10",
         rand_df = x)},
  mc.cores = 8)

# R and I+Ig log
mc_R_I_Ig_log.res <- mclapply(posterior.ls, function(x){
  mc_all_dual(par = c(-0.123534059,	10.41243862,	-16.13098789,	28.09607529,	-12.49060926,	12.77524469,	36.77045332,	7.011182218,	6.680916699),
                    cue = "R",
         cue_b = "I+Ig",
                    cue_range = seq((10^6), (10^7), length.out = 500),
         cue_range_b = seq(0, log10(6*(10^6)), length.out = 500),
                    log= "none",
                    log_b = "log10",
         rand_df = x)},
  mc.cores = 8)

# R log and I+Ig log
mc_R_log_I_Ig_log.res <- mclapply(posterior.ls, function(x){
  mc_all_dual(par = c(-7.687311702,	-497.7126667,	-1003.526906,	47.78563659,	-248.7360112,	-181.9755341,	27.71388409,	-22.55271948,	-52.13198563),
                    cue = "R",
         cue_b = "I+Ig",
                    cue_range = seq(log10(10^6), log10(10^7), length.out = 500),
         cue_range_b = seq(0, log10(6*(10^6)), length.out = 500),
                    log= "log10",
                    log_b = "log10",
         rand_df = x)},
  mc.cores = 8)
```

### Only one parameter vary
Note, after checking the difference in distribution betweeen 5000 vs 1000 reps, I do not find any difference. Hence, for subsequent simulations, only perform 1000 replicates!
```{r}
# Asexual iRBC
mclapply(posterior.ls, function(x){
  mc_single(par = c(0.1135384,  -39.0585154, 1941.9082813,  119.8228980),
                    cue = "I",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none",
                   rand_df = x)},
  mc.cores = 8)

mclapply(posterior.ls, function(x){
  mc_single(par = c(5.463558,   2.383948, -17.757281,   4.571835),
                    cue = "I",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10",
                   rand_df = x)},
  mc.cores = 8)

# Sexual iRBC
mclapply(posterior.ls, function(x){
  mc_single(par = c(0.05234791,  -46.03368629, 1897.61313455,   70.57689145),
                    cue = "Ig",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none",
         rand_df = x)},
  mc.cores = 8)
```


```{r}
mclapply(posterior.ls, function(x){
  mc_single(par = c(1.74633, -1.78582, -5.52834, 1.57344 ),
                    cue = "Ig",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10",
         rand_df = x)},
  mc.cores = 8)

# all iRBC
mclapply(posterior.ls, function(x){
  mc_single(par = c(0.3159297,  -46.1104558, 1250.7529081,   -6.1982093),
                    cue = "I+Ig",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none",
         rand_df = x)},
  mc.cores = 8)

mclapply(posterior.ls, function(x){
  mc_single(par = c(3.594042,   4.157744, -13.530672,   2.599905),
                    cue = "I+Ig",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10",
         rand_df = x)},
  mc.cores = 8)

# gametocyte
mclapply(posterior.ls, function(x){
  mc_single(par = c(0.04061288,   -9.31445958,   74.13015506, -431.59843638),
                    cue = "G",
                    cue_range = seq(0, 6*(10^4), (6*(10^4))/5000),
                    log= "none",
         rand_df = x)},
  mc.cores = 8)

mclapply(posterior.ls, function(x){
  mc_single(par = c(1.211521, -3.936778,-1.312944, -1.285713),
                    cue = "G",
                    cue_range = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000),
                    log= "log10",
         rand_df = x)},
  mc.cores = 8)

# RBC
mclapply(posterior.ls, function(x){
  mc_single(par = c(-4.912371,	45.345566,	-16.844173,	11.91522),
                    cue = "R",
                    cue_range = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000),
                    log= "none",
         rand_df = x)},
  mc.cores = 8)

mclapply(posterior.ls, function(x){
  mc_single(par = c(3.460017,	203.970669,	-45.649759,	1.691582),
                    cue = "R",
                    cue_range = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000),
                    log= "log10",
         rand_df = x)},
  mc.cores = 8)

# R log and I log
mclapply(posterior.ls, function(x){
  mc_single_dual(par = c(4.446192033,	10.97518275,	1.38762817,	23.3059254,	-3.452052371,	-18.0070692	,39.66614226,	-3.545193141,	18.78350799),
                    cue = "R",
         cue_b = "I",
                    cue_range = seq(log10(10^6), log10(10^7), length.out = 500),
         cue_range_b = seq(0, log10(6*(10^6)), length.out = 500),
                    log= "log10",
                    log_b = "log10",
         rand_df = x)},
  mc.cores = 8)

# R and I log
mclapply(posterior.ls, function(x){
  mc_single_dual(par = c(-9.518084898,	-439.4342135,	85.99834201,	118.6093975,	-244.108158,	33.24560006,	-30.89681964,	-24.84888061,	-88.60274223),
                    cue = "R",
         cue_b = "I",
                    cue_range = seq((10^6), (10^7), length.out = 500),
         cue_range_b = seq(0, log10(6*(10^6)), length.out = 500),
                    log= "none",
                    log_b = "log10",
         rand_df = x)},
  mc.cores = 8)

# R and I+Ig log
mclapply(posterior.ls, function(x){
  mc_single_dual(par = c(-0.123534059,	10.41243862,	-16.13098789,	28.09607529,	-12.49060926,	12.77524469,	36.77045332,	7.011182218,	6.680916699),
                    cue = "R",
         cue_b = "I+Ig",
                    cue_range = seq((10^6), (10^7), length.out = 500),
         cue_range_b = seq(0, log10(6*(10^6)), length.out = 500),
                    log= "none",
                    log_b = "log10",
         rand_df = x)},
  mc.cores = 8)

# R log and I+Ig log
mclapply(posterior.ls, function(x){
  mc_single_dual(par = c(-7.687311702,	-497.7126667,	-1003.526906,	47.78563659,	-248.7360112,	-181.9755341,	27.71388409,	-22.55271948,	-52.13198563),
                    cue = "R",
         cue_b = "I+Ig",
                    cue_range = seq(log10(10^6), log10(10^7), length.out = 500),
         cue_range_b = seq(0, log10(6*(10^6)), length.out = 500),
                    log= "log10",
                    log_b = "log10",
         rand_df = x)},
  mc.cores = 8)

```

#=================================#
# Examining the robustness and reliability of cues under stochasticity
#=================================#
#---------- Examining cue reliability with burst size -----------#
```{r}
## plotting the psoterior distribution. It seems that these values represent the peak points
ggplot(posterior.df) +
  geom_density(aes(x = burst)) +
  geom_vline(xintercept = c(3.98,4.7,5.53, 6.08)) +
  theme_classic()
```

## Prepare database
```{r}
## List of beta values to test
beta_ls <- c(3.98,4.7,5.53, 6.08)

## dataframes containing all single cues to loop over (we will perform the dual cue opt separately)
si_opt_beta.df <- cbind.data.frame(id = rep(si_opt.df$id, length(beta_ls))) %>% 
  arrange(id) %>% 
  mutate(beta = rep(beta_ls, n_distinct(si_opt.df$id))) %>% 
  left_join(si_opt.df, by = "id")

## split
si_opt_beta.ls <- split(si_opt_beta.df, seq(nrow(si_opt_beta.df)))
si_opt_beta.ls
```

## Run function
```{r}
## optimization with initial starting point of optimized parameter set
lapply(si_opt_beta.ls, function(x){opt_local_beta(x)})

## optimization with initial starting point of (0.5x4)
lapply(si_opt_beta.ls, function(x){opt_local_beta(x, default = T)})
```

## Optimize top 4 dual cue models
```{r}
## import in the functions
source(here("code_repository/functions/dual_cue_opt_beta.R"))

## import in dual cue fitness dataframe
dual_cue_f.df <- read.csv(here("code_repository/data/dual_cue_fitness_final.csv"))

## make df for optimization by adding the correspond optmization parameters
dual_cue_burst.df <- dual_cue_f.df %>% 
  slice_max(n = 4, order_by = fitness) %>% 
  cbind.data.frame(
    log = c("log", "none", "none", "log"),
    log_b = c("log", "log", "log", "log"),
    cue = c("R", "R", "R", "R"),
    cue_b = c("I", "I", "I+Ig", "I+Ig"),
    low = c(6, 10^6,10^6, 6),
    high = c(7, 10^7,10^7, 7),
    low_b= c(0,0,0, 0),
    high_b = c(log10(6*(10^6)),log10(6*(10^6)),log10(6*(10^6)),log10(6*(10^6)))
  )

## add beta
dual_cue_burst.df <- do.call("rbind", replicate(4, dual_cue_burst.df, simplify = FALSE)) %>% 
  arrange(id, id_b) %>% 
  mutate(beta = rep(beta_ls, 4))

## split
dual_cue_burst.ls <- split(dual_cue_burst.df, seq(nrow(dual_cue_burst.df)))

## run function
lapply(dual_cue_burst.ls[5:16], function(x){dual_cue_opt_beta(x)})
lapply(dual_cue_burst.ls[5:16], function(x){dual_cue_opt_beta(x, default = T)})
```





