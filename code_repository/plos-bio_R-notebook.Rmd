---
title: "Code Base for Cue perception underlies malaria life history and infection dynamics"
output: html_notebook
---
# Introduction
This R Notebook will take you through the entirety of the modelling process of simulating and optimizing Plasmodium chabaudi intrahost dynamics. It will be roughly split into the following sections:

- single infection optimization
- co-infection optimization
- dual cue optimization
- phase mapping of laboratory mice infections
- co-infection competition
- partitioning the drivers of infection outcomes
- semi-stochastic single infection model

# Preparation
### Load libraries
```{r results='hide', message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(here)
library(deSolve)
library(crone)
library(optimParallel)
library(doParallel)
library(doRNG)
library(arrow)
library(parallel)
```

### Load scripts
```{r warning=FALSE}
# for single infections
source(here("code_repository/functions/opt_local.R"))
source(here("code_repository/functions/chabaudi_si_clean.R"))
source(here("code_repository/functions/validate_si.R"))

# for co-infections
source(here("code_repository/functions/co_infection_opt_alt.R"))
source(here("code_repository/functions/co_infection_opt_do.R"))
source(here("code_repository/functions/chabaudi_ci_clean.R"))
source(here("code_repository/functions/validate_ci.R"))

# for dual cue
source(here("code_repository/functions/dual_cue_opt.R"))

# for static competition
source(here("code_repository/functions/ci_comp_static.R"))

# for invasive competition
source(here("code_repository/functions/ci_invasion_analysis.R"))

# for partitioning analysis
source(here("code_repository/functions/partition_si.R"))

# for semi-stochastic single infection model
source(here("code_repository/functions/mc_run.R")) ## 1000 MC simulations of single infection model where all 6 parameters vary
source(here("code_repository/functions/mc_five.R")) ## wrapper around mc_run to simulate 5000 MC simulations. Avoid memory overload
source(here("code_repository/functions/partition_var.R")) ## performs 1000 MC simulations of the single infection model where only one specified parameter vary
source(here("code_repository/functions/mc_five2.R")) ## wrapper around partition_var to perform 5000 simulations
source(here("code_repository/functions/get_par_MC.R")) ## wrapper around mc_five2 to execute all 6 iterations of 5000 simulations where only one parameter vary
```

### Load parameters
```{r}
# parameters used to simulate malaria intrahost  dynamics
parameters_tsukushi <- c(R1 = 8.89*10^6, 
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, 
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6),
                rho = 0.2627156)

# time range and time step at which the model will be simulated
time_range <- seq(0, 20, by = 1e-3)

# smallest fitness difference for co-infection optimization script to exit
limit <- 0.01

# different cue_range
I_range_none <- seq(0, 6*(10^6), by = (6*(10^6))/5000)
I_range_log <- seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000)
G_range_none <- seq(0, 6*(10^4), by = (6*(10^4))/5000)
G_range_log <- seq(0, log10(6*(10^4)), by = (log10(6*(10^4)))/5000)
```

# Single infection optimization
The purpose of numerical optimization is to identify the basis-spline coefficients that maximizes the cumulative transmission potential of the model. Here, model optimization is performed using the L-BFGS-B algorithm implemented in optimParallel. Model optimization is performed using the opt_local wrapper function, which works around the chabaudi_si_clean.R script, which simulates the single infection dynamics of P. chabaudi. We will perform optimization for each cue separately.

### Model optimization
```{r}
# Time (ideal case)
t_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "t",
                            log = "none",
                            cue_range = time_range)

# I 
I_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "I",
                            log = "none",
                            cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))

# I logged
I_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "I",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

# Ig
Ig_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "Ig",
                            log = "none",
                            cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))


# Ig logged
Ig_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "Ig",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

# I + Ig
I_Ig_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "I+Ig",
                            log = "none",
                            cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000))

# I+Ig logged
I_Ig_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "Ig+I",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

# I logged
I_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "I",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000))

# RBC 
R_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "R",
                            log = "none",
                            cue_range = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000))

# RBC logged
R_loc_log.op <- opt_local(par = rep(0.5, 4),
                            cue = "R",
                            log = "log10",
                            cue_range = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000))

# G
G_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "G",
                            log = "none",
                            cue_range = seq(0, 6*(10^4), (6*(10^4))/5000))

# G logged 
G_log_loc.op <- opt_local(par = rep(0.5, 4),
                            cue = "G",
                            log = "log10",
                            cue_range = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000))
```

### Model validation
To ensure that we have obtained a result near the global optimum, we need to validate each of the results. This can be done by randomly simulating 1000 parameter sets and seeing whether those random parameters produces a higher cumulative transmission results compared to our optimized set. Here, we are using the validate_si package to generate 1000 random parameters (these parameter values are generated within a empirically determined bound that should encapsulate most spline flexibility).

```{r results='hide', message=FALSE, warning=FALSE}
# Import in the list of single infection optimization results
si_opt.df2 <- read.csv(here("data/si_opt.csv"))

# split into individual tables
si_opt.ls <- split(si_opt.df, seq(nrow(si_opt.df)))

# cluster initialization. This will write the results to a data/si_validation folder
surveillance::plapply(si_opt.ls, validate_si)

# import in all single infection data
si_val.ls <- list.files(path = here("data/si_validation"), pattern = "*.csv", full.names = T)

si_val.df <- lapply(si_val.ls, read.csv)
si_val.df <- do.call(rbind, si_val.df)

# get max fitness from simulation. left join with si_opt
si_opt.df <- read.csv(here("data/si_opt.csv"))

# we can see that all of the randomly simulated models have a fitness value that is less than the optimized model
si_val.df %>% group_by(id) %>% summarise(max_fitness = max(V1)) %>% 
  left_join(si_opt.df, by =c("id" = "id")) %>% 
  mutate(difference = fitness_20 - max_fitness)
```

# Co-infection
For co-infection optimization, the optimization process do not always converge (when using the L-BFGS-B algorithm). In these cases, I find that using an alternative global numerical optimization algorithm often does the trick (e.g. DEoptim).

### Model optimization
```{r}
# time
#local optimization (0.5x4) gave variable coefficients: 26.16425,	-71.07799,	53.34121,	-166.25693
# deoptim optimization (0.5x4):  -0.999973,   -99.997053,  -999.322610, -4115.796681. Produced dynamic where all parasites die within the first few days. Not used!
# local optimization with c(4.55386, -13.0056, 4.15466, -11.9424): 31.35883  -86.98317   70.37316 -217.06454. Does not make a difference
ci_opt_t <- co_infection_opt_alt(parameters_cr = c(4.55386, -13.0056, 4.15466, -11.9424),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "t",
                             cue_2 = "t",
                             cue_range_1 = time_range,
                             cue_range_2 = time_range,
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")

# I (kin-disrimination)
ci_opt_I_none <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "I1",
                             cue_2 = "I2",
                             cue_range_1 = I_range_none,
                             cue_range_2 = I_range_none,
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")

# I log (kin discrimination)
ci_opt_I_log <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "I1",
                             cue_2 = "I2",
                             cue_range_1 = I_range_log,
                             cue_range_2 = I_range_log,
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")

# I (combined)
ci_opt_Ic_none <- co_infection_opt_do(parameters_cr = rep(0.5, 4),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "I1+I2",
                             cue_2 = "I1+I2",
                             cue_range_1 = I_range_none,
                             cue_range_2 = I_range_none,
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none",
                             neg = T)

# I log (combined)
ci_opt_Ic_log <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "I1+I2",
                             cue_2 = "I1+I2",
                             cue_range_1 = I_range_log,
                             cue_range_2 = I_range_log,
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")

# Ig (kin discrimination)
ci_opt_Ig_none <- co_infection_opt_alt(parameters_cr = c(59.08092, -101.28757,  -30.07456,  -76.75252),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "Ig1",
                             cue_2 = "Ig2",
                             cue_range_1 = I_range_none,
                             cue_range_2 = I_range_none,
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")

# Ig log (kin discrimination)
ci_opt_Ig_log <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "Ig1",
                             cue_2 = "Ig2",
                             cue_range_1 = I_range_log,
                             cue_range_2 = I_range_log,
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")

# Ig (combined)
ci_opt_Igc_none <- co_infection_opt_alt(parameters_cr = c(4.707722, -1821.744619,   420.111232,    25.925959),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "Ig1+Ig2",
                             cue_2 = "Ig1+Ig2",
                             cue_range_1 = I_range_none,
                             cue_range_2 = I_range_none,
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")


# I+Ig (kin discrimination)
ci_opt_Ig_I_none <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "I1+Ig1",
                             cue_2 = "I2+Ig2",
                             cue_range_1 = I_range_none,
                             cue_range_2 = I_range_none,
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")

# I+Ig log (kin discrimination)
ci_opt_I_Ig_log <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "I1+Ig1",
                             cue_2 = "I2+Ig2",
                             cue_range_1 = I_range_log,
                             cue_range_2 = I_range_log,
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")

# sum (I1+I2+Ig1+Ig2) 
ci_opt_sum_none <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "sum",
                             cue_2 = "sum",
                             cue_range_1 = I_range_none,
                             cue_range_2 = I_range_none,
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")

# sum log (I1+I2+Ig1+Ig2) 
ci_opt_sum_log <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "sum",
                             cue_2 = "sum",
                             cue_range_1 = I_range_log,
                             cue_range_2 = I_range_log,
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")

# G (kin discrimination)
ci_opt_G_none <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "G1",
                             cue_2 = "G2",
                             cue_range_1 = G_range_none,
                             cue_range_2 = G_range_none,
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")

# G log (kin discrimination)
ci_opt_G_log <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "G1",
                             cue_2 = "G2",
                             cue_range_1 = G_range_log,
                             cue_range_2 = G_range_log,
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")

# G (combined)
ci_opt_Gc_none <- co_infection_opt_do(parameters_cr = rep(0.5, 4),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "G1+G2",
                             cue_2 = "G1+G2",
                             cue_range_1 = G_range_none,
                             cue_range_2 = G_range_none,
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none",
                             neg = T)

# RBC
ci_opt_R_none <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "R",
                             cue_2 = "R",
                             cue_range_1 = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000),
                             cue_range_2 = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000),
                             solver = "vode",
                             log_cue_1 = "none",
                             log_cue_2 = "none")

# RBC log
ci_opt_R_log <- co_infection_opt_alt(parameters_cr = rep(0.5, 4),
                             limit = limit,
                             model = chabaudi_ci_clean,
                             immunity = "tsukushi",
                             parameters = parameters_tsukushi,
                             time_range = time_range,
                             cue_1 = "R",
                             cue_2 = "R",
                             cue_range_1 = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000),
                             cue_range_2 = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000),
                             solver = "vode",
                             log_cue_1 = "log10",
                             log_cue_2 = "log10")
```

### Model validation
```{r}
# import in ci optimum for same cue and join with cue range
ci_opt.df <- read.csv(here("data/ci_opt.csv"))
cue_range.df <- read.csv(here("data/cue_range_ci.csv"))

ci_opt.df2 <- left_join(ci_opt.df, cue_range.df, by= c("id", "cue", "log"))

# split
ci_opt.ls <- split(ci_opt.df2, seq(nrow(ci_opt.df2)))

# iterate and validate
ci_opt.ls <- lapply(ci_opt.ls, validate_ci)

# read in the results file
ci_val.ls <- list.files(path = here("data/ci_validation"), pattern = "*.csv", full.names = T)
ci_val.ls2 <- lapply(ci_val.ls, read.csv)
ci_val.df <- do.call(rbind, ci_val.ls2)

# Here, we are competing strain 1 (adopting supposed optimum strategy) with strain 2 adopting a randomized strategy. Hence, we expect fitness difference to be above 1!
ci_val.df %>% 
  group_by(label) %>% 
  summarize(min_fitness = min(V1))
```

# Dual cue optimization
```{r}
# impport in single infection optimization dataframe
si_opt.csv <- read.csv(here("data/si_opt.csv"))

#W get all unique combinations but eliminating all combinations that uses the same cue
dual_cue.df <- expand.grid(si_opt.csv$id, si_opt.csv$id) %>% 
  filter(Var1 != Var2) %>% 
  left_join(select(si_opt.csv, cue1 = cue, id), by = c("Var1" = "id")) %>% 
  left_join(select(si_opt.csv, cue2 = cue, id), by = c("Var2" = "id")) %>% 
  filter(cue1 != cue2) %>% 
  mutate(temp = paste(pmin(Var1, Var2), pmax(Var1, Var2))) %>% 
  distinct(temp, .keep_all = T) # get rid of the same cue combination but just in different orders

# get cue range (500 divisons)
cue_range_alt <- read.csv(here("data/cue_range_si_alt.csv"))
dual_cue.df2 <- dual_cue.df %>% 
  left_join(cue_range_alt, by = c("Var1" = "id")) %>% 
  left_join(select(cue_range_alt, cue_b = cue, log_b = log, low_b = low, high_b = high, by_b = by, id_b = id, label_b = label), by = c("Var2" = "id_b"))

# split table into rows
dual_cue.ls <- split(dual_cue.df2, seq(nrow(dual_cue.df2)))

# run optimization
lapply(dual_cue.ls, dual_cue_opt)
```

# Phase-mapping of laboratory mice infection
### Importing in data downloaded from Dryad
```{r}
# import in https://academic.oup.com/emph/article/2018/1/127/5045871?login=true
## (2018 published in EMPH)
emph_2018 <- readxl::read_xls(here("experimental_data/Huijben_2018_EMPH.xls"), sheet = 1)

# import in https://onlinelibrary.wiley.com/doi/10.1111/j.1558-5646.2010.01068.x
## (2010 published in Evolution)
evo_2010 <- readxl::read_xls(here("experimental_data/Huijben_2010_evolution.xls"), sheet = 1)

# import in https://journals.plos.org/plospathogens/article?id=10.1371/journal.ppat.1003578#:~:text=The%20philosophy%20is%20that%20aggressive,longer%20feel%20sick%20%5B13%5D.
## (2013 in PLoS pathogen)
plos_2013_1 <- readxl::read_xlsx(here("experimental_data/Huijben_2013_PLoS.xlsx"), sheet = 2)

plos_2013_2 <- readxl::read_xlsx(here("experimental_data/Huijben_2013_PLoS.xlsx"), sheet = 3)

# import in https://onlinelibrary.wiley.com/doi/10.1111/j.1420-9101.2011.02369.x
## (2011 in Journal of Evolutionary Biology)
eseb_2011 <- readxl::read_xls(here("experimental_data/Huijben_2011_eseb.xls"), sheet = 1)

# PRIVATE database!! This will not  be available! import in https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3939351/
## (2011 in Journal of American naturalist)
amna_2011 <- readxl::read_xls(here("experimental_data/Pollitt_2011_naturalist.xls"), sheet = 1)
```

### clean data for single infection
```{r}
## for EMPH 2018 study, include only infection series without drugs were R-inoculum is administered by itself, which includes 6, 7, 8, 9, 10. Box 6 has a starting inoculum number of 10^6, which is most similar to other studies. Filtering between day 3-21 because those are the days where we have single day data.
emph_2018_ss.df <- emph_2018 %>% 
  filter(Box %in% seq(6, 10) &
         dplyr::between(Day, 3, 21)) %>% 
  mutate(dose = case_when(
    Box == 6 ~ 10^6,
    Box == 7 ~ 10^5,
    Box == 8 ~ 10^3,
    Box == 9 | Box == 10 ~ 10^1
  )) %>% 
  mutate(strain = "As6p",
         study = "emph2018",
         study_strain = paste0(strain, study),
         id = paste0(study, strain, Box, Mouse, 1),
         RBC = RBC * (10^6)) %>%
  select(day = Day,
         mouse = Mouse, 
         RBC, 
         asex = Rasex,
         gam = Rgam,
         dose,
         strain,
         study,
         study_strain,
         id)

## for 2011 eseb, only day 3-17 data are analyzed because those are the days where gametocyte data are available
eseb_2011_ss.df <- eseb_2011 %>% 
  filter(Clones == "R" & between(Day, 3, 17) &
           Drugs == "N") %>% 
  mutate(dose = 10^6,
         strain = "As8p",
         study = "eseb2011",
         study_strain = paste0(strain, study),
         RBC = RBC*(10^6),
         id = paste0(study, strain, Box, Mouse, 2)) %>% 
  select(day = Day,
         mouse = Mouse,
         RBC,
         asex = R.asex,
         gam = R.gam,
         dose,
         strain,
         study,
         study_strain,
         id)

## for evolution_2010, single infection data for both resistant and susceptible clones are available without drug treatment
evolution_2010_ss.df <- evo_2010 %>% 
  filter(Clone == "R" | Clone == "S") %>%
  filter(between(Day, 3, 21) &
           Drugs == "nodrugs") %>% 
  mutate(asex = R.asex + S.asex,
         gam = R.gam + S.gam,
         dose = 10^6,
         RBC = RBC*(10^6),
         study = "evol2011",
         strain = ifelse(Clone == "R", "As12", "AJ51"),
         study_strain = paste0(strain, "_", study),
         id = paste0(study, strain, Box, Mouse, 3)) %>% 
  select(day = Day,
         mouse = Mouse,
         RBC,
         asex,
         gam,
         dose,
         strain,
         study,
         study_strain,
         id)

## for amnat 2011, get single infection data. Filter out any mice that have missing data. Set negative asexual data ot 0
amna_2011_ss.df <-  amna_2011 %>% 
  filter(treat %in% c("AJ", "AS", "ER", "CR", "CW", "DK")) %>% 
  mutate(asex = tot.para - tot.gcyte,
         gam = tot.gcyte,
         dose = 10^6,
         study = "amna_2011",
         RBC = rbc/(10^6),
         study_strain = paste0(treat, "_", study),
         id = paste0(study, treat, div, mouse, 4)) %>% 
  mutate(asex = ifelse(asex < 0, 0, asex)) # sometimes total parasite is less than gametocyte so need to correct for this

### check for NA by groups
amna_na.id <- amna_2011_ss.df %>% 
  filter_at(vars(asex, gam, RBC), all_vars(is.na(.))) %>% 
  distinct(id) %>% 
  select(id)

amna_2011_ss.df2 <- amna_2011_ss.df %>% 
  filter(!(id %in% amna_na.id$id)) %>% 
  select(day,
         mouse,
         RBC,
         asex,
         gam,
         dose,
         strain = treat,
         study,
         study_strain,
         id)

# rbind
exp_ss.df <- rbind(emph_2018_ss.df, eseb_2011_ss.df, evolution_2010_ss.df, amna_2011_ss.df2)

# correct RBC to actual density (in unit of RBC/uL)
exp_ss_dose.df <- exp_ss.df %>% filter(dose == 10^6) 

# add logged parameters
exp_ss_dose.df <- exp_ss_dose.df %>% 
  mutate(log10_asex = log10(asex+1),
         log10_RBC = log10(RBC+1),
         log10_gam = log10(gam+1))

# get dataset with only resistance strain
exp_ss_R.df <- exp_ss_dose.df %>% filter(strain != "AJ51")
```

# Co-infection competition
### Static competition
Here, both strains adopt the optimal co-infection strategy for their respective cues. The strains are not permitted to alter their reaction norm.
```{r}
# import in co-infection optimal dataframe and cue range
ci_opt.df <- read.csv(here("data/ci_opt.csv"))
cue_range.df <- read.csv(here("data/cue_range_ci.csv"))

# join the two dataframes
ci_opt.df2 <- left_join(ci_opt.df, cue_range.df, by= c("id", "cue", "log"))

# get all pairwise combinations of cues
ci_cue_pair.df <- ci_opt.df2 %>% 
  setNames(paste0(names(ci_opt.df2), '_2')) %>% # add 2 infront of all col names
  tidyr::crossing(ci_opt.df2, .name_repair = "check_unique") %>% 
  janitor::clean_names()

# keep only unique pairwise combinations
ci_cue_pair.df2 <- ci_cue_pair.df[!duplicated(apply(select(ci_cue_pair.df, id, id_2), 1, function(x) paste(sort(x),collapse=''))),]

# split to list
ci_cue_pair.ls <- split(ci_cue_pair.df2, seq(nrow(ci_cue_pair.df2)))

# parallelized lapply
ci_static <- mclapply(ci_cue_pair.ls, ci_comp_static)
ci_static.df <- data.frame(do.call(rbind, lapply(ci_static, unlist)))
names(ci_static.df) <- c("id_1", "id_2", "fitness_1", "fitness_2")
ci_static.df$fitness_1 <- as.numeric(ci_static.df$fitness_1)
ci_static.df$fitness_2 <- as.numeric(ci_static.df$fitness_2)

# write file
write.csv(ci_static.df, here("data/ci_static.csv"))
```

### Invasive competition
Here, the resident strain maintains a constant optimal co-infection strategy while the invader is allowed to "mutate" and optimize their strategy to increase the fitness difference between it and the resident strain.
```{r}
# do all pairwise cue combinations except for those of the same id
ci_cue_pair.df3 <- ci_cue_pair.df %>% filter(id != id_2)

# split dataframe into row based list
ci_cue_pair.ls3 <- split(ci_cue_pair.df3, seq(nrow(ci_cue_pair.df3)))

# run invasion analysis
lapply(ci_cue_pair.ls3, ci_invasion_analysis)
```

# Partitioning analysis
```{r}
# import in optimized df
si_opt.df <- read.csv(here("data/si_opt.csv"))

# join with cue_range
cue_range_si.df <- read.csv(here("data/cue_range_si.csv"))
si_opt.df <- si_opt.df %>% left_join(select(cue_range_si.df, low, high, by, id), "id")

# lapply loop to reoptimize
si_opt.ls <- split(si_opt.df, seq(nrow(si_opt.df)))
lapply(si_opt.ls, partition_si)
```

# Semi-stochastic single infection model
Here, we are going to perform 5000 Monte Carlo simulations where the parasite is adopting the optimal single infection strategy with all six random variables. For each run, the values of these random variables is drawn from a log normal distribution. Thus, while the variable value remains constant through out the simulation, each run will likely have a different set of parameters describing host immunity, parasite burst size, and RBC regeneration speed. To partition the contribution of each random variable to the overall effect on infection outcomes, we will perform Monte Carlo simulations where only one random variable is present during each run. 

### All six parameters vary
#### Asexual iRBC
```{r}
# non-logged
mc_I.res <- mc_five(par = c(0.1135384,  -39.0585154, 1941.9082813,  119.8228980),
                    cue = "I",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none")

write.csv(mc_I.res[[1]], here("data/MC2/mc_I_fitness.csv"))
write_parquet(mc_I.res[[3]], here("data/MC2/mc_I_dyn.parquet"))

# logged
mc_I_log.res <- mc_five(par = c(5.463558,   2.383948, -17.757281,   4.571835),
                    cue = "I",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10")

write.csv(mc_I_log.res[[1]], here("data/MC2/mc_I_log_fitness.csv"))
write_parquet(mc_I_log.res[[3]], here("data/MC2/mc_I_log_dyn.parquet"))
```

#### Sexual iRBC
```{r}
# non-logged
mc_Ig.res <- mc_five(par = c(0.05234791,  -46.03368629, 1897.61313455,   70.57689145),
                    cue = "Ig",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none")

write.csv(mc_Ig.res[[1]], here("data/MC2/mc_Ig_fitness.csv"))
write_parquet(mc_Ig.res[[3]], here("data/MC2/mc_Ig_dyn.parquet"))

# logged
mc_Ig_log.res <- mc_five(par = c(1.74633, -1.78582, -5.52834, 1.57344 ),
                    cue = "Ig",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10")

write.csv(mc_Ig_log.res[[1]], here("data/MC2/mc_Ig_log_fitness.csv"))
write_parquet(mc_Ig_log.res[[3]], here("data/MC2/mc_Ig_log_dyn.parquet"))
```

#### iRBC
```{r}
mc_I_Ig.res <- mc_five(par = c(0.3159297,  -46.1104558, 1250.7529081,   -6.1982093),
                    cue = "I+Ig",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none")

write.csv(mc_I_Ig.res[[1]], here("data/MC2/mc_I_Ig_fitness.csv"))
write_parquet(mc_I_Ig.res[[3]], here("data/MC2/mc_I_Ig_dyn.parquet"))

mc_I_Ig_log.res <- mc_five(par = c(3.594042,   4.157744, -13.530672,   2.599905),
                    cue = "I+Ig",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10")

write.csv(mc_I_Ig_log.res[[1]], here("data/MC2/mc_I_Ig_log_fitness.csv"))
write_parquet(mc_I_Ig_log.res[[3]], here("data/MC2/mc_I_Ig_log_dyn.parquet"))
```

#### Gametocyte
```{r}
# non-logged
MC_G.res <- MC_five(par = c(0.04061288,   -9.31445958,   74.13015506, -431.59843638),
                    cue = "G",
                    cue_range = seq(0, 6*(10^4), (6*(10^4))/5000),
                    log= "none")

write.csv(mc_G.res[[1]], here("data/MC2/mc_G_fitness.csv"))
write_parquet(mc_G.res[[3]], here("data/MC2/mc_G_dyn.parquet"))


mc_G_log.res <- mc_five(par = c(1.211521, -3.936778,-1.312944, -1.285713),
                    cue = "G",
                    cue_range = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000),
                    log= "log10")

write.csv(mc_G_log.res[[1]], here("data/MC2/mc_G_log_fitness.csv"))
write_parquet(mc_G_log.res[[3]], here("data/MC2/mc_G_log_dyn.parquet"))
```

#### RBC
```{r}
mc_R.res <- mc_five(par = c(7.0976026,  30.1295151, -28.0565613,  -0.2788713),
                    cue = "R",
                    cue_range = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000),
                    log= "none")

write.csv(mc_R.res[[1]], here("data/MC2/mc_R_fitness.csv"))
write_parquet(mc_R.res[[3]], here("data/MC2/mc_R_dyn.parquet"))

mc_R_log.res <- mc_five(par = c(48.70772, 105.18882, -81.80625, -44.60051),
                    cue = "R",
                    cue_range = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000),
                    log= "log10")

write.csv(mc_R_log.res[[1]], here("data/MC2/mc_R_log_fitness.csv"))
write_parquet(mc_R_log.res[[3]], here("data/MC2/mc_R_log_dyn.parquet"))
```

### Only one parameter vary
```{r}
# I
## non-logged
get_par_MC(par = c(0.1135384,  -39.0585154, 1941.9082813,  119.8228980),
                    cue = "I",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none")

## logged
get_par_MC(par = c(5.463558,   2.383948, -17.757281,   4.571835),
                    cue = "I",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10")

# Ig
## non-logged
get_par_MC(par = c(0.05234791,  -46.03368629, 1897.61313455,   70.57689145),
                    cue = "Ig",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none")

## logged
get_par_MC(par = c(1.74633, -1.78582, -5.52834, 1.57344 ),
                    cue = "Ig",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10")

# I+Ig
## non-logged
get_par_MC(par = c(0.3159297,  -46.1104558, 1250.7529081,   -6.1982093),
                    cue = "I+Ig",
                    cue_range = seq(0, 6*(10^6), by = (6*(10^6))/5000),
                    log= "none")

## logged
get_par_MC(par = c(3.594042,   4.157744, -13.530672,   2.599905),
                    cue = "I+Ig",
                    cue_range = seq(0, log10(6*(10^6)), by = (log10(6*(10^6)))/5000),
                    log= "log10")
# G
## non-logged
get_par_MC(par = c(0.04061288,   -9.31445958,   74.13015506, -431.59843638),
                    cue = "G",
                    cue_range = seq(0, 6*(10^4), (6*(10^4))/5000),
                    log= "none")

## logged
get_par_MC(par = c(1.211521, -3.936778,-1.312944, -1.285713),
                    cue = "G",
                    cue_range = seq(0, log10(6*(10^4)), (log10(6*(10^4)))/5000),
                    log= "log10")
# R
## non-logged
get_par_MC(par = c(7.0976026,  30.1295151, -28.0565613,  -0.2788713),
                    cue = "R",
                    cue_range = seq((10^6), (10^7), by = ((10^7)-(10^6))/5000),
                    log= "none")

## logged
get_par_MC(par = c(48.70772, 105.18882, -81.80625, -44.60051),
                    cue = "R",
                    cue_range = seq(log10(10^6), log10(10^7), by = (log10(10^7)-log10(10^6))/5000),
                    log= "log10")
```

