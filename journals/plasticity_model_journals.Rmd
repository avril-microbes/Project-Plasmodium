---
title: "plasticity_model_journal"
output: html_document
---

# Load libraries
```{r}
library(deSolve)
library(splines)
library(optimParallel)
library(ggplot2)
library(ggpubr)
library(tidyr)
library(magrittr)
library(Rcpp)
library(microbenchmark)
```

# Load functions
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt.R")
source("par_to_df.R")
source("chabaudi_si_opt_cpp.R")
```

# Testing single infection model chabaudi_si_opt
See if results matches original script. It does!
```{r}
# define arguments
parameters_cr <- c(1,2,3,4)
parameters <- c(R1 = 8.5*10^6,
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 4*10^-6,
                alpha = 1, 
                alphag = 2, 
                beta = 10, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1)

time_range <- seq(0, 20, by = 1e-3)
cue_range <- seq(0, (3.7*10^5)*(8.5*10^6)/((3.7*10^5)-0.025*(8.5*10^6)), by = 1000) 

# Run model
## Name = parasite_infection(single/co-infection)_immunity_cue_infectiontimeperiod.opt
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_ni_I_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt, 
                      control = list(trace = 6),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)

stopCluster(cl) #1.543123 -309.396705  -25.689852    2.609319
end.time <- Sys.time()

time.taken <- end.time - start.time 
time.taken #12.18853 minutes

#setwd("/Users/avrilwang/Desktop/Project_Plasmodium/opt_parm")
#write.csv(ch_si_ni_i_20.opt$par, "ch_si_ni_i_20.csv")

# visualizing conversion rate across cue range
## convert parameter values to dataframe 
ch_si_ni_I_20_cr.df <- par_to_df(ch_si_ni_i_20.opt, cue_range)

## plot!
ch_si_ni_I_20_cr.df %>% 
    gather(key = "optimization_methods", value = "Transmission_investment", -cue_range) %>%
    ggplot(aes(x = cue_range, y = model)) +
    geom_line(alpha = 0.7) +
    xlab("Infected RBC density") +
    ylab("Transmission investment") +
  xlim(0,400000) +
    labs(color = "Optimization methods") +
    theme_bw()
```

# Testing chabaudi single infection model to see whether host immunity modulates optimal conversion rate strategy
```{r}
# run model for 20 days with immunity. Conversion rate still dependent on infected RBC density

## very slow at its current state.
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)

stopCluster(cl) #1.769660 -363.080884  -37.980378    1.827227
#setwd("/Users/avrilwang/Desktop/Project_Plasmodium/opt_parm")
#write.csv(ch_si_i_I_20.opt$par, "ch_si_i_I_20.csv")

# visualize
ch_si_i_I_20_cr.df <- par_to_df(ch_si_i_I_20.opt, cue_range)
ch_si_i_I_20_cr.df %>% 
    ggplot(aes(x = cue_range, y = model)) +
    geom_line(alpha = 0.7) +
    xlab("Infected RBC density") +
    ylab("Transmission investment") +
    xlim(0, 500000)+
    labs(color = "Optimization methods") +
    theme_bw()

ch_si_ni_I_20_cr.df %>% 
    ggplot(aes(x = cue_range, y = model)) +
    geom_line(alpha = 0.7) +
    xlab("Infected RBC density") +
    ylab("Transmission investment") +
    xlim(0, 500000)+
    labs(color = "Optimization methods") +
    theme_bw()

# seems to have earlier convesion rate rise with immunity
ch_si_i_I_20.opt$par
ch_si_ni_i_20.opt$par
```

# integrating C++ to speed up calculation
## test out whether using splines 2 bSpline will be faster. Nope!
## streamlined cr function section. much faster
```{r}
# get alternative y value
dummy_y.vals <- rep(0, length(cue_range)) 
# bind to make dummy data
dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
# fit basic spline with no internal knots. Here, increasing df increases knots
dummy_cr.mod <- lm(dummy_y.vals ~ bSpline(cue_range, degree = 3, df = 3))
# specify coefficient, or the way individual splines are multiplicated. Numberof parameters = d+k+1, or degree of freedom (shape of basis sline) + number of knots (0) here + 1.
dummy_cr.mod $coefficients <- c(1,2,3,4)
cr_fit <- exp(-exp(predict(dummy_cr.mod, newdata = data.frame(cue_range))))
cr2 <- splinefun(data.frame(cue_range, cr_fit))

# same as original cr function output
all.equal(cr, cr2)

# testing whether models run or not
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_ni_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)
stopCluster(cl) #1.543123 -309.396705  -25.689852    2.609319. Same as before
end.time <- Sys.time()

time.taken <- end.time - start.time 
time.taken #7.009973 minutes much faster. Compared to 12 minutes, much faster!
```

# testing after removing with list
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_cpp.R")

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_ni_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)
stopCluster(cl) #1.543123 -309.396705  -25.689852    2.609319
end.time <- Sys.time()
time.taken <- end.time - start.time 
time.taken #6.350481. Not sure whether this is much better or due to diff between programs
```

# changed method of solver to lsoda
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_cpp.R")

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_ni_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)
ch_si_i_ni_20.opt$par
stopCluster(cl) #1.543123 -309.396705  -25.689852    2.609319
end.time <- Sys.time()
time.taken <- end.time - start.time 
time.taken #6.533385. not too different
```

## testing with immunity function
## very slow with base integrate or integral from pracma
## investigating where the bottle neck is
```{r}

  df <- 3
  #-------------------------#
  # Define initial condition
  #------------------------#
  state <- c(R = 8.5*10^6,
             I = 43.85965,
             Ig = 0,
             M = 0,
             G = 0)
  
  #-------------------------#
  # Function to describe population 
  # structure of initial inoculum
  #------------------------#
  pulseBeta <- function(I0, sp, t){ 
    res = rep(NA, length(t))
    for (num in 1:length(t)){
      res[num] = I0*(dbeta(t[num], sp, sp))
    }
    return(res)}
  
  #-------------------------#
  # Define conversion rate function. 
  # Simplified to increase performance. 
  #------------------------#
  ## Define dummy data of conversion rate
  dummy_y.vals <- rep(0, length(cue_range)) 
  dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
  
  ## fit basic cubic spline with no internal knots. Here, increasing df increases knots.
  ## degree defines shape of basis spline. This shouldn't have any impact on ultimate result
  ## What matter is the number of knots, or df. Increasing df should give us more complex reaction norm
  dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(cue_range, degree = 3, df = df))
  dummy_cr.mod$data <- dummy_cr.data
  
  ## Assign coefficient to be optimized to the dummy conversion rate function
  dummy_cr.mod$coefficients <- parameters_cr
  
  ## use spline function to predict cr 
  cr_fit <- exp(-exp(predict(dummy_cr.mod, newdata = data.frame(cue_range))))
  
  ## Get spline function where cr ~ cue
  cr <- splinefun(cbind(cue_range, cr_fit))
  
  # define trapezoid function for estimation survival curve
  trapezoid <- function(f, lower, upper) {
  if (is.function(f) == FALSE) {
    stop('f must be a function with one parameter (variable)')
  }
  h <- upper - lower
  fxdx <- (h / 2) * (f(lower) + f(upper))
  return(fxdx)}
  
  #-------------------------#
  # Define single-infection model
  #------------------------#
   single_infection.fun <- function(t, state, parameters) {
      
      ## Define the lag terms. lag[1] = R, lag[2] = I, lag[3] = Ig, lag[4] = M, lag[5] = G
      if(t>parameters["alpha"]){lag1 = deSolve::lagvalue(t-parameters["alpha"])} # lag state for asexual development
      if(t>parameters["alphag"]){lag2 = deSolve::lagvalue(t-parameters["alphag"])} # lag state for gametocyte development
      
      ## get lag term index given cue
      lag.i <- match(cue, names(state))
      
      ## convert cue to variable in state
      cue_state <- state[cue]
      
      ## Define K, carrying capacity of RBC
      K <- parameters["lambda"]*parameters["R1"]/(parameters["lambda"]-parameters["mu"]*parameters["R1"])
      
      ## Define survival functions
      ### Survival of infected asexual RBC
      if(t>parameters["alpha"] && immunity == "ni"){
        S <- exp(-parameters["mu"]*parameters["alpha"])
      } else if(t>parameters["alpha"] && immunity =="i"){
        integrand <- function(x) {parameters["mu"]+parameters["a"]/(parameters["b"]+state["I"])}
        integrate_val <- trapezoid(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)
        S <- exp(-1*integrate_val)
      } else if(t<=parameters["alpha"] && immunity == "ni"){
        S <- exp(-parameters["mu"]*t)
      } else{
        integrand <- function(x) {parameters["mu"]+parameters["a"]/(parameters["b"]+state["I"])}
        integrate_val <- trapezoid(Vectorize(integrand), lower = 0, upper = t)
        S <- exp(-1*integrate_val)
      }
      
      ### Survival of gametocytes. We assume that infected
      ### RBC with gametocyte is not removed by immune response
      if(t<=parameters["alphag"]){
        Sg <- exp(-parameters["mu"]*t)
      } else{
        Sg <- exp(-parameters["mu"]*parameters["alphag"])}
      
      ## Define the models without lag terms. 
      dR <- parameters["lambda"]*(1-state["R"]/K)-parameters["mu"]*state["R"]-parameters["p"]*state["R"]*state["M"] # change in susceptible RBC
      if(immunity == "ni"){
        dI_nolag <- (1-cr(cue_state))*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["I"] # change in infected RBC density
      } else{
        dI_nolag <- (1-cr(cue_state))*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["I"]-(parameters["a"]*state["I"])/(parameters["b"]+state["I"]) # change in infected RBC density with immunity
      }
      dIg_nolag <- cr(cue_state)*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["Ig"] 
      dM_nolag <- -parameters["mum"]*state["M"]-parameters["p"]*state["R"]*state["M"]
      dG_nolag <- -parameters["mug"]*state["G"]
      
      ## Track states in initial cohort of infection
      if(t<=parameters["alpha"]){
        dI <- dI_nolag-pulseBeta(parameters["I0"], parameters["sp"], t)*S 
        dM <- dM_nolag+parameters["beta"]*pulseBeta(parameters["I0"], parameters["sp"], t)*S 
      }
      
      if(t<=parameters["alphag"]){
        dIg <- dIg_nolag-pulseBeta(parameters["Ig0"], parameters["sp"], t-1)*Sg 
        dG <- dG_nolag+pulseBeta(parameters["Ig0"], parameters["sp"], t-1)*Sg 
      }
      
      ## Track states after delay 
      if(t>parameters["alpha"]){
        dI <- dI_nolag-(1-cr(lag1[lag.i]))*parameters["p"]*lag1[1]*lag1[4]*S 
        dM <- dM_nolag+parameters["beta"]*(1-cr(lag1[lag.i]))*parameters["p"]*lag1[1]*lag1[4]*S 
      }
      
      if(t>parameters["alphag"]){
        dIg <- dIg_nolag-cr(lag2[lag.i])*parameters["p"]*lag2[1]*lag2[4]*Sg 
        dG <- dG_nolag+cr(lag2[lag.i])*parameters["p"]*lag2[1]*lag2[4]*Sg
      }
      
      ## Return the states
      return(list(c(dR, dI, dIg, dM, dG)))
  }

immunity <- "i"
cue <- "I"
  
# visualize where bottle neck with immunity run is. Integration is the greatest bottleneck 23000ms for integrate alone. Down to 11850 for trapezoid approximation
profvis::profvis({deSolve::dede(y = state, times = time_range, func = single_infection.fun, p = parameters, control=list(mxhist = 1e6))})

# trying lsoda
start.time <- Sys.time()
deSolve::dede(y = state, times = time_range, func = single_infection.fun, p = parameters, control=list(mxhist = 1e6), method = "lsoda")
end.time <- Sys.time()
end.time-start.time #31.42669 secs

# trying bdf
start.time <- Sys.time()
deSolve::dede(y = state, times = time_range, func = single_infection.fun, p = parameters, control=list(mxhist = 1e6), method = "bdf")
end.time <- Sys.time()
end.time-start.time #34.48703 secs'

# trying vode
start.time <- Sys.time()
deSolve::dede(y = state, times = time_range, func = single_infection.fun, p = parameters, control=list(mxhist = 1e6), method = "vode")
end.time <- Sys.time()
end.time-start.time #6.451089 
```

# testing the speed of different integrator
```{r}
# using stat integrate
t <- 10
integrand <- function(x) {parameters["mu"]+parameters["a"]/(parameters["b"]+state["I"])}
integrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$value

# cubature package. much slower
cubature::adaptIntegrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$integral

# pracma
pracma::integral(Vectorize(integrand), xmin = t-parameters["alpha"], xmax = t, method = "Kronrod")

# foreach
library(foreach)
foreach(i=1,.combine="c") %dopar%
{
  integrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$value;
}

# trapezoid estimation
trapezoid <- function(f, lower, upper) {
  if (is.function(f) == FALSE) {
    stop('f must be a function with one parameter (variable)')
  }
  h <- upper - lower
  fxdx <- (h / 2) * (f(lower) + f(upper))
  return(fxdx)
}

# composite trapezoid estimation
composite_trapezoid <- function(f, lower, upper, n) {
  if (is.function(f) == FALSE) {
    stop('f must be a function with one parameter (variable)')
  }
  h <- (upper - lower) / n
  j <- 1:n - 1
  xj <- lower + j * h
  approx <- (h / 2) * (f(lower) + 2 * sum(f(xj)) + f(upper))
  return(approx)
}

composite_trapezoid(Vectorize(integrand), lower = t-parameters["alpha"], upper = t, n = parameters["alpha"]/1e-3)

# Simpsin's rule
simpsons_rule <- function(f, lower, upper) {
  if (is.function(f) == FALSE) {
    stop('f must be a function with one parameter (variable)')
  }
  h <- (upper - lower) / 2
  x0 <- lower
  x1 <- lower + h
  x2 <- upper
  s <- (h / 3) * (f(x0) + 4 * f(x1) + f(x2))
  return(s)
}

simpsons_rule(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)

# pracma auadinf
pracma::quadinf(Vectorize(integrand), t-parameters["alpha"], t)$Q

# compare method speeds. Trapezoid fastest followed by Simpson's and R integrate
microbenchmark(integrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$value,
               cubature::adaptIntegrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$integral, foreach(i=1,.combine="c") %dopar%
{
  integrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$value;
},
pracma::integral(Vectorize(integrand), xmin = t-parameters["alpha"], xmax = t, method = "Kronrod"),
pracma::integral(Vectorize(integrand), xmin = t-parameters["alpha"], xmax = t, method = "Clenshaw"),
pracma::integral(Vectorize(integrand), xmin = t-parameters["alpha"], xmax = t, method = "Simpson"),
trapezoid(Vectorize(integrand), lower = t-parameters["alpha"], upper = t), 
composite_trapezoid(Vectorize(integrand), lower = t-parameters["alpha"], upper = t, n = parameters["alpha"]/1e-3), 
simpsons_rule(Vectorize(integrand), lower = t-parameters["alpha"], upper = t), 
pracma::quadinf(Vectorize(integrand), t-parameters["alpha"], t)$Q, times = 1000L)
```

# rerunning immunity model and calculate run time
```{r}
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_i_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)
ch_si_i_i_20.opt$par
stopCluster(cl) #1.769660 -363.080884  -37.980378    1.827227. Same as before
end.time <- Sys.time()
time.taken <- end.time - start.time 
time.taken #38.85414 (40 minutes!)
```

# optimizing pulsebeta function to vectorize
```{r}
# original pulse beta function
pulseBeta <- function(I0, sp, t){ 
    res = rep(NA, length(t))
    for (num in 1:length(t)){
      res[num] = I0*(dbeta(t[num], sp, sp))
    }
    return(res)}

# new pulse beta function
pulseBeta2 <- function(I0, sp, t){ 
    res = rep(NA, length(t))
    res = I0*(dbeta(t, sp, sp))
    }

# are they equal? Yes!
all.equal(pulseBeta2(48, 100, time_range), pulseBeta(48, 100, time_range))

# how should we call new function. Here dividng time by 1e-3 (time interval) and + 1 give us the proper index
test <- pulseBeta2(48, 100, time_range)
test[[(t/1e-3)+1]]

# plotting. We should see synchronous centering at 12 hours. Yes, it does
ggplot(data.frame(time_range, test)) +
  geom_line(aes(x = time_range, y = test)) +
  xlim(0,2)

# plotting asynchronous. All infected RBC must brst after 1 day. Matches up. 
ggplot(data.frame(time_range, test2 = pulseBeta2(48, 1, time_range))) +
  geom_line(aes(x = time_range, y = test2)) +
  xlim(0,2)
```

# testing new function that includes updated pulse-beta function and time-based cue
## without immunity, time-based. Looks good.
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_cpp.R")

# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_ni_t_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range)

stopCluster(cl) 
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken #13 minutes, down from 40 minutes in original run and from 20 minutes in first iteration
ch_si_ni_t_20.opt$par #6.2932211 -15.3891982   0.3197596 -11.3816705. Similar to Greischar model

# plot
ch_si_ni_t_20_cr.df <- par_to_df(ch_si_ni_t_20.opt, time_range)
```

## with immunity. Different! Greischar model had much later trnamission investment. 
### plotting the cumulutive transmission potential suggests that my model should be correct... By my model, Greischar;s optimal strategy produced lower cumulative transmission potential than the one I found.
```{r}
# with immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range)

stopCluster(cl) 
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken #58.7155 minutes. Very long with lsoda and integrate function
ch_si_i_t_20.opt$par #10.948894 -23.608461  -1.903851 -17.421159. SLightly different from Greischar's model wonder why.
ch_si_i_t_20.opt$value #-11.96688. 

## plotting
ch_si_i_t_20_cr.df <- par_to_df(ch_si_i_t_20.opt, time_range)
### get greischar model parameters
ch_si_i_t_20.opt_gre <- ch_si_i_t_20.opt
ch_si_i_t_20.opt_gre$par <- c(13.46, -27.66, -3.62, -20.24)
ch_si_i_t_20_cr_gre.df <- par_to_df(ch_si_i_t_20.opt_gre, time_range)

### similar directions but Greischar model had even more delayed transmission investment. 
ggplot() +
  geom_line(data = ch_si_i_t_20_cr.df, aes(x = time_range, y = model), alpha = 0.7, color = "blue") +
  geom_line(data = ch_si_i_t_20_cr_gre.df, aes(x = time_range, y = model), alpha = 0.7, color = "red") +
  geom_line(data = ch_si_ni_t_20_cr.df, aes(x = time_range, y = model), alpha = 0.7, color = "black") +
    xlab("Time") +
    ylab("Transmission investment") +
    labs(color = "Optimization methods") +
    theme_bw()

parameters
```

## getting transmission value cumulative form greischar's parameters 11.87644 in Greischar model. Smaller than ours. Different model or something?
```{r}
cue_range <- time_range
immunity <- "i"
cue <- "t"
df <- 3

state <- c(R = 8.5*10^6,
             I = 43.85965,
             Ig = 0,
             M = 0,
             G = 0)


  pulseBeta_fun <- function(I0, sp, t){ 
    res = rep(NA, length(t))
    res = I0*(dbeta(t, sp, sp))
  }
  
  #-------------------------#
  # Define conversion rate function. 
  # Simplified to increase performance. 
  #------------------------#
  ## Define dummy data of conversion rate
  dummy_y.vals <- rep(0, length(cue_range)) 
  dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
  
  ## fit basic cubic spline with no internal knots. Here, increasing df increases knots.
  ## degree defines shape of basis spline. This shouldn't have any impact on ultimate result
  ## What matter is the number of knots, or df. Increasing df should give us more complex reaction norm
  dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(cue_range, degree = 3, df = df))
  dummy_cr.mod$data <- dummy_cr.data
  
  ## Assign coefficient to be optimized to the dummy conversion rate function
  dummy_cr.mod$coefficients <- c(13.46, -27.66, -3.62, -20.24)
  
  ## use spline function to predict cr 
  cr_fit <- exp(-exp(predict(dummy_cr.mod, newdata = data.frame(cue_range))))
  
  ## Get spline function where cr ~ cue
  cr <- splinefun(cbind(cue_range, cr_fit))
  
  #-------------------------#
  # Define trapezoidal estimation 
  # for survival function approximation. Use this if speeding up model
  #------------------------#
  trapezoid <- function(f, lower, upper) {
    if (is.function(f) == FALSE) {
      stop('f must be a function with one parameter (variable)')
    }
    h <- upper - lower
    fxdx <- (h / 2) * (f(lower) + f(upper))
    return(fxdx)}
  
  #-------------------------#
  # Define single-infection model
  #------------------------#
  single_infection.fun <- function(t, state, parameters) {
    
    ## Defining Pulse beta function based on current time
    pulseBeta <- pulseBeta_fun(parameters["I0"], parameters["sp"], t)
      
      ## Define the lag terms. lag[1] = R, lag[2] = I, lag[3] = Ig, lag[4] = M, lag[5] = G
      if(t>parameters["alpha"]){lag1 = deSolve::lagvalue(t-parameters["alpha"])} # lag state for asexual development
      if(t>parameters["alphag"]){lag2 = deSolve::lagvalue(t-parameters["alphag"])} # lag state for gametocyte development
      
      ## get lag term index given cue
    ### Only get lag index when it is a state-based cue
    if(cue != "t") {
      lag.i <- match(cue, names(state))}
    
     ## convert cue to variable in state or just time
    if(cue == "t"){
      cue_state <- t}
    else{
      cue_state <- state[cue]}
    
    ### define lagged cue. Lag1 = alpha times ago, lag2 = alphag times ago
    if(t>parameters["alpha"] && cue == "t"){
      cue_lag1 <- t-parameters["alpha"]
    } 
    
    if(t>parameters["alpha"] && cue != "t"){
      cue_lag1 <- lag1[lag.i]
    } 
    
    if(t>parameters["alphag"] && cue == "t") {
      cue_lag2 <- t-parameters["alphag"]
    } 
    
    if(t>parameters["alphag"] && cue != "t") {
      cue_lag2 <- lag2[lag.i]
    }
      
      ## Define K, carrying capacity of RBC
      K <- parameters["lambda"]*parameters["R1"]/(parameters["lambda"]-parameters["mu"]*parameters["R1"])
      
      ## Define survival functions
      ### Survival of infected asexual RBC
      if(t>parameters["alpha"] && immunity == "ni"){
        S <- exp(-parameters["mu"]*parameters["alpha"])
      } else if(t>parameters["alpha"] && immunity =="i"){
        integrand <- function(x) {parameters["mu"]+parameters["a"]/(parameters["b"]+state["I"])}
        integrate_val <- integrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)
        S <- exp(-1*integrate_val$value)
      } else if(t<=parameters["alpha"] && immunity == "ni"){
        S <- exp(-parameters["mu"]*t)
      } else{
        integrand <- function(x) {parameters["mu"]+parameters["a"]/(parameters["b"]+state["I"])}
        integrate_val <- integrate(Vectorize(integrand), lower = 0, upper = t)
        S <- exp(-1*integrate_val$value)
      }
      
      ### Survival of gametocytes. We assume that infected
      ### RBC with gametocyte is not removed by immune response
      if(t<=parameters["alphag"]){
        Sg <- exp(-parameters["mu"]*t)
      } else{
        Sg <- exp(-parameters["mu"]*parameters["alphag"])}
      
      ## Define the models without lag terms. 
      dR <- parameters["lambda"]*(1-state["R"]/K)-parameters["mu"]*state["R"]-parameters["p"]*state["R"]*state["M"] # change in susceptible RBC
     
       if(immunity == "ni"){
        dI_nolag <- (1-cr(cue_state))*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["I"] # change in infected RBC density
      } else{
        dI_nolag <- (1-cr(cue_state))*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["I"]-(parameters["a"]*state["I"])/(parameters["b"]+state["I"]) # change in infected RBC density with immunity
      }
      
      dIg_nolag <- cr(cue_state)*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["Ig"] 
      dM_nolag <- -parameters["mum"]*state["M"]-parameters["p"]*state["R"]*state["M"]
      dG_nolag <- -parameters["mug"]*state["G"]
      
      ## Track states in initial cohort of infection
      if(t<=parameters["alpha"]){
        dI <- dI_nolag-pulseBeta*S 
        dM <- dM_nolag+parameters["beta"]*pulseBeta*S 
      }
      
      if(t<=parameters["alphag"]){
        dIg <- dIg_nolag ## should have no cells form initial cohort
        dG <- 0
      }
      
      ## Track states after delay 
      if(t>parameters["alpha"]){
        dI <- dI_nolag-(1-cr(cue_lag1))*parameters["p"]*lag1[1]*lag1[4]*S 
        dM <- dM_nolag+parameters["beta"]*(1-cr(cue_lag1))*parameters["p"]*lag1[1]*lag1[4]*S 
      }
      
      if(t>parameters["alphag"]){
        dIg <- dIg_nolag-cr(cue_lag2)*parameters["p"]*lag2[1]*lag2[4]*Sg 
        dG <- dG_nolag+cr(cue_lag2)*parameters["p"]*lag2[1]*lag2[4]*Sg
      }
      
      ## Return the states
      return(list(c(dR, dI, dIg, dM, dG)))
  }
  
  #-------------------------#
  # Run single-infection model
  #------------------------#
  single_infection.df <- as.data.frame(deSolve::dede(y = state,
                                                     times = time_range,
                                                     func = single_infection.fun,
                                                     p = parameters,
                                                     method = solver,
                                                     control=list(mxhist = 1e6)))
  
#-------------------------#
  # Calculate fitness
  #------------------------#
  ## Get Gametocyte density time series data
  gam <- single_infection.df$G
  gam[gam<0] <- 0 # Assign negative gametocyte density to 0
  
  ## Get timeseries interval. Simplify first time after t=0
  int <- single_infection.df[2,1]
  
  ## Define the fitness parameter values
  aval <- -12.69
  bval <- 3.6
  dens <- log10(gam)
  
  ## Calculate the transmission potential at each time t
  tau.ls <- (exp(aval+bval*dens))/(1+exp(aval+bval*dens))
  
  ## Get approximation of cumulative transmission potential
  tau.sum <- sum(tau.ls*int)
  tau.cumsum <- cumsum(tau.ls*int)
  tau.sum
```

## check infection dynamics to see if same model.Seems to be the case...
```{r}
# tau cumulative sum. Looks very similar
ggplot(data.frame(time_range, tau.cumsum)) +
  geom_line(aes(time_range, tau.cumsum))

# plotting other stuff
single_infection.df2 <- single_infection.df %>% gather(key = "variable", value = "value", -time)

ggplot(single_infection.df2, aes(x = time, y = value)) +
  geom_line() +
  facet_wrap(~variable, scales = "free") +
  scale_y_continuous(labels = scales::scientific) +
  theme_bw()
```

## double check this is the case. I changed some stuff, fixed the conditional lag cue code. So rerun the code
### run with immunity
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_cpp.R")

# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.opt2 <- optimParallel(par = c(13, -25, -3, -20), # get it close so it runs faster
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range)

stopCluster(cl) 
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken # 31.47385 mins taken
ch_si_i_t_20.opt2$par #10.948492 -23.607393  -1.904272 -17.419994. Same as before. Sigh...

single_function.fun
```

## run with immunity + trapezoidal estimation for integration
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.opt_trap <- optimParallel(par = c(13, -25, -3, -20), # get it close so it runs faster
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range,
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #22.84097 minutes. Done from 31 minutes with integrate.
ch_si_i_t_20.opt_trap$par #10.94948 -23.60937  -1.90456 -17.42204 (very similar. insignificant difference)
```

## run with immunity + trapezoid+vode integration. Fastest run so far. 
```{r}
# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.opt_trap_vode <- optimParallel(par = c(13, -25, -3, -20), # get it close so it runs faster
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range,
                      integration = "trapezoid",
                      solver = "vode")
stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time # 6.682592 minutes. very fast
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.opt_trap_vode$par #10.947226 -23.605154  -1.902684 -17.423413 (very similar)
```

# fix death rate from immune response
## trying out other forms of immunity removal integration
```{r}
# calculate immune reaction based on non-immunity model
immune <- parameters["a"]/(parameters["b"]+single_infection.df$I)
immune_dummy <- data.frame(time_range, immune)
## calculate cumulative immune hazard rate for each time t (from t-alpha to t)
immune_dummy.df <- immune_dummy %>%
  mutate(cumsum = cumsum(immune)) %>%
  mutate(cum_rolling1000 = zoo::rollapplyr(immune*1e-3, width = 1000, FUN = sum, partial = TRUE)) %>%
  drop_na(cumsum)

# trying definite integral function
def_int <- data.frame(time_range, immune =(parameters["alpha"]*parameters["a"])/(parameters["b"]+single_infection.df$I))

# trying laplace
laplace <- data.frame(time_range, immune = (parameters["a"]*log10(single_infection.df$time+parameters["b"])-2*log10(single_infection.df$time-parameters["alpha"]))/single_infection.df$I)

# plotting. Definitive integral seem to match up pretty good. Of course...
ggplot() +
  geom_line(data = immune_dummy.df, aes(x = time_range, y = cum_rolling1000), color = "blue") +
  geom_line(data = def_int, aes(x = time_range, y = immune), color = "red") +
  geom_line(data = laplace, aes(x = time_range, y = immune), color = "green") +
  xlim(1, 20) + #applies to only after alpha
  theme_bw() +
  ylim(0,3)

def_int
immune_dummy.df
```

## test out function with immunity as definitive integral
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.def_int <- optimParallel(par = c(13, -25, -3, -20), # get it close so it runs faster
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range,
                      solver = "vode")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time#2.391554 minutes fast!
ch_si_i_t_20.def_int$par # 10.94816 -23.60684  -1.90449 -17.41818. Very similar to integrate. lol....

par_to_df(ch_si_i_t_20.def_int, time_range) %>% 
  ggplot(aes(x = cue_range, y = model)) +
  geom_line()

```







