---
title: "plasticity_model_journal"
output: html_document
---

# Load libraries
```{r}
library(deSolve)
library(splines)
library(optimParallel)
library(ggplot2)
library(ggpubr)
library(tidyr)
library(magrittr)
library(Rcpp)
library(microbenchmark)
library(GA)
```

# Load functions
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt.R")
source("par_to_df.R")
source("chabaudi_si_opt_fast.R")
```

# Testing single infection model chabaudi_si_opt
See if results matches original script. It does!
```{r}
# define arguments
parameters_cr <- c(1,2,3,4)
parameters <- c(R1 = 8.5*10^6,
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 4*10^-6,
                alpha = 1, 
                alphag = 2, 
                beta = 10, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1)

time_range <- seq(0, 20, by = 1e-3)
cue_range <- seq(0, (3.7*10^5)*(8.5*10^6)/((3.7*10^5)-0.025*(8.5*10^6)), by = 1000) 

# Run model
## Name = parasite_infection(single/co-infection)_immunity_cue_infectiontimeperiod.opt
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_ni_I_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt, 
                      control = list(trace = 6),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)

stopCluster(cl) #1.543123 -309.396705  -25.689852    2.609319
end.time <- Sys.time()

time.taken <- end.time - start.time 
time.taken #12.18853 minutes

#setwd("/Users/avrilwang/Desktop/Project_Plasmodium/opt_parm")
#write.csv(ch_si_ni_i_20.opt$par, "ch_si_ni_i_20.csv")

# visualizing conversion rate across cue range
## convert parameter values to dataframe 
ch_si_ni_I_20_cr.df <- par_to_df(ch_si_ni_i_20.opt, cue_range)

## plot!
ch_si_ni_I_20_cr.df %>% 
    gather(key = "optimization_methods", value = "Transmission_investment", -cue_range) %>%
    ggplot(aes(x = cue_range, y = model)) +
    geom_line(alpha = 0.7) +
    xlab("Infected RBC density") +
    ylab("Transmission investment") +
  xlim(0,400000) +
    labs(color = "Optimization methods") +
    theme_bw()
```

# Testing chabaudi single infection model to see whether host immunity modulates optimal conversion rate strategy
```{r}
# run model for 20 days with immunity. Conversion rate still dependent on infected RBC density

## very slow at its current state.
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)

stopCluster(cl) #1.769660 -363.080884  -37.980378    1.827227
#setwd("/Users/avrilwang/Desktop/Project_Plasmodium/opt_parm")
#write.csv(ch_si_i_I_20.opt$par, "ch_si_i_I_20.csv")

# visualize
ch_si_i_I_20_cr.df <- par_to_df(ch_si_i_I_20.opt, cue_range)
ch_si_i_I_20_cr.df %>% 
    ggplot(aes(x = cue_range, y = model)) +
    geom_line(alpha = 0.7) +
    xlab("Infected RBC density") +
    ylab("Transmission investment") +
    xlim(0, 500000)+
    labs(color = "Optimization methods") +
    theme_bw()

ch_si_ni_I_20_cr.df %>% 
    ggplot(aes(x = cue_range, y = model)) +
    geom_line(alpha = 0.7) +
    xlab("Infected RBC density") +
    ylab("Transmission investment") +
    xlim(0, 500000)+
    labs(color = "Optimization methods") +
    theme_bw()

# seems to have earlier convesion rate rise with immunity
ch_si_i_I_20.opt$par
ch_si_ni_i_20.opt$par
```

# integrating C++ to speed up calculation
## test out whether using splines 2 bSpline will be faster. Nope!
## streamlined cr function section. much faster
```{r}
# get alternative y value
dummy_y.vals <- rep(0, length(cue_range)) 
# bind to make dummy data
dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
# fit basic spline with no internal knots. Here, increasing df increases knots
dummy_cr.mod <- lm(dummy_y.vals ~ bSpline(cue_range, degree = 3, df = 3))
# specify coefficient, or the way individual splines are multiplicated. Numberof parameters = d+k+1, or degree of freedom (shape of basis sline) + number of knots (0) here + 1.
dummy_cr.mod $coefficients <- c(1,2,3,4)
cr_fit <- exp(-exp(predict(dummy_cr.mod, newdata = data.frame(cue_range))))
cr2 <- splinefun(data.frame(cue_range, cr_fit))

# same as original cr function output
all.equal(cr, cr2)

# testing whether models run or not
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_ni_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)
stopCluster(cl) #1.543123 -309.396705  -25.689852    2.609319. Same as before
end.time <- Sys.time()

time.taken <- end.time - start.time 
time.taken #7.009973 minutes much faster. Compared to 12 minutes, much faster!
```

# testing after removing with list
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_cpp.R")

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_ni_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)
stopCluster(cl) #1.543123 -309.396705  -25.689852    2.609319
end.time <- Sys.time()
time.taken <- end.time - start.time 
time.taken #6.350481. Not sure whether this is much better or due to diff between programs
```

# changed method of solver to lsoda
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_cpp.R")

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_ni_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)
ch_si_i_ni_20.opt$par
stopCluster(cl) #1.543123 -309.396705  -25.689852    2.609319
end.time <- Sys.time()
time.taken <- end.time - start.time 
time.taken #6.533385. not too different
```

## testing with immunity function
## very slow with base integrate or integral from pracma
## investigating where the bottle neck is
```{r}

  df <- 3
  #-------------------------#
  # Define initial condition
  #------------------------#
  state <- c(R = 8.5*10^6,
             I = 43.85965,
             Ig = 0,
             M = 0,
             G = 0)
  
  #-------------------------#
  # Function to describe population 
  # structure of initial inoculum
  #------------------------#
  pulseBeta <- function(I0, sp, t){ 
    res = rep(NA, length(t))
    for (num in 1:length(t)){
      res[num] = I0*(dbeta(t[num], sp, sp))
    }
    return(res)}
  
  #-------------------------#
  # Define conversion rate function. 
  # Simplified to increase performance. 
  #------------------------#
  ## Define dummy data of conversion rate
  dummy_y.vals <- rep(0, length(cue_range)) 
  dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
  
  ## fit basic cubic spline with no internal knots. Here, increasing df increases knots.
  ## degree defines shape of basis spline. This shouldn't have any impact on ultimate result
  ## What matter is the number of knots, or df. Increasing df should give us more complex reaction norm
  dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(cue_range, degree = 3, df = df))
  dummy_cr.mod$data <- dummy_cr.data
  
  ## Assign coefficient to be optimized to the dummy conversion rate function
  dummy_cr.mod$coefficients <- parameters_cr
  
  ## use spline function to predict cr 
  cr_fit <- exp(-exp(predict(dummy_cr.mod, newdata = data.frame(cue_range))))
  
  ## Get spline function where cr ~ cue
  cr <- splinefun(cbind(cue_range, cr_fit))
  
  # define trapezoid function for estimation survival curve
  trapezoid <- function(f, lower, upper) {
  if (is.function(f) == FALSE) {
    stop('f must be a function with one parameter (variable)')
  }
  h <- upper - lower
  fxdx <- (h / 2) * (f(lower) + f(upper))
  return(fxdx)}
  
  #-------------------------#
  # Define single-infection model
  #------------------------#
   single_infection.fun <- function(t, state, parameters) {
      
      ## Define the lag terms. lag[1] = R, lag[2] = I, lag[3] = Ig, lag[4] = M, lag[5] = G
      if(t>parameters["alpha"]){lag1 = deSolve::lagvalue(t-parameters["alpha"])} # lag state for asexual development
      if(t>parameters["alphag"]){lag2 = deSolve::lagvalue(t-parameters["alphag"])} # lag state for gametocyte development
      
      ## get lag term index given cue
      lag.i <- match(cue, names(state))
      
      ## convert cue to variable in state
      cue_state <- state[cue]
      
      ## Define K, carrying capacity of RBC
      K <- parameters["lambda"]*parameters["R1"]/(parameters["lambda"]-parameters["mu"]*parameters["R1"])
      
      ## Define survival functions
      ### Survival of infected asexual RBC
      if(t>parameters["alpha"] && immunity == "ni"){
        S <- exp(-parameters["mu"]*parameters["alpha"])
      } else if(t>parameters["alpha"] && immunity =="i"){
        integrand <- function(x) {parameters["mu"]+parameters["a"]/(parameters["b"]+state["I"])}
        integrate_val <- trapezoid(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)
        S <- exp(-1*integrate_val)
      } else if(t<=parameters["alpha"] && immunity == "ni"){
        S <- exp(-parameters["mu"]*t)
      } else{
        integrand <- function(x) {parameters["mu"]+parameters["a"]/(parameters["b"]+state["I"])}
        integrate_val <- trapezoid(Vectorize(integrand), lower = 0, upper = t)
        S <- exp(-1*integrate_val)
      }
      
      ### Survival of gametocytes. We assume that infected
      ### RBC with gametocyte is not removed by immune response
      if(t<=parameters["alphag"]){
        Sg <- exp(-parameters["mu"]*t)
      } else{
        Sg <- exp(-parameters["mu"]*parameters["alphag"])}
      
      ## Define the models without lag terms. 
      dR <- parameters["lambda"]*(1-state["R"]/K)-parameters["mu"]*state["R"]-parameters["p"]*state["R"]*state["M"] # change in susceptible RBC
      if(immunity == "ni"){
        dI_nolag <- (1-cr(cue_state))*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["I"] # change in infected RBC density
      } else{
        dI_nolag <- (1-cr(cue_state))*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["I"]-(parameters["a"]*state["I"])/(parameters["b"]+state["I"]) # change in infected RBC density with immunity
      }
      dIg_nolag <- cr(cue_state)*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["Ig"] 
      dM_nolag <- -parameters["mum"]*state["M"]-parameters["p"]*state["R"]*state["M"]
      dG_nolag <- -parameters["mug"]*state["G"]
      
      ## Track states in initial cohort of infection
      if(t<=parameters["alpha"]){
        dI <- dI_nolag-pulseBeta(parameters["I0"], parameters["sp"], t)*S 
        dM <- dM_nolag+parameters["beta"]*pulseBeta(parameters["I0"], parameters["sp"], t)*S 
      }
      
      if(t<=parameters["alphag"]){
        dIg <- dIg_nolag-pulseBeta(parameters["Ig0"], parameters["sp"], t-1)*Sg 
        dG <- dG_nolag+pulseBeta(parameters["Ig0"], parameters["sp"], t-1)*Sg 
      }
      
      ## Track states after delay 
      if(t>parameters["alpha"]){
        dI <- dI_nolag-(1-cr(lag1[lag.i]))*parameters["p"]*lag1[1]*lag1[4]*S 
        dM <- dM_nolag+parameters["beta"]*(1-cr(lag1[lag.i]))*parameters["p"]*lag1[1]*lag1[4]*S 
      }
      
      if(t>parameters["alphag"]){
        dIg <- dIg_nolag-cr(lag2[lag.i])*parameters["p"]*lag2[1]*lag2[4]*Sg 
        dG <- dG_nolag+cr(lag2[lag.i])*parameters["p"]*lag2[1]*lag2[4]*Sg
      }
      
      ## Return the states
      return(list(c(dR, dI, dIg, dM, dG)))
  }

immunity <- "i"
cue <- "I"
  
# visualize where bottle neck with immunity run is. Integration is the greatest bottleneck 23000ms for integrate alone. Down to 11850 for trapezoid approximation
profvis::profvis({deSolve::dede(y = state, times = time_range, func = single_infection.fun, p = parameters, control=list(mxhist = 1e6))})

# trying lsoda
start.time <- Sys.time()
deSolve::dede(y = state, times = time_range, func = single_infection.fun, p = parameters, control=list(mxhist = 1e6), method = "lsoda")
end.time <- Sys.time()
end.time-start.time #31.42669 secs

# trying bdf
start.time <- Sys.time()
deSolve::dede(y = state, times = time_range, func = single_infection.fun, p = parameters, control=list(mxhist = 1e6), method = "bdf")
end.time <- Sys.time()
end.time-start.time #34.48703 secs'

# trying vode
start.time <- Sys.time()
deSolve::dede(y = state, times = time_range, func = single_infection.fun, p = parameters, control=list(mxhist = 1e6), method = "vode")
end.time <- Sys.time()
end.time-start.time #6.451089 
```

# testing the speed of different integrator
```{r}
# using stat integrate
t <- 10
integrand <- function(x) {parameters["mu"]+parameters["a"]/(parameters["b"]+state["I"])}
integrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$value

# cubature package. much slower
cubature::adaptIntegrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$integral

# pracma
pracma::integral(Vectorize(integrand), xmin = t-parameters["alpha"], xmax = t, method = "Kronrod")

# foreach
library(foreach)
foreach(i=1,.combine="c") %dopar%
{
  integrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$value;
}

# trapezoid estimation
trapezoid <- function(f, lower, upper) {
  if (is.function(f) == FALSE) {
    stop('f must be a function with one parameter (variable)')
  }
  h <- upper - lower
  fxdx <- (h / 2) * (f(lower) + f(upper))
  return(fxdx)
}

# composite trapezoid estimation
composite_trapezoid <- function(f, lower, upper, n) {
  if (is.function(f) == FALSE) {
    stop('f must be a function with one parameter (variable)')
  }
  h <- (upper - lower) / n
  j <- 1:n - 1
  xj <- lower + j * h
  approx <- (h / 2) * (f(lower) + 2 * sum(f(xj)) + f(upper))
  return(approx)
}

composite_trapezoid(Vectorize(integrand), lower = t-parameters["alpha"], upper = t, n = parameters["alpha"]/1e-3)

# Simpsin's rule
simpsons_rule <- function(f, lower, upper) {
  if (is.function(f) == FALSE) {
    stop('f must be a function with one parameter (variable)')
  }
  h <- (upper - lower) / 2
  x0 <- lower
  x1 <- lower + h
  x2 <- upper
  s <- (h / 3) * (f(x0) + 4 * f(x1) + f(x2))
  return(s)
}

simpsons_rule(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)

# pracma auadinf
pracma::quadinf(Vectorize(integrand), t-parameters["alpha"], t)$Q

# compare method speeds. Trapezoid fastest followed by Simpson's and R integrate
microbenchmark(integrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$value,
               cubature::adaptIntegrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$integral, foreach(i=1,.combine="c") %dopar%
{
  integrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$value;
},
pracma::integral(Vectorize(integrand), xmin = t-parameters["alpha"], xmax = t, method = "Kronrod"),
pracma::integral(Vectorize(integrand), xmin = t-parameters["alpha"], xmax = t, method = "Clenshaw"),
pracma::integral(Vectorize(integrand), xmin = t-parameters["alpha"], xmax = t, method = "Simpson"),
trapezoid(Vectorize(integrand), lower = t-parameters["alpha"], upper = t), 
composite_trapezoid(Vectorize(integrand), lower = t-parameters["alpha"], upper = t, n = parameters["alpha"]/1e-3), 
simpsons_rule(Vectorize(integrand), lower = t-parameters["alpha"], upper = t), 
pracma::quadinf(Vectorize(integrand), t-parameters["alpha"], t)$Q, times = 1000L)
```

# rerunning immunity model and calculate run time
```{r}
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_i_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)
ch_si_i_i_20.opt$par
stopCluster(cl) #1.769660 -363.080884  -37.980378    1.827227. Same as before
end.time <- Sys.time()
time.taken <- end.time - start.time 
time.taken #38.85414 (40 minutes!)
```

# optimizing pulsebeta function to vectorize
```{r}
# original pulse beta function
pulseBeta <- function(I0, sp, t){ 
    res = rep(NA, length(t))
    for (num in 1:length(t)){
      res[num] = I0*(dbeta(t[num], sp, sp))
    }
    return(res)}

# new pulse beta function
pulseBeta2 <- function(I0, sp, t){ 
    res = rep(NA, length(t))
    res = I0*(dbeta(t, sp, sp))
    }

# are they equal? Yes!
all.equal(pulseBeta2(48, 100, time_range), pulseBeta(48, 100, time_range))

# how should we call new function. Here dividng time by 1e-3 (time interval) and + 1 give us the proper index
test <- pulseBeta2(48, 100, time_range)
test[[(t/1e-3)+1]]

# plotting. We should see synchronous centering at 12 hours. Yes, it does
ggplot(data.frame(time_range, test)) +
  geom_line(aes(x = time_range, y = test)) +
  xlim(0,2)

# plotting asynchronous. All infected RBC must brst after 1 day. Matches up. 
ggplot(data.frame(time_range, test2 = pulseBeta2(48, 1, time_range))) +
  geom_line(aes(x = time_range, y = test2)) +
  xlim(0,2)
```

# testing new function that includes updated pulse-beta function and time-based cue
## without immunity, time-based. Looks good.
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_cpp.R")

# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_ni_t_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range)

stopCluster(cl) 
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken #13 minutes, down from 40 minutes in original run and from 20 minutes in first iteration
ch_si_ni_t_20.opt$par #6.2932211 -15.3891982   0.3197596 -11.3816705. Similar to Greischar model

# plot
ch_si_ni_t_20_cr.df <- par_to_df(ch_si_ni_t_20.opt, time_range)
```

## with immunity. Different! Greischar model had much later trnamission investment. 
### plotting the cumulutive transmission potential suggests that my model should be correct... By my model, Greischar;s optimal strategy produced lower cumulative transmission potential than the one I found.
```{r}
# with immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range)

stopCluster(cl) 
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken #58.7155 minutes. Very long with lsoda and integrate function
ch_si_i_t_20.opt$par #10.948894 -23.608461  -1.903851 -17.421159. SLightly different from Greischar's model wonder why.
ch_si_i_t_20.opt$value #-11.96688. 

## plotting
ch_si_i_t_20_cr.df <- par_to_df(ch_si_i_t_20.opt, time_range)
### get greischar model parameters
ch_si_i_t_20.opt_gre <- ch_si_i_t_20.opt
ch_si_i_t_20.opt_gre$par <- c(13.46, -27.66, -3.62, -20.24)
ch_si_i_t_20_cr_gre.df <- par_to_df(ch_si_i_t_20.opt_gre, time_range)

### similar directions but Greischar model had even more delayed transmission investment. 
ggplot() +
  geom_line(data = ch_si_i_t_20_cr.df, aes(x = time_range, y = model), alpha = 0.7, color = "blue") +
  geom_line(data = ch_si_i_t_20_cr_gre.df, aes(x = time_range, y = model), alpha = 0.7, color = "red") +
  geom_line(data = ch_si_ni_t_20_cr.df, aes(x = time_range, y = model), alpha = 0.7, color = "black") +
    xlab("Time") +
    ylab("Transmission investment") +
    labs(color = "Optimization methods") +
    theme_bw()

parameters
```

## getting transmission value cumulative form greischar's parameters 11.87644 in Greischar model. Smaller than ours. Different model or something?
```{r}
cue_range <- time_range
immunity <- "i"
cue <- "t"
df <- 3

state <- c(R = 8.5*10^6,
             I = 43.85965,
             Ig = 0,
             M = 0,
             G = 0)


  pulseBeta_fun <- function(I0, sp, t){ 
    res = rep(NA, length(t))
    res = I0*(dbeta(t, sp, sp))
  }
  
  #-------------------------#
  # Define conversion rate function. 
  # Simplified to increase performance. 
  #------------------------#
  ## Define dummy data of conversion rate
  dummy_y.vals <- rep(0, length(cue_range)) 
  dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
  
  ## fit basic cubic spline with no internal knots. Here, increasing df increases knots.
  ## degree defines shape of basis spline. This shouldn't have any impact on ultimate result
  ## What matter is the number of knots, or df. Increasing df should give us more complex reaction norm
  dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(cue_range, degree = 3, df = df))
  dummy_cr.mod$data <- dummy_cr.data
  
  ## Assign coefficient to be optimized to the dummy conversion rate function
  dummy_cr.mod$coefficients <- c(13.46, -27.66, -3.62, -20.24)
  
  ## use spline function to predict cr 
  cr_fit <- exp(-exp(predict(dummy_cr.mod, newdata = data.frame(cue_range))))
  
  ## Get spline function where cr ~ cue
  cr <- splinefun(cbind(cue_range, cr_fit))
  
  #-------------------------#
  # Define trapezoidal estimation 
  # for survival function approximation. Use this if speeding up model
  #------------------------#
  trapezoid <- function(f, lower, upper) {
    if (is.function(f) == FALSE) {
      stop('f must be a function with one parameter (variable)')
    }
    h <- upper - lower
    fxdx <- (h / 2) * (f(lower) + f(upper))
    return(fxdx)}
  
  #-------------------------#
  # Define single-infection model
  #------------------------#
  single_infection.fun <- function(t, state, parameters) {
    
    ## Defining Pulse beta function based on current time
    pulseBeta <- pulseBeta_fun(parameters["I0"], parameters["sp"], t)
      
      ## Define the lag terms. lag[1] = R, lag[2] = I, lag[3] = Ig, lag[4] = M, lag[5] = G
      if(t>parameters["alpha"]){lag1 = deSolve::lagvalue(t-parameters["alpha"])} # lag state for asexual development
      if(t>parameters["alphag"]){lag2 = deSolve::lagvalue(t-parameters["alphag"])} # lag state for gametocyte development
      
      ## get lag term index given cue
    ### Only get lag index when it is a state-based cue
    if(cue != "t") {
      lag.i <- match(cue, names(state))}
    
     ## convert cue to variable in state or just time
    if(cue == "t"){
      cue_state <- t}
    else{
      cue_state <- state[cue]}
    
    ### define lagged cue. Lag1 = alpha times ago, lag2 = alphag times ago
    if(t>parameters["alpha"] && cue == "t"){
      cue_lag1 <- t-parameters["alpha"]
    } 
    
    if(t>parameters["alpha"] && cue != "t"){
      cue_lag1 <- lag1[lag.i]
    } 
    
    if(t>parameters["alphag"] && cue == "t") {
      cue_lag2 <- t-parameters["alphag"]
    } 
    
    if(t>parameters["alphag"] && cue != "t") {
      cue_lag2 <- lag2[lag.i]
    }
      
      ## Define K, carrying capacity of RBC
      K <- parameters["lambda"]*parameters["R1"]/(parameters["lambda"]-parameters["mu"]*parameters["R1"])
      
      ## Define survival functions
      ### Survival of infected asexual RBC
      if(t>parameters["alpha"] && immunity == "ni"){
        S <- exp(-parameters["mu"]*parameters["alpha"])
      } else if(t>parameters["alpha"] && immunity =="i"){
        integrand <- function(x) {parameters["mu"]+parameters["a"]/(parameters["b"]+state["I"])}
        integrate_val <- integrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)
        S <- exp(-1*integrate_val$value)
      } else if(t<=parameters["alpha"] && immunity == "ni"){
        S <- exp(-parameters["mu"]*t)
      } else{
        integrand <- function(x) {parameters["mu"]+parameters["a"]/(parameters["b"]+state["I"])}
        integrate_val <- integrate(Vectorize(integrand), lower = 0, upper = t)
        S <- exp(-1*integrate_val$value)
      }
      
      ### Survival of gametocytes. We assume that infected
      ### RBC with gametocyte is not removed by immune response
      if(t<=parameters["alphag"]){
        Sg <- exp(-parameters["mu"]*t)
      } else{
        Sg <- exp(-parameters["mu"]*parameters["alphag"])}
      
      ## Define the models without lag terms. 
      dR <- parameters["lambda"]*(1-state["R"]/K)-parameters["mu"]*state["R"]-parameters["p"]*state["R"]*state["M"] # change in susceptible RBC
     
       if(immunity == "ni"){
        dI_nolag <- (1-cr(cue_state))*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["I"] # change in infected RBC density
      } else{
        dI_nolag <- (1-cr(cue_state))*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["I"]-(parameters["a"]*state["I"])/(parameters["b"]+state["I"]) # change in infected RBC density with immunity
      }
      
      dIg_nolag <- cr(cue_state)*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["Ig"] 
      dM_nolag <- -parameters["mum"]*state["M"]-parameters["p"]*state["R"]*state["M"]
      dG_nolag <- -parameters["mug"]*state["G"]
      
      ## Track states in initial cohort of infection
      if(t<=parameters["alpha"]){
        dI <- dI_nolag-pulseBeta*S 
        dM <- dM_nolag+parameters["beta"]*pulseBeta*S 
      }
      
      if(t<=parameters["alphag"]){
        dIg <- dIg_nolag ## should have no cells form initial cohort
        dG <- 0
      }
      
      ## Track states after delay 
      if(t>parameters["alpha"]){
        dI <- dI_nolag-(1-cr(cue_lag1))*parameters["p"]*lag1[1]*lag1[4]*S 
        dM <- dM_nolag+parameters["beta"]*(1-cr(cue_lag1))*parameters["p"]*lag1[1]*lag1[4]*S 
      }
      
      if(t>parameters["alphag"]){
        dIg <- dIg_nolag-cr(cue_lag2)*parameters["p"]*lag2[1]*lag2[4]*Sg 
        dG <- dG_nolag+cr(cue_lag2)*parameters["p"]*lag2[1]*lag2[4]*Sg
      }
      
      ## Return the states
      return(list(c(dR, dI, dIg, dM, dG)))
  }
  
  #-------------------------#
  # Run single-infection model
  #------------------------#
  single_infection.df <- as.data.frame(deSolve::dede(y = state,
                                                     times = time_range,
                                                     func = single_infection.fun,
                                                     p = parameters,
                                                     method = solver,
                                                     control=list(mxhist = 1e6)))
  
#-------------------------#
  # Calculate fitness
  #------------------------#
  ## Get Gametocyte density time series data
  gam <- single_infection.df$G
  gam[gam<0] <- 0 # Assign negative gametocyte density to 0
  
  ## Get timeseries interval. Simplify first time after t=0
  int <- single_infection.df[2,1]
  
  ## Define the fitness parameter values
  aval <- -12.69
  bval <- 3.6
  dens <- log10(gam)
  
  ## Calculate the transmission potential at each time t
  tau.ls <- (exp(aval+bval*dens))/(1+exp(aval+bval*dens))
  
  ## Get approximation of cumulative transmission potential
  tau.sum <- sum(tau.ls*int)
  tau.cumsum <- cumsum(tau.ls*int)
  tau.sum
```

## check infection dynamics to see if same model.Seems to be the case...
```{r}
# tau cumulative sum. Looks very similar
ggplot(data.frame(time_range, tau.cumsum)) +
  geom_line(aes(time_range, tau.cumsum))

# plotting other stuff
single_infection.df2 <- single_infection.df %>% gather(key = "variable", value = "value", -time)

ggplot(single_infection.df2, aes(x = time, y = value)) +
  geom_line() +
  facet_wrap(~variable, scales = "free") +
  scale_y_continuous(labels = scales::scientific) +
  theme_bw()
```

## double check this is the case. I changed some stuff, fixed the conditional lag cue code. So rerun the code
### run with immunity
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_cpp.R")

# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.opt2 <- optimParallel(par = c(13, -25, -3, -20), # get it close so it runs faster
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range)

stopCluster(cl) 
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken # 31.47385 mins taken
ch_si_i_t_20.opt2$par #10.948492 -23.607393  -1.904272 -17.419994. Same as before. Sigh...

single_function.fun
```

## run with immunity + trapezoidal estimation for integration
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.opt_trap <- optimParallel(par = c(13, -25, -3, -20), # get it close so it runs faster
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range,
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #22.84097 minutes. Done from 31 minutes with integrate.
ch_si_i_t_20.opt_trap$par #10.94948 -23.60937  -1.90456 -17.42204 (very similar. insignificant difference)
```

## run with immunity + trapezoid+vode integration. Fastest run so far. 
```{r}
# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.opt_trap_vode <- optimParallel(par = c(13, -25, -3, -20), # get it close so it runs faster
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range,
                      integration = "trapezoid",
                      solver = "vode")
stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time # 6.682592 minutes. very fast
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.opt_trap_vode$par #10.947226 -23.605154  -1.902684 -17.423413 (very similar)
```

# fix death rate from immune response
## trying out other forms of immunity removal integration
```{r}
# calculate immune reaction based on non-immunity model
immune <- parameters["a"]/(parameters["b"]+single_infection.df$I)
immune_dummy <- data.frame(time_range, immune)
## calculate cumulative immune hazard rate for each time t (from t-alpha to t)
immune_dummy.df <- immune_dummy %>%
  mutate(cumsum = cumsum(immune)) %>%
  mutate(cum_rolling1000 = zoo::rollapplyr(immune*1e-3, width = 1000, FUN = sum, partial = TRUE)) %>%
  drop_na(cumsum)

# trying definite integral function
def_int <- data.frame(time_range, immune =(parameters["alpha"]*parameters["a"])/(parameters["b"]+single_infection.df$I))
 # trying definite integral function from 0 to alpha
def_int_init <- data.frame(time_range, immune = parameters["a"]*time_range/(parameters["b"]+single_infection.df$I))
  
# trying laplace
laplace <- data.frame(time_range, immune = (parameters["a"]*log10(single_infection.df$time+parameters["b"])-2*log10(single_infection.df$time-parameters["alpha"]))/single_infection.df$I)

# plotting. Definitive integral seem to match up pretty good. Of course...
ggplot() +
  geom_line(data = immune_dummy.df, aes(x = time_range, y = cum_rolling1000), color = "blue") + # OG
  geom_line(data = def_int, aes(x = time_range, y = immune), color = "red") + #valid after alpha
  geom_line(data = def_int_init, aes(x = time_range, y = immune), color = "dark red") + # valid before alpha
  geom_line(data = laplace, aes(x = time_range, y = immune), color = "green") +
  xlim(0, 20) + #applies to only after alpha
  theme_bw() +
  ylim(0,3)

def_int
immune_dummy.df
```

## test out function with immunity as definitive integral
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.def_int <- optimParallel(par = c(13, -25, -3, -20), # get it close so it runs faster
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range,
                      solver = "vode")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time#2.391554 minutes fast!
ch_si_i_t_20.def_int$par # 10.94816 -23.60684  -1.90449 -17.41818. Very similar to integrate. lol.... Still not replicating Greischar et al.

# plotting. Black is our and red is greischar model. Blue is without immunity
par_to_df(ch_si_i_t_20.def_int, time_range) %>% 
  ggplot(aes(x = cue_range, y = model)) +
  geom_line() +
  geom_line(data = ch_si_i_t_20_cr_gre.df, aes(x = time_range, y = model), alpha = 0.7, color = "red") +
  geom_line(data = ch_si_ni_t_20_cr.df, aes(x = time_range, y = model), alpha = 0.7, color = "blue") +
  theme_bw()

```

## changed dI condition to 2 ifs. Nope. doesn't make a difference
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.dIif <- optimParallel(par = c(13, -25, -3, -20), # get it close so it runs faster
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range,
                      solver = "vode")

stopCluster(cl) 
end.time <- Sys.time()

end.time-start.time #2.4 minutes
# 10.9482 -23.6068 -1.90449 -17.4182  still the same lol
```

# testing out infection dynamics simulation with new function
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

# run infection model using opt function. However, do not wrap around opt and set dyn = TRUE
ch_si_i_t_20.dyn <- chabaudi_si_opt_fast(parameters_cr = c(10.9482, -23.6068, -1.90449, -17.4182),
                                         immunity = "i",
                                         parameters = parameters,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "t",
                                         cue_range = time_range,
                                         solver = "lsoda",
                                         dyn = TRUE)


# get no immunity model to compare. Kind of different than greischar's case. huh.
ch_si_ni_t_20.dyn <- chabaudi_si_opt_fast(parameters_cr = c(6.2932211, -15.3891982,  0.3197596, -11.3816705),
                                         immunity = "ni",
                                         parameters = parameters,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "t",
                                         cue_range = time_range,
                                         solver = "vode",
                                         dyn = TRUE)

# plot. Red = no immunity. Blue = immunity
ggplot() +
  geom_line(data = ch_si_ni_t_20.dyn, aes(x = time, y = value), color = "red") +
  geom_line(data = ch_si_i_t_20.dyn, aes(x = time, y = value), color = "blue") +
  facet_wrap(~variable, scales = "free") +
  scale_y_continuous(labels = scales::label_scientific(digits = 2)) +
  theme_bw()

```

# testing out more complex models. Where cue is based on I
# redefine parameters
```{r}
parameters <- c(R1 = 8.5*10^6,
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 4*10^-6,
                alpha = 1, 
                alphag = 2, 
                beta = 10, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1)

time_range <- seq(0, 20, by = 1e-3)
cue_range <- seq(0, (3.7*10^5)*(8.5*10^6)/((3.7*10^5)-0.025*(8.5*10^6)), by = 1000) 
```

## Testing out higher df
```{r}
# df = 3
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_3 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "lsoda")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #10.50088 mins
ch_si_i_I_20.opt_3$par #1.7689113 -362.9437761  -26.2038195   -0.5623042 Slightly different than before with numerical integration...
#1.769660 -363.080884  -37.980378    1.827227

ch_si_i_I_20.opt_3$value #-11.63004
```

```{r}
# df = 4. Not able to converge with vode. Try lsoda which converged
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_4 <- optimParallel(par = rep(0.5, 5),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 4,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "lsoda")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time # 8.858414 mins from 0.5x5. Nice!
ch_si_i_I_20.opt_4$par #1.769130 -181.902327   33.287844    2.866469    0.500000


ch_si_i_I_20.opt_4$value #-11.63058
```


```{r}
# visualizing reaction norm. Big difference!
ch_si_i_I_20_3.cr <- par_to_df(ch_si_i_I_20.opt_3, cue_range)
ch_si_i_I_20_4.cr <- par_to_df(ch_si_i_I_20.opt_4, cue_range)

ggplot() +
  geom_line(data = ch_si_i_I_20_3.cr, aes(x = cue_range, y = cr), color = "black") +
  geom_line(data = ch_si_i_I_20_4.cr, aes(x = cue_range, y = cr), color = "blue")  +
  theme_bw()
```

# adjusting cue_range
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")
# first get basic infection simulation to see Infected RBC range. SEt this to max IRBC for constant investment

ch_si_i_I_20.dyn_3 <- chabaudi_si_opt_fast(parameters_cr = ch_si_i_I_20.opt_3$par,
                                         immunity = "i",
                                         parameters = parameters,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range,
                                         solver = "lsoda",
                                         dyn = TRUE)

ch_si_i_I_20.dyn_4 <- chabaudi_si_opt_fast(parameters_cr = ch_si_i_I_20.opt_4$par,
                                         immunity = "i",
                                         parameters = parameters,
                                         time_range = time_range,
                                         df = 4,
                                         cue = "I",
                                         cue_range = cue_range,
                                         solver = "lsoda",
                                         dyn = TRUE)

# plot
ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_3, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  scale_y_continuous(labels = scales::label_scientific(digits = 2)) +
  theme_bw()

# get range of I. Max at 55272.17078. Let's go slightly triple that @200000
range(ch_si_i_I_20.dyn_3 %>% 
  filter(variable == "I") %>% select(value))
```

# redo optimization with different cue_range
```{r}
# Define shorter range
cue_range2 <- seq(0, 2000000, by = 1000) ## shorter distance or else error

## sort of converged??
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_3_short <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range2,
                      solver = "lsoda")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #23.77503
ch_si_i_I_20.opt_3_short$par #1.808594  -73.232651 1251.575459 -133.909465
ch_si_i_I_20.opt_3_short$value #-11.79005 (higher)

# plot
ch_si_i_I_20_3_short.cr <- par_to_df(ch_si_i_I_20.opt_3_short, cue_range2)

# very different lol
ggplot() +
  geom_line(data = ch_si_i_I_20_3_short.cr, aes(x = cue_range, y = cr)) +
  theme_bw()
```

## looking at short_ranged byt with higher df
```{r}
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_4_short <- optimParallel(par = rep(0.5, 5),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 4,
                      cue = "I",
                      cue_range = cue_range2,
                      solver = "lsoda")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #29.59606 mins
ch_si_i_I_20.opt_4_short$par #2.076018 -22.471865 185.846543 -13.824956  27.202292
ch_si_i_I_20.opt_4_short$value #-11.73344

# plot
ch_si_i_I_20_4_short.cr <- par_to_df(ch_si_i_I_20.opt_4_short, cue_range2)

# lacks the terminal high that was shown in the 3 df model
ggplot() +
  geom_line(data = ch_si_i_I_20_4_short.cr, aes(x = cue_range, y = cr)) +
  theme_bw()
```


# plotting overall infection dynamics
```{r}
ch_si_i_I_20.dyn_3_short <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_3_short$par,
                                         immunity = "i",
                                         parameters = parameters,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range2,
                                         solver = "lsoda",
                                         dyn = TRUE)

ch_si_i_I_20.dyn_4_short <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_4_short$par,
                                         immunity = "i",
                                         parameters = parameters,
                                         time_range = time_range,
                                         df = 4,
                                         cue = "I",
                                         cue_range = cue_range2,
                                         solver = "lsoda",
                                         dyn = TRUE)

# compare black = across K optimization, red = 0 to 2000000 optimization. Very different. Blue is time based approach. Overall parasite density is much lower in I-based cue models. The "peak" of iRBC also is reached much earlier in our model (although we have that range spike at the end of infection). The earlier timing is much more reminiscent of typical P. chabaudi infection (which peaks around 6-8 days). Most infection exhibits a unimodel distribution, which our models does not have. This could be due to lack of adaptive immune reaction, which kicks in around 5 days??

## when CR ~ time, population growth seems to be bottom-up (where paratemesia is governed by RBC availability). This does occur in models however, much earlier

## when we do df = 4 for shorter cue_range, we also see a semi peak at around 15 days and subsequent decline in iRBC count due to RBC non-avaiability. Need better immune reaction
ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_4, aes(x = time, y = value), color = "black") +
  #geom_line(data = ch_si_i_I_20.dyn_3_short, aes(x = time, y = value), color = "red") +
  geom_line(data = ch_si_i_I_20.dyn_4_short, aes(x = time, y = value), color = "green") +
  geom_line(data = ch_si_i_t_20.dyn, aes(x = time, y = value), color = "blue") +
  facet_wrap(~variable, scales = "free") +
  #scale_y_continuous(labels = scales::label_scientific(digits = 2)) +
  theme_bw()

```

# Trying different immunity models!
## Kochin's innate immunity
## Very similar results. For some reason, targetted innate immunity is not sufficient. We might need to incorporate indescriminate killing as part of that.
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_imm.R")

# set different parameters
parameters_kochin <- c(R1 = 8.89*10^6,
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 4*10^-6,
                alpha = 1, 
                alphag = 2, 
                beta = 10, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                sigma = 1.17*10^-8,
                mue = 0.3,
                gamma = 133)
  
  
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_kochin_3 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "kochin",
                      parameters = parameters_kochin,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "vode",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #27.29253 mins
ch_si_i_I_20.opt_kochin_3$par #1.5364718 -301.1007836   -3.1754708    0.5604894
ch_si_i_I_20.opt_kochin_3$value #-12.69556

# plotting cr
ch_si_i_I_20_kochin_3.cr <- par_to_df(ch_si_i_I_20.opt_kochin_3, cue_range)

ggplot() +
  geom_line(data = ch_si_i_I_20_kochin_3.cr, aes(x = cue_range, y = cr)) +
  xlim(0, 500000) +
  theme_bw()

# plotting df
ch_si_i_I_20.dyn_kochin_3 <- chabaudi_si_opt_imm(
  parameters_cr = ch_si_i_I_20.opt_kochin_3$par,
                                         immunity = "kochin",
                                         parameters = parameters_kochin,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range,
                                         solver = "lsoda",
                                         dyn = TRUE,
  integration = "trapezoid")

ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_kochin_3, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```



## Adding indescriminant removal of RBC using tsukushi'd model
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")
## Warning consider changing certain parameter values to the ones Tsukushi used
## Estimated using adobe illustrator lol
parameters_tsukushi <- c(R1 = 8.5*10^6,
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 4*10^-6,
                alpha = 1, 
                alphag = 2, 
                beta = 10, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 17.65,
                psiw = 1,
                phin = 28.5175,
                phiw = 552.178,
                iota = (10^4)/(2.18*(10^6)))

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_3 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "lsoda",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #3.825459 mins
ch_si_i_I_20.opt_tsukushi_3$par #0.5462002 0.4996780 0.5000022 0.5000017
ch_si_i_I_20.opt_tsukushi_3$value #-0.02495789

# plotting cr vs cue
ch_si_i_I_20_tsukushi_3.cr <- par_to_df(ch_si_i_I_20.opt_tsukushi_3, cue_range)

ggplot() +
  geom_line(data = ch_si_i_I_20_tsukushi_3.cr, aes(x = cue_range, y = cr)) +
  theme_bw()

# plotting infection dynamics
ch_si_i_I_20.dyn_tsukushi_3 <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_3$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range,
                                         solver = "lsoda",
                                         dyn = TRUE,
  integration = "trapezoid")

 # All RBC dead lol
ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_3, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

## Need to add in replenishment rate that increases with deviation
## testing with new parameter set. Changed dR dt and added in Rho. Much better. Seems to simulate actual infection dynamics captured in experiments. The conversion rate is also much lower. Still, I am not sure the value of phin, given the weird y axis in their plots.
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

parameters_tsukushi2 <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 8.55, # approximate
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 17.65,
                psiw = 1,
                phin = 28.5175,
                phiw = 552.178,
                iota = (10^4)/(2.18*(10^6)), # please surround with bracket. Or else R does wrong calculation
                rho = 0.263)

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_3 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi2,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "lsoda",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #15.07049 mins
ch_si_i_I_20.opt_tsukushi_3$par #1.1772653 -30.2704138   0.3361028   0.5065292
ch_si_i_I_20.opt_tsukushi_3$value #-7.002037. Lower than before.

# plotting best strategy
ch_si_i_I_20_tsukushi_3.cr <- par_to_df(ch_si_i_I_20.opt_tsukushi_3, cue_range)

ggplot() +
  geom_line(data = ch_si_i_I_20_tsukushi_3.cr, aes(x = cue_range, y = cr)) +
  theme_bw()

# plotting infection dynamics
ch_si_i_I_20.dyn_tsukushi_3 <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_3$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi2,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range,
                                         solver = "lsoda",
                                         dyn = TRUE,
  integration = "trapezoid")

# Interesting pattern. Seems to replicate typical infection dynamics
ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_3, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

# try with negative phin
```{r}
parameters_tsukushi3 <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 8.55, # approximate
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 17.65,
                psiw = 1,
                phin = 0.035, # changed if negative
                phiw = 552.178,
                iota = (10^4)/(2.18*(10^6)), # please surround with bracket. Or else R does wrong calculation
                rho = 0.263)


start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_3_phin2 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi3,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "lsoda",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #19.7743 mins
ch_si_i_I_20.opt_tsukushi_3_phin2$par #1.479769 -305.409474  -28.886532   -1.489173
ch_si_i_I_20.opt_tsukushi_3_phin2$value #-13.54399

ch_si_i_I_20_tsukushi_3_phin2.cr <- par_to_df(ch_si_i_I_20.opt_tsukushi_3_phin2, cue_range)

ggplot() +
  geom_line(data = ch_si_i_I_20_tsukushi_3_phin2.cr, aes(x = cue_range, y = cr)) +
  theme_bw()

# plotting infection dynamics
ch_si_i_I_20.dyn_tsukushi_3_phin2 <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_3_phin2$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi3,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range,
                                         solver = "lsoda",
                                         dyn = TRUE,
  integration = "trapezoid")

# infection dynamics
ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_3_phin2, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

## I think the positive larger phin is the correct one
## See whether shortening cue_range does anything
```{r}
cue_range2 <- seq(0, 2000000, by = 1000) 

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_3_short <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi2,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range2,
                      solver = "vode",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()

end.time-start.time #9.981977 mins
ch_si_i_I_20.opt_tsukushi_3_short$par #.616375 -14.202095 112.612226   7.231653
ch_si_i_I_20.opt_tsukushi_3_short$value #-7.857734. higher but different solver

#plot cr vs cue
ch_si_i_I_20_tsukushi_3_short.cr <- par_to_df(ch_si_i_I_20.opt_tsukushi_3_short, cue_range2)

ggplot() +
  geom_line(data = ch_si_i_I_20_tsukushi_3_short.cr, aes(x = cue_range, y = cr)) +
  theme_bw()

## get infection dynamics
ch_si_i_I_20.dyn_tsukushi_3_short <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_3_short$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi2,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range2,
                                         solver = "vode",
                                         dyn = TRUE,
  integration = "trapezoid")

# infection dynamics
ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_3_short, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

## even shorter cue_range. Same lol
```{r}
cue_range3 <- seq(0, 1000000, by = 1000) 

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_3_short2 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi2,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range3,
                      solver = "vode",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()

end.time-start.time #11.3569 mins
ch_si_i_I_20.opt_tsukushi_3_short2$par #1.650313 -7.958943 27.811791  3.490711
ch_si_i_I_20.opt_tsukushi_3_short2$value #-7.882489. higher

#plot cr vs cue
ch_si_i_I_20_tsukushi_3_short2.cr <- par_to_df(ch_si_i_I_20.opt_tsukushi_3_short2, cue_range3)

# very similar
ggplot() +
  geom_line(data = ch_si_i_I_20_tsukushi_3_short2.cr, aes(x = cue_range, y = cr), color = "blue") +
  geom_line(data = ch_si_i_I_20_tsukushi_3_short.cr, aes(x = cue_range, y = cr), color = "red") +
  theme_bw()

## get infection dynamics
ch_si_i_I_20.dyn_tsukushi_3_short2 <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_3_short2$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi2,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range3,
                                         solver = "vode",
                                         dyn = TRUE,
  integration = "trapezoid")

# infection dynamics
ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_3_short2, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

## higher df
```{r}
cue_range2 <- seq(0, 2000000, by = 1000) 

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_4_short <- optimParallel(par = rep(0.5, 5),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi2,
                      time_range = time_range,
                      df = 4,
                      cue = "I",
                      cue_range = cue_range2,
                      solver = "lsoda",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()

end.time-start.time #36.09026 mins
ch_si_i_I_20.opt_tsukushi_4_short$par #1.643224 -7.919851 60.709204  3.469604  0.500000
ch_si_i_I_20.opt_tsukushi_4_short$value #-7.870702

#plot cr vs cue
ch_si_i_I_20_tsukushi_4_short.cr <- par_to_df(ch_si_i_I_20.opt_tsukushi_4_short, cue_range2)

# slightly different but not really
ggplot() +
  geom_line(data = ch_si_i_I_20_tsukushi_4_short.cr, aes(x = cue_range, y = cr)) +
  geom_line(data = ch_si_i_I_20_tsukushi_3_short.cr, aes(x = cue_range, y = cr), color = "blue") +
  theme_bw()

## get infection dynamics
ch_si_i_I_20.dyn_tsukushi_4_short <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_4_short$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi2,
                                         time_range = time_range,
                                         df = 4,
                                         cue = "I",
                                         cue_range = cue_range2,
                                         solver = "lsoda",
                                         dyn = TRUE,
  integration = "trapezoid")

# infection dynamics. Very similar. seems like the big impact is cue range rather than degrees of freedom
ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_4_short, aes(x = time, y = value), color = "black") +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_3_short, aes(x = time, y = value), color = "blue") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()


```

## really short cue range
```{r}
cue_range4 <- seq(0, 500000, by = 100) 

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_3_short3 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi2,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range4,
                      solver = "lsoda",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #43.35133 mins
ch_si_i_I_20.opt_tsukushi_3_short3$par #1.690811 -4.387426  4.644109  1.748226
ch_si_i_I_20.opt_tsukushi_3_short3$value #-7.91632 higher

#plot cr vs cue
ch_si_i_I_20_tsukushi_3_short3.cr <- par_to_df(ch_si_i_I_20.opt_tsukushi_3_short3, cue_range4)

# same lol
ggplot() +
  geom_line(data = ch_si_i_I_20_tsukushi_3_short3.cr, aes(x = cue_range, y = cr)) +
  geom_line(data = ch_si_i_I_20_tsukushi_3_short2.cr, aes(x = cue_range, y = cr), color = "blue") +
  theme_bw()

# infection dynamics
ch_si_i_I_20.dyn_tsukushi_3_short3 <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_3_short3$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi2,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range4,
                                         solver = "lsoda",
                                         dyn = TRUE,
  integration = "trapezoid")

ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_3_short3, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

# getting better parameters for tsukushi's model
```{r}
library("rstan")
library("lattice")
library("gridExtra")

setwd("/Users/avrilwang/Desktop/Project_Plasmodium/tsukushi_2020")
load("output.rda")
source("model_input.R")
extracted_output=rstan::extract(output)

reaction_norms=array(NA,dim=c(n_doses,7,length(extracted_output$dose_slope[,1])))

for(i in 1:7){
  reaction_norms[i,1,]=extracted_output$rho+       extracted_output$dose_slope[,1]*dose_slope_id[i];
  reaction_norms[i,2,]=extracted_output$burst+     extracted_output$dose_slope[,2]*dose_slope_id[i];
  reaction_norms[i,3,]=extracted_output$iota_N1+   extracted_output$dose_slope[,3]*dose_slope_id[i];
  reaction_norms[i,4,]=extracted_output$iota_N2+   extracted_output$dose_slope[,4]*dose_slope_id[i];
  reaction_norms[i,5,]=extracted_output$phi_N1+    extracted_output$dose_slope[,5]*dose_slope_id[i];
  reaction_norms[i,6,]=extracted_output$phi_N2+    extracted_output$dose_slope[,6]*dose_slope_id[i];
}

reaction_norms_upper=array(NA,dim=c(n_doses,7))
reaction_norms_lower=array(NA,dim=c(n_doses,7))
reaction_norms_median=array(NA,dim=c(n_doses,7))

for(i in 1:7){
  for(v in 1:7){
    reaction_norms_upper[i,v] = quantile(reaction_norms[i,v,],0.975,na.rm = T)
    reaction_norms_lower[i,v] = quantile(reaction_norms[i,v,],0.025,na.rm = T)
    reaction_norms_median[i,v] = median(reaction_norms[i,v,],na.rm = T)
  }
}
 # v = 3 = activations strength general, v = 5 = half lifegeneral, v =1 = erythropoiesis, v = 2 burst size, v4 = activation strength targeted, v6 = half life targeted

plot(seq(2,8, by = 1), reaction_norms_median[,3])
reaction_norms_median[3,3] ## general RBC activation strength = 2.81495
exp(reaction_norms_median[3,3])  #16.69234

plot(seq(2,8, by = 1), reaction_norms_median[,4])
reaction_norms_median[3,4] ## targeted activaion strength = -0.1705766
exp(reaction_norms_median[3,4]) #0.8431785

plot(seq(2,8, by = 1), reaction_norms_median[,5])
reaction_norms_median[3,5] ## general half life = -3.346541
exp(reaction_norms_median[3,5]) #0.03520591

plot(seq(2,8, by = 1), reaction_norms_median[,6])
reaction_norms_median[3,6] ## targeted half life 6.311448
exp(reaction_norms_median[3,6]) ##550.842

plot(seq(2,8, by = 1), reaction_norms_median[,1])
reaction_norms_median[3,1] ## 0.0496112 for erythropoesis
exp(reaction_norms_median[3,1])*0.25 #0.2627156

plot(seq(2,8, by = 1), reaction_norms_median[,2])
reaction_norms_median[3,2] ##-0.2016985
exp(reaction_norms_median[3,2])*7 #5.721389
```

## ok update model with new parameters/ Also corrected cue formula
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

# updated and accurate parameters
parameters_tsukushi4 <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 5.721, # approximate
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 16.69234,
                psiw = 0.8431785,
                phin = 0.03520591, 
                phiw = 550.842,
                iota = 2.18*(10^6), # please surround with bracket. Or else R does wrong calculation
                rho = 0.2627156)

# start with whole range
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_updated <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi4,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "vode",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()

ch_si_i_I_20.dyn_tsukushi_updated <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_updated$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi4,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range,
                                         solver = "vode",
                                         dyn = TRUE,
  integration = "trapezoid")


ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_updated, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()


```

## trying 10^5 parameters
```{r}
parameters_tsukushi5 <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = exp(reaction_norms_median[4,2])*7, # approximate
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = exp(reaction_norms_median[4,3]),
                psiw = exp(reaction_norms_median[4,4]),
                phin = exp(reaction_norms_median[4,5]), 
                phiw = exp(reaction_norms_median[4,6]),
                iota = 2.18*(10^6), # please surround with bracket. Or else R does wrong calculation
                rho = exp(reaction_norms_median[4,1])*0.25)

setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_updated2 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi5,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "vode",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()

ch_si_i_I_20.dyn_tsukushi_updated2 <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_updated2$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi5,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range,
                                         solver = "vode",
                                         dyn = TRUE,
  integration = "trapezoid")

ch_si_i_I_20.dyn_tsukushi_updated2 %>% dplyr::filter(variable == "R")

ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_updated2, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()

ch_si_i_I_20.dyn_tsukushi_updated %>% 
  dplyr::filter(variable=="I") %>% 
  dplyr::arrange(desc(value))
```

## changed RBC replishment to original... nope
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")
# start with whole range
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_updated3 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi4,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "vode",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()

ch_si_i_I_20.dyn_tsukushi_updated3 <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_updated3$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi4,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range,
                                         solver = "vode",
                                         dyn = TRUE,
  integration = "trapezoid")

ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_updated3, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

# Fixed the equations of tsukushi's model in include sexual iRBC removal by indiscriminant RBC removal (forgot that)
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_updated4 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi4,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "vode",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #6.828209 mins
ch_si_i_I_20.opt_tsukushi_updated4$par #1.6926425 -288.1998249   -3.9605169    0.2630436
ch_si_i_I_20.opt_tsukushi_updated4$value #-11.62228

ch_si_i_I_20.dyn_tsukushi_updated4 <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_updated4$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi4,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range,
                                         solver = "vode",
                                         dyn = TRUE,
  integration = "trapezoid")

ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_updated4, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
chabaudi_si_opt_fast
```

## try out if gametocyte is targeted by immune system
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_updated5 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi4,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "vode",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time

ch_si_i_I_20.opt_tsukushi_updated5$par #1.940619 -585.327007   -1.682000   -1.762249
ch_si_i_I_20.opt_tsukushi_updated5$value #-7.964332

ch_si_i_I_20_tsukushi_updated5.cr <- par_to_df(ch_si_i_I_20.opt_tsukushi_updated5, cue_range)

ggplot(ch_si_i_I_20_tsukushi_updated5.cr) +
  geom_line(aes(x = cue_range, y=cr)) +
  xlim(0, 500000)

ch_si_i_I_20.dyn_tsukushi_updated5 <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_updated5$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi4,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range,
                                         solver = "vode",
                                         dyn = TRUE,
  integration = "trapezoid")

ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_updated5, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

## shorter cue range
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_updated6 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi4,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = seq(0, 2.18*10^6, by = 1000),
                      solver = "vode",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time

ch_si_i_I_20.opt_tsukushi_updated6$par #2.1147080 -70.3984268 -13.0573976  -0.9477162
ch_si_i_I_20.opt_tsukushi_updated6$value #-7.964732

ch_si_i_I_20_tsukushi_updated6.cr <- par_to_df(ch_si_i_I_20.opt_tsukushi_updated6, seq(0, 2.18*10^6, by = 1000))

ggplot(ch_si_i_I_20_tsukushi_updated6.cr) +
  geom_line(aes(x = cue_range, y=cr)) +
  xlim(0, 500000)

ch_si_i_I_20.dyn_tsukushi_updated6 <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_updated6$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi4,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = seq(0, 2.18*10^6, by = 1000),
                                         solver = "vode",
                                         dyn = TRUE,
  integration = "trapezoid")

I_total <- ch_si_i_I_20.dyn_tsukushi_updated6 %>% 
  dplyr::filter(variable == "I" | variable == "Ig") %>% 
  dplyr::group_by(time) %>% 
  dplyr::summarise(I_total = sum(value))

I_totaldf <- data.frame(variable = rep("I_total", nrow(I_total)), time = I_total$time, value = I_total$I_total)


ch_si_i_I_20.dyn_tsukushi_updated6_2 <- rbind(ch_si_i_I_20.dyn_tsukushi_updated6, I_totaldf)


ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_updated6_2, aes(x = time, y = log10(value)), color = "black") +
  facet_wrap(~variable, scales = "free") +
  ylim(0,7)+
  xlim(0,20)+
  theme_bw()

ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_updated6_2, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

## trouble shooting tsukushi model. Why is I so low?? Here, conversion rate is higher to produce gametocyte but not produce too much infected RBC to control for immune response. Higher iRBC (lower conversion rate) leads to rapid innate immune response which decimate parasite population. 
### Looking at parameter values
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")
# construct test cr so that we have a consistently low cr of 0.05
dummy_y.vals <- rep(1.1, length(cue_range)) 
dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))

dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(x = cue_range, degree = 3, df = 3))
  
dummy_cr.mod$coefficients #15e-02, 6.288615e-15, 3.149452e-19, 3.144150e-15
  
test.cr <- ch_si_i_I_20.opt_tsukushi_updated6
test.cr$par <- dummy_cr.mod$coefficients
test.crdf <- par_to_df(test.cr, cue_range)
plot(test.crdf$cue_range, test.crdf$cr)

# run test simulation with constant conversion rate. 
test_par1 <- chabaudi_si_opt_fast(
  parameters_cr = dummy_cr.mod$coefficients,
  immunity = "tsukushi",
  parameters = parameters_tsukushi4,
  time_range = time_range,
  df = 3,
  cue = "I",
  cue_range = cue_range,
  solver = "vode",
  dyn = TRUE,
  integration = "trapezoid")

# this looks good. I vs Ig looks normal and timing of infections looks normal. Although very low fitness 
ggplot() +
  geom_line(data = test_par1, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()

# trying when sexually commited iRBC are only half as likely going to be removed targetetd
test_par2 <- chabaudi_si_opt_fast(
  parameters_cr = dummy_cr.mod$coefficients,
  immunity = "tsukushi",
  parameters = parameters_tsukushi4,
  time_range = time_range,
  df = 3,
  cue = "I",
  cue_range = cue_range,
  solver = "vode",
  dyn = TRUE,
  integration = "trapezoid")

# much higher fitness, no shit. 
ggplot() +
  #geom_line(data = test_par1, aes(x = time, y = value), color = "black") +
  geom_line(data = test_par2, aes(x = time, y = value), color = "blue") +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_updated6_2, aes(x = time, y = value), color = "red") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

## trying optimization on new model
```{r}
## tring R based cue system. vode vs lsoda makes little difference
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_updated7 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi4,
                      time_range = time_range,
                      df = 3,
                      cue = "R",
                      cue_range = seq(0, 8.89*10^6, by = 1000),
                      solver = "lsoda",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time
ch_si_i_I_20.opt_tsukushi_updated7$par #9.164356  33.327181 -19.870258  -8.444712
ch_si_i_I_20.opt_tsukushi_updated7$value #-9.199341

ch_si_i_I_20_tsukushi_updated7_cr <- par_to_df(ch_si_i_I_20.opt_tsukushi_updated7, seq(0, 8.89*10^6, by = 1000))
ggplot() +
  geom_line(data =ch_si_i_I_20_tsukushi_updated7_cr, aes(x = cue_range, y = cr))

ch_si_i_I_20.dyn_tsukushi_updated7 <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_updated7$par,
  immunity = "tsukushi",
  parameters = parameters_tsukushi4,
  time_range = time_range,
  df = 3,
  cue = "R",
  cue_range = seq(0, 8.89*10^6, by = 1000),
  solver = "vode",
  dyn = TRUE,
  integration = "trapezoid")

ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_updated7, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

# trying incorporating adaptive immunity with Tsukushi model
```{r}
# for 10^5 
parameters_tsukushi6 <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = exp(reaction_norms_median[4,2])*7, # approximate
                mum = 48, 
                mug = 4, 
                I0 = 438.5965, # 10 times the starting volume
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = exp(reaction_norms_median[4,3]),
                psiw = exp(reaction_norms_median[4,4]),
                phin = exp(reaction_norms_median[4,5]), 
                phiw = exp(reaction_norms_median[4,6]),
                iota = 2.18*(10^6), # please surround with bracket. Or else R does wrong calculation
                rho = exp(reaction_norms_median[4,1])*0.25,
                psia = 1,
                epsilon = 2.5,
                phia = exp(reaction_norms_median[4,5]), # put long half life here
                theta = 7)

setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

## did not converge with vode or lsoda. Might need to change integration method. Also starting point changes shit. OMG
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_updated8 <- optimParallel(par = dummy_cr.mod$coefficients,# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi6,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range,
                      solver = "lsoda",
                      integration = "trapezoid",
                      adaptive = TRUE)

stopCluster(cl) 
end.time <- Sys.time()

## plotting infection dynamics
ch_si_i_I_20.dyn_tsukushi_updated8 <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_updated8$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi6,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "t",
                                         cue_range = time_range,
                                         solver = "vode",
                                         dyn = TRUE,
  integration = "trapezoid",
  adaptive = TRUE)

ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_updated8, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

# trying vode with better integration
## also increased half life of adaptive 
```{r}
parameters_tsukushi7 <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = exp(reaction_norms_median[4,2])*7, # approximate
                mum = 48, 
                mug = 4, 
                I0 = 438.5965, # 10 times the starting volume
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = exp(reaction_norms_median[4,3]),
                psiw = exp(reaction_norms_median[4,4]),
                phin = exp(reaction_norms_median[4,5]), 
                phiw = exp(reaction_norms_median[4,6]),
                iota = 2.18*(10^6), # please surround with bracket. Or else R does wrong calculation
                rho = exp(reaction_norms_median[4,1])*0.25,
                psia = 1,
                epsilon = 2.5,
                phia = exp(reaction_norms_median[4,6]), # put long half life here
                theta = 7)

## did not converge with vode or lsoda. Might need to change integration method. Also starting point changes shit. OMG
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_updated9 <- optimParallel(par = dummy_cr.mod$coefficients,# paramter search space gives us all 0.05 cr
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi7,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range5, # max 2.18*10^6
                      solver = "vode",
                      integration = "simpson", # changed to simpson
                      adaptive = TRUE)

stopCluster(cl) 
end.time <- Sys.time()
ch_si_i_I_20.opt_tsukushi_updated9$value #-6.821705. Not converged!
ch_si_i_I_20.opt_tsukushi_updated9$par #1.100000e+00, 6.282725e-17, 3.146502e-21,  3.141205e-17 

ch_si_i_I_20.dyn_tsukushi_updated9 <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_updated9$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi6,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range5,
                                         solver = "vode",
                                         dyn = TRUE,
  integration = "simpson",
  adaptive = TRUE)

ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_updated9, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

# trying hybrid genetic algorithm
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

# first test with no adaptive immune. Stuck mutation rate of 0.1
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)

ch_si_ts_I_20.ga <- ga(type = "real-valued", 
         fitness =  function(parameters_cr)
           chabaudi_si_opt_fast(
           parameters_cr, 
           immunity = "tsukushi",
           parameters = parameters_tsukushi6,
           time_range = time_range,
           df = 3,
           cue = "I",
           cue_range = cue_range5,
           solver = "vode",
           integration = "simpson"),
         lower = rep(-500,4), 
         upper = rep(500,4), 
         popSize = 100, 
         maxiter = 200, 
         run = 30,
         pmutation = 0.3, # higher given local minimum stuck
         parallel = TRUE,
         seed = 137,
         keepBest = TRUE)
stopCluster(cl)
end.time <- Sys.time()
end.time-start.time # 4.05263 hours


ch_si_ts_I_20.ga@solution #16.9642 -492.382 -403.6787 -274.0575

ch_si_ts_I_20_ga.cr <- par_to_df(ch_si_ts_I_20.ga@solution, cue_range5)

ggplot() +
  geom_line(data=ch_si_ts_I_20_ga.cr, aes(x = cue_range, y = cr)) +
  xlim(0,50000)+
  theme_bw()

ch_si_ts_I_20_ga.dy <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_ts_I_20.ga@solution,
  immunity = "tsukushi",
  parameters = parameters_tsukushi6,
  time_range = time_range,
  df = 3,
  cue = "I",
  cue_range = cue_range5,
  solver = "vode",
  dyn = TRUE,
  integration = "simpson")

I_total <- ch_si_ts_I_20_ga.dy %>% 
  dplyr::filter(variable == "I" | variable == "Ig") %>% 
  dplyr::group_by(time) %>% 
  dplyr::summarise(I_total = sum(value))

I_totaldf <- data.frame(variable = rep("I_total", nrow(I_total)), time = I_total$time, value = I_total$I_total)


ch_si_ts_I_20_ga.dy_2 <- rbind(ch_si_ts_I_20_ga.dy, I_totaldf)

ggplot() +
  geom_line(data = ch_si_ts_I_20_ga.dy_2, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_updated7, aes(x = time, y = value), color = "blue") +
  theme_bw()

parameters_tsukushi4
```

# trying out new lags function
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_lag.R")
source("chabaudi_si_opt_fast.R")


# very different!
test <- sample(-100:100,4)

# with 10^4 parameters with short 0cue range. 0.05 constant investment rate
lag_test1.dyn <- chabaudi_si_opt_lag(
  parameters_cr = ch_si_ts_I_20.ga@solution,
  immunity = "tsukushi",
  parameters = parameters_tsukushi4,
  time_range = time_range,
  df = 3,
  cue = "I",
  cue_range = cue_range5,
  solver = "vode",
  dyn = TRUE,
  integration = "trapezoid")

# repeat same with original model
fast_test1.dyn <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_ts_I_20.ga@solution,
  immunity = "tsukushi",
  parameters = parameters_tsukushi4,
  time_range = time_range,
  df = 3,
  cue = "I",
  cue_range = cue_range5,
  solver = "vode",
  dyn = TRUE,
  integration = "trapezoid")

# same conversion rate... lagged model produce very different results???
ggplot() +
  geom_line(data = lag_test1.dyn, aes(x = time, y = value), color = "red") +
  geom_line(data = fast_test1.dyn, aes(x = time, y = value), color = "blue") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

# optimization
```{r}
# run optimization. cannot find convergence
## by R
R_range <- seq(0,8.89*10^6,by = 1000)

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
lag_test1.opt <- optimParallel(par = dummy_cr.mod$coefficients,# paramter search space gives us all 0.05 cr
                      fn = chabaudi_si_opt_lag, 
                      control = list(trace = 6, fnscale = -1),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi4,
                      time_range = time_range,
                      df = 3,
                      cue = "R",
                      cue_range = R_range, 
                      solver = "vode",
                      integration = "simpson")
stopCluster(cl)
end.time <- Sys.time()
lag_test1.opt$par # 9.120678,33.836034,-17.536676,-9.024782 
lag_test1.opt$value #7.588328

# get infection dynamics
lag_test1.optdyn <- chabaudi_si_opt_lag(
  parameters_cr = lag_test1.opt$par,
  immunity = "tsukushi",
  parameters = parameters_tsukushi4,
  time_range = time_range,
  df = 3,
  cue = "R",
  cue_range = R_range,
  solver = "vode",
  dyn = TRUE,
  integration = "simpson")

# convesion
lag_test1.cr <- par_to_df(lag_test1.opt$par, R_range)

ggplot()+
  geom_line(data = lag_test1.cr, aes(x = cue_range, y = cr)) +
  theme_bw()

# plot
ggplot() +
  #geom_line(data = lag_test1.dyn, aes(x = time, y = value), color = "red") +
  #geom_line(data = fast_test1.dyn, aes(x = time, y = value), color = "blue") +
  geom_line(data = lag_test1.optdyn, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()

parameters_tsukushi4
```

# testing with ga
```{r}
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
lag_test1.ga <- ga(type = "real-valued", 
         fitness =  function(parameters_cr)
           chabaudi_si_opt_lag(
           parameters_cr, 
           immunity = "tsukushi",
           parameters = parameters_tsukushi4,
           time_range = time_range,
           df = 3,
           cue = "I",
           cue_range = cue_range5,
           solver = "vode",
           integration = "simpson"),
         lower = rep(-500,4), 
         upper = rep(500,4), 
         popSize = 100, 
         maxiter = 200, 
         run = 30,
         pmutation = 0.3, # higher given local minimum stuck
         parallel = TRUE,
         seed = 137,
         keepBest = TRUE)
stopCluster(cl)
end.time <- Sys.time()
end.time-start.time #1.353508 hours
lag_test1.ga@solution #0.2744434 -28.84773 495.4096 153.2123
lag_test1.ga@fitnessValue #7.323752

lag_test1.gacr <- par_to_df(lag_test1.ga@solution, cue_range5)
ggplot() +
  geom_line(data = lag_test1.gacr, aes(x = cue_range, y = cr)) +
  theme_bw()


lag_test1.gadyn <- chabaudi_si_opt_lag(
  parameters_cr = lag_test1.ga@solution,
  immunity = "tsukushi",
  parameters = parameters_tsukushi4,
  time_range = time_range,
  df = 3,
  cue = "I",
  cue_range = cue_range5,
  solver = "vode",
  dyn = TRUE,
  integration = "simpson")

ggplot() +
  geom_line(data = lag_test1.optdyn, aes(x = time, y = value), color = "red") +
  geom_line(data = lag_test1.gadyn, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

# finding the appropriate search space
Redefining spline transformation to normalization so that we can better interpret coefficients. Testing out appropraite search spaces. It seems that beyond -100:100, additional increase in coefficients have little effect on spline shape. honestly, even at 50, very little difference. But keep at 100 to play safe.
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("par_to_df.R") 

# function to generate different parameter combinations
test_par <- function(position, mutation_value){
  par_ls <- rep(list(rep(1,4)), length(mutation_value))
  for(i in 1:length(mutation_value)){
    par_ls[[i]][position] <- mutation_value[i]
  }
  return(par_ls)
}

# search space determination
# position 1 (-10:5)
# position 2 (-500:100)
# position 3 (-1000:500)
# position 4 (-100000:500) # very large range???
par_results <- test_par(c(3),c(5,100,500,-5,-1000,-2000))

test0 <- par_to_df(rep(1,4), time_range)
test <- par_to_df(par_results[[1]], time_range)
test1 <- par_to_df(par_results[[2]], time_range)
test2 <- par_to_df(par_results[[3]], time_range)
test3 <- par_to_df(par_results[[4]], time_range)
test4 <- par_to_df(par_results[[5]], time_range)
test5 <- par_to_df(par_results[[6]], time_range)

ggplot() +
  geom_line(data = test0, aes(x = cue_range, y = cr), linetype = "dotted") +
  geom_line(data = test, aes(x = cue_range, y = cr), color = "red") + #5
  geom_line(data = test1, aes(x = cue_range, y = cr), color = "orange") + #100
  geom_line(data = test2, aes(x = cue_range, y = cr), color = "yellow", linetype = "dotted") + #500
  geom_line(data = test3, aes(x = cue_range, y = cr), color = "navy") + #-5
  geom_line(data = test4, aes(x = cue_range, y = cr), color = "blue") + #-100
  geom_line(data = test5, aes(x = cue_range, y = cr), color = "cyan", linetype = "dotted") + #-500
  theme_bw()
```

# after changing spline transformation to normalization, retesting optimization
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("par_to_df.R") 
source("chabaudi_si_opt_fast.R") 


# normalization
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_ni_t_20.opt <- optimParallel(par = rep(0.5, 4), 
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6, fnscale = -1),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range)

stopCluster(cl) #0.4999969 0.9291013 0.6145913 1.1871088
end.time <- Sys.time()
end.time-start.time #4.558821 mins
ch_si_ni_t_20.opt$value #12.45763

# exp(-exp)
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_ni_t_20.opt_exp <- optimParallel(par = rep(0.5, 4), 
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6, fnscale = -1),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range,
                      transformation = "exp")

stopCluster(cl) #6.29106 -15.3837 0.318377 -11.3767 
end.time <- Sys.time()
end.time-start.time
ch_si_ni_t_20.opt_exp$value #13.103090 (better than normalization)

## logistics
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_ni_t_20.opt_logit <- optimParallel(par = rep(0.5, 4), 
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6, fnscale = -1),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range,
                      solver = "vode",
                      transformation = "logit")

stopCluster(cl) #-10.393609  23.708464  -0.360155  17.501375
end.time <- Sys.time()
end.time-start.time
ch_si_ni_t_20.opt_exp$value #13.051555 
ch_si_ni_t_20.opt_logit$par

## plot infection dynamics. Very different?
ch_si_ni_t_20.dyn <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_ni_t_20.opt$par,
  immunity = "ni",
  parameters = parameters,
  time_range = time_range,
  df = 3,
  cue = "t",
  cue_range = time_range,
  solver = "vode",
  dyn = TRUE)

ch_si_ni_t_20.dyn_exp <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_ni_t_20.opt_exp$par,
  immunity = "ni",
  parameters = parameters,
  time_range = time_range,
  df = 3,
  cue = "t",
  cue_range = time_range,
  solver = "vode",
  dyn = TRUE,
  transformation = "exp")

ch_si_ni_t_20.dyn_logit <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_ni_t_20.opt_logit$par,
  immunity = "ni",
  parameters = parameters,
  time_range = time_range,
  df = 3,
  cue = "t",
  cue_range = time_range,
  solver = "vode",
  dyn = TRUE,
  transformation = "logit")

#################
ggplot() +
  geom_line(data = ch_si_ni_t_20.dyn, aes(x = time, y = value), color = "red") +
  geom_line(data = ch_si_ni_t_20.dyn_exp, aes(x = time, y = value), color = "blue") +
  geom_line(data = ch_si_ni_t_20.dyn_logit, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()


#### cr vs cue
ch_si_ni_t_20.cr <- par_to_df(ch_si_ni_t_20.opt$par, time_range, transformation = "norm")
ch_si_ni_t_20.cr_exp <- par_to_df(ch_si_ni_t_20.opt_exp$par, time_range, transformation = "exp")
ch_si_ni_t_20.cr_logit <- par_to_df(ch_si_ni_t_20.opt_logit$par, time_range, transformation = "logit")

ggplot() +
  geom_line(data = ch_si_ni_t_20.cr, aes(x = cue_range, y = cr)) +
  geom_line(data = ch_si_ni_t_20.cr_exp, aes(x = cue_range, y = cr), color = "red") +
  geom_line(data = ch_si_ni_t_20.cr_logit, aes(x = cue_range, y = cr), color = "blue") +
  theme_bw()
```

# testing pefermance for cue based
All didn't coverge properly. Nontheless, exp seems to be still the best. 
```{r}
# normalization
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_ni_I_20.opt <- optimParallel(par = rep(0.5, 4), 
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6, fnscale = -1),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range5,
                      solver = "vode",
                      transformation = "norm")

stopCluster(cl) 
ch_si_ni_I_20.opt$value #12.69503
ch_si_ni_I_20.opt$par #0.4964347  0.9340670 -0.6220811  0.3111943

ch_si_ni_I_20.dyn <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_ni_I_20.opt$par,
  immunity = "ni",
  parameters = parameters,
  time_range = time_range,
  df = 3,
  cue = "I",
  cue_range = cue_range5,
  solver = "vode",
  dyn = TRUE,
  transformation = "norm")

# exp
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_ni_I_20.opt_exp <- optimParallel(par = rep(0.5, 4), 
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6, fnscale = -1),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range5,
                      transformation = "exp",
                      solver= "vode")

stopCluster(cl)
ch_si_ni_I_20.opt_exp$value #12.87371
ch_si_ni_I_20.opt_exp$par #1.919289 -42.692728 389.488521   2.796794

ch_si_ni_I_20.dyn_exp <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_ni_I_20.opt_exp$par,
  immunity = "ni",
  parameters = parameters,
  time_range = time_range,
  df = 3,
  cue = "I",
  cue_range = cue_range5,
  solver = "vode",
  dyn = TRUE,
  transformation = "exp")

# logit
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_ni_I_20.opt_logit <- optimParallel(par = rep(0.5, 4), 
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6, fnscale = -1),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range5,
                      transformation = "logit",
                      solver = "vode")

stopCluster(cl)
ch_si_ni_I_20.opt_logit$par #-3.61183 57.93911 36.11553 11.14561
ch_si_ni_I_20.opt_logit$value #12.67279

ch_si_ni_I_20.dyn_logit <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_ni_I_20.opt_logit$par,
  immunity = "ni",
  parameters = parameters,
  time_range = time_range,
  df = 3,
  cue = "I",
  cue_range = cue_range5,
  solver = "vode",
  dyn = TRUE,
  transformation = "logit")

#################
ggplot() +
  geom_line(data = ch_si_ni_I_20.dyn, aes(x = time, y = value), color = "red") +
  geom_line(data = ch_si_ni_I_20.dyn_exp, aes(x = time, y = value), color = "blue") +
  geom_line(data = ch_si_ni_I_20.dyn_logit, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()

#### cr vs cue
ch_si_ni_I_20.cr <- par_to_df(ch_si_ni_I_20.opt$par, cue_range5, transformation = "norm")
ch_si_ni_I_20.cr_exp <- par_to_df(ch_si_ni_I_20.opt_exp$par, cue_range5, transformation = "exp")
ch_si_ni_I_20.cr_logit <- par_to_df(ch_si_ni_I_20.opt_logit$par, cue_range5, transformation = "logit")

ggplot() +
  geom_line(data = ch_si_ni_I_20.cr, aes(x = cue_range, y = cr)) +
  geom_line(data = ch_si_ni_I_20.cr_exp, aes(x = cue_range, y = cr), color = "red") +
  geom_line(data = ch_si_ni_I_20.cr_logit, aes(x = cue_range, y = cr), color = "blue") +
  theme_bw()
```

```{r}

ga_custom <- function(type = c("binary", "real-valued", "permutation"), 
               fitness, ...,
               lower, upper, nBits,
               population = gaControl(type)$population,
               selection = gaControl(type)$selection,
               crossover = gaControl(type)$crossover, 
               mutation = gaControl(type)$mutation,
               popSize = 50, 
               pcrossover = 0.8, 
               pmutation = 0.1, 
               elitism = base::max(1, round(popSize*0.05)), 
               updatePop = FALSE,
               postFitness = NULL,
               maxiter = 100,
               run = maxiter,
               maxFitness = Inf,
               names = NULL,
               suggestions = NULL,
               optim = FALSE,
               optimArgs = list(method = "L-BFGS-B", 
                                poptim = 0.05,
                                pressel = 0.5,
                                control = list(fnscale = -1, maxit = 100)),
               keepBest = FALSE,
               parallel = FALSE,
               monitor = if(interactive()) gaMonitor else FALSE,
               seed = NULL) 
{
  
  call <- match.call()
  
  type <- match.arg(type, choices = eval(formals(ga)$type))
  
  if(!is.function(population)) population <- get(population)
  if(!is.function(selection))  selection  <- get(selection)
  if(!is.function(crossover))  crossover  <- get(crossover)
  if(!is.function(mutation))   mutation   <- get(mutation)
  
  if(missing(fitness))
  { stop("A fitness function must be provided") }
  if(!is.function(fitness)) 
  { stop("A fitness function must be provided") }
  if(popSize < 10) 
  { warning("The population size is less than 10.") }
  if(maxiter < 1) 
  { stop("The maximum number of iterations must be at least 1.") }
  if(elitism > popSize) 
  { stop("The elitism cannot be larger that population size.") }
  elitism <- as.integer(elitism)
  if(pcrossover < 0 | pcrossover > 1)
  { stop("Probability of crossover must be between 0 and 1.") }
  if(is.numeric(pmutation))
  { 
    if(pmutation < 0 | pmutation > 1)
    { stop("If numeric probability of mutation must be between 0 and 1.") }
    else if(!is.function(population))
    { stop("pmutation must be a numeric value in (0,1) or a function.") }
  }
  
  # check for min and max arguments instead of lower and upper
  callArgs <- list(...)
  if(any("min" %in% names(callArgs)))
  {
    lower <- callArgs$min
    callArgs$min <- NULL
    warning("'min' arg is deprecated. Use 'lower' instead.")
  }
  if(any("max" %in% names(callArgs)))
  {
    upper <- callArgs$max
    callArgs$max <- NULL
    warning("'max' arg is deprecated. Use 'upper' instead.")
  }
  
  if(missing(lower) & missing(upper) & missing(nBits))
  { stop("A lower and upper range of values (for 'real-valued' or 'permutation' GA) or nBits (for 'binary' GA) must be provided!") }
  
  # check GA search type 
  switch(type, 
         "binary"      = { nBits <- as.vector(nBits)[1]
         lower <- upper <- NA
         nvars <- nBits 
         if(is.null(names))
           names <- paste0("x", 1:nvars)
         },
         "real-valued" = { lnames <- names(lower)
         unames <- names(upper)
         lower <- as.vector(lower)
         upper <- as.vector(upper)
         nBits <- NA
         if(length(lower) != length(upper))
           stop("lower and upper must be vector of the same length!")
         nvars <- length(upper)
         if(is.null(names) & !is.null(lnames))
           names <- lnames
         if(is.null(names) & !is.null(unames))
           names <- unames
         if(is.null(names))
           names <- paste0("x", 1:nvars)
         },
         "permutation" = { lower <- as.vector(lower)[1]
         upper <- as.vector(upper)[1]
         nBits <- NA
         nvars <- length(seq.int(lower,upper))
         if(is.null(names))
           names <- paste0("x", 1:nvars)
         }
  )
  
  # check suggestions
  if(is.null(suggestions))
  { suggestions <- matrix(nrow = 0, ncol = nvars) }
  else
  { if(is.vector(suggestions)) 
  { if(nvars > 1) suggestions <- matrix(suggestions, nrow = 1)
  else          suggestions <- matrix(suggestions, ncol = 1) }
    else
    { suggestions <- as.matrix(suggestions) }
    if(nvars != ncol(suggestions))
      stop("Provided suggestions (ncol) matrix do not match number of variables of the problem!")
  }
  
  # check monitor arg
  if(is.logical(monitor))
  { if(monitor) monitor <- gaMonitor }
  if(is.null(monitor)) monitor <- FALSE
  
  # if optim merge provided and default args for optim()
  if(optim)
  { # merge default and provided parameters
    optimArgs.default <- eval(formals(ga)$optimArgs)
    optimArgs.default$control[names(optimArgs$control)] <- optimArgs$control
    optimArgs$control <- NULL
    optimArgs.default[names(optimArgs)] <- optimArgs
    optimArgs <- optimArgs.default; rm(optimArgs.default)
    if(any(optimArgs$method == c("L-BFGS-B", "Brent")))
    { optimArgs$lower <- lower
    optimArgs$upper <- upper }
    else
    { optimArgs$lower <- -Inf
    optimArgs$upper <- Inf }
    optimArgs$poptim <- min(max(0, optimArgs$poptim), 1)
    optimArgs$pressel <- min(max(0, optimArgs$pressel), 1)
    optimArgs$control$maxit <- as.integer(optimArgs$control$maxit)
    # ensure that optim maximise the fitness
    if(is.null(optimArgs$control$fnscale))
      optimArgs$control$fnscale <- -1
    if(optimArgs$control$fnscale > 0)
      optimArgs$control$fnscale <- -1*optimArgs$control$fnscale
  }
  
  # Start parallel computing (if needed)
  if(is.logical(parallel))
  { if(parallel) 
  { parallel <- startParallel(parallel)
  stopCluster <- TRUE }
    else
    { parallel <- stopCluster <- FALSE } 
  }
  else
  { stopCluster <- if(inherits(parallel, "cluster")) FALSE else TRUE
  parallel <- startParallel(parallel) 
  }
  on.exit(if(parallel & stopCluster)
    stopParallel(attr(parallel, "cluster")) )
  # define operator to use depending on parallel being TRUE or FALSE
  `%DO%` <- if(parallel && requireNamespace("doRNG", quietly = TRUE)) 
    doRNG::`%dorng%`
  else if(parallel) `%dopar%` else `%do%`
  # set seed for reproducibility  
  if(!is.null(seed)) set.seed(seed)
  i. <- NULL # dummy to trick R CMD check 
  
  fitnessSummary <- matrix(as.double(NA), nrow = maxiter, ncol = 6)
  colnames(fitnessSummary) <- names(gaSummary(rnorm(10)))
  bestSol <- if(keepBest) vector(mode = "list", length = maxiter)
  else         list()
  Fitness <- rep(NA, popSize)
  
  object <- new("ga", 
                call = call, 
                type = type,
                lower = lower, 
                upper = upper, 
                nBits = nBits, 
                names = if(is.null(names)) character() else names,
                popSize = popSize,
                iter = 0, 
                run = 1, 
                maxiter = maxiter,
                suggestions = suggestions,
                population = matrix(), 
                elitism = elitism, 
                pcrossover = pcrossover, 
                pmutation = if(is.numeric(pmutation)) pmutation else NA,
                optim = optim,
                fitness = Fitness, 
                summary = fitnessSummary,
                bestSol = bestSol)
  
  if(maxiter == 0)
    return(object)
  
  # generate beginning population
  Pop <- matrix(as.double(NA), nrow = popSize, ncol = nvars)
  ng <- min(nrow(suggestions), popSize)
  if(ng > 0) # use suggestion if provided
  { Pop[1:ng,] <- suggestions }
  # fill the rest with a random population
  if(popSize > ng)
  { Pop[(ng+1):popSize,] <- population(object)[1:(popSize-ng),] }
  object@population <- Pop
  
  # create different 2-strain tournaments within population
  tournaments <- combn(x = seq_len(popSize), m = 2, simplify = FALSE)
  
  # start iterations
  for(iter in seq_len(maxiter))
  {
    object@iter <- iter
    
    # evalute fitness function (when needed) 
    if(!parallel)
    { for(i in seq_len(popSize))
      if(is.na(Fitness[i]))
      { fit <- do.call(fitness, c(list(Pop[i,]), callArgs)) 
      if(updatePop)
        Pop[i,] <- attributes(fit)[[1]]
      Fitness[i] <- fit
      }
    }
    else
    { Fitness <- foreach(i. = seq_len(popSize), .combine = "c") %DO%
      { if(is.na(Fitness[i.])) 
        do.call(fitness, c(list(Pop[i.,]), callArgs)) 
        else                   
          Fitness[i.] 
      }
    }
    else{
      Fitness <- foreach(i. = seq_len(tournaments), .combine = "c") %DO%
      { if(is.na(Fitness[i.])) 
        do.call(fitness, c(list(Pop[tournaments[[i]],][1,], Pop[tournaments[[i]],][2,]), callArgs)) 
        else                   
          Fitness[i.] 
    }
    
    # update object
    object@population <- Pop
    object@fitness <- Fitness
    
    # Local search optimisation
    if(optim & (type == "real-valued"))
    {
      if(optimArgs$poptim > runif(1))
      { # perform local search from random selected solution
        # with prob proportional to fitness
        i <- sample(1:popSize, size = 1, 
                    prob = optimProbsel(Fitness, q = optimArgs$pressel))
        # run local search
        opt <- try(suppressWarnings(
          do.call(stats::optim, 
                  c(list(fn = fitness,
                         par = Pop[i,],
                         method = optimArgs$method,
                         lower = optimArgs$lower,
                         upper = optimArgs$upper,
                         control = optimArgs$control), 
                    callArgs))
        ), silent = TRUE)
        if(is.function(monitor))
        { if(!inherits(opt, "try-error"))
          cat("\b | Local search =", 
              format(opt$value, digits = getOption("digits")))
          else cat("\b |", opt[1])
          cat("\n")
        }
        if(!inherits(opt, "try-error"))
        { Pop[i,] <- opt$par
        Fitness[i] <- opt$value }
        # update object
        object@population <- Pop
        object@fitness <- Fitness
        # update iterations summary
        fitnessSummary[iter,] <- gaSummary(object@fitness)
        object@summary <- fitnessSummary
      }
    }
    
    if(keepBest) 
    { 
      object@bestSol[[iter]] <- unique(Pop[Fitness == max(Fitness, na.rm = TRUE),, drop=FALSE]) 
    }
    
    # apply a user's defined function to update the GA object
    if(is.function(postFitness))
    { 
      object <- do.call(postFitness, c(object, callArgs))
      Fitness <- object@fitness
      Pop <- object@population
    }
    
    # update iterations summary
    fitnessSummary[iter,] <- gaSummary(object@fitness)
    object@summary <- fitnessSummary
    
    if(is.function(monitor)) 
    { monitor(object) }
    
    # check stopping criteria
    if(iter > 1)
      object@run <- garun(fitnessSummary[seq(iter),1])
    if(object@run >= run) break  
    if(max(Fitness, na.rm = TRUE) >= maxFitness) break
    if(object@iter == maxiter) break  
    
    ord <- order(Fitness, decreasing = TRUE)
    PopSorted <- Pop[ord,,drop=FALSE]
    FitnessSorted <- Fitness[ord]
    
    # selection
    if(is.function(selection))
    { 
      sel <- selection(object)
      # sel <- do.call(selection, c(object, callArgs))
      Pop <- sel$population
      Fitness <- sel$fitness
    }
    else
    { sel <- sample(1:popSize, size = popSize, replace = TRUE)
    Pop <- object@population[sel,]
    Fitness <- object@fitness[sel]
    }
    object@population <- Pop
    object@fitness <- Fitness
    
    # crossover
    if(is.function(crossover) & pcrossover > 0)
    { nmating <- floor(popSize/2)
    mating <- matrix(sample(1:(2*nmating), size = (2*nmating)), ncol = 2)
    for(i in seq_len(nmating))
    { if(pcrossover > runif(1))
    { parents <- mating[i,]
    Crossover <- crossover(object, parents)
    Pop[parents,] <- Crossover$children
    Fitness[parents] <- Crossover$fitness
    }
    }             
    object@population <- Pop
    object@fitness <- Fitness
    }
    
    # mutation
    pm <- if(is.function(pmutation)) pmutation(object) else pmutation
    if(is.function(mutation) & pm > 0)
    { for(i in seq_len(popSize)) 
    { if(pm > runif(1)) 
    { Mutation <- mutation(object, i)
    Pop[i,] <- Mutation
    Fitness[i] <- NA
    }
    }
      object@population <- Pop
      object@fitness <- Fitness
    }
    
    # elitism
    if(elitism > 0) # (elitism > 0 & iter > 1) 
    { ord <- order(object@fitness, na.last = TRUE)
    u <- which(!duplicated(PopSorted, margin = 1))
    Pop[ord[1:elitism],] <- PopSorted[u[1:elitism],]
    Fitness[ord[1:elitism]] <- FitnessSorted[u[1:elitism]]
    object@population <- Pop
    object@fitness <- Fitness
    } 
    
  }
  
  # if optim is required perform a local search from the best 
  # solution at the end of GA iterations
  if(optim & (type == "real-valued"))
  { 
    optimArgs$control$maxit <- rev(optimArgs$control$maxit)[1]
    i <- which.max(object@fitness)
    # if not provided suggest approx parscale
    # if(is.null(optimArgs$control$parscale))
    #   optimArgs$control$parscale <- 10^round(log10(abs(object@population[i,])+1))
    # run local search
    opt <- try(suppressWarnings(
      do.call(stats::optim, 
              c(list(fn = fitness,
                     par = object@population[i,],
                     method = optimArgs$method,
                     lower = optimArgs$lower,
                     upper = optimArgs$upper,
                     control = optimArgs$control), 
                callArgs))
    ), silent = TRUE)
    if(is.function(monitor))
    { if(!inherits(opt, "try-error"))
      cat("\b | Final local search =",
          format(opt$value, digits = getOption("digits")))
      else cat("\b |", opt[1])
    }
    if(!inherits(opt, "try-error"))
    { object@population[i,] <- opt$par
    object@fitness[i] <- opt$value }
  }
  
  # if(is.function(monitor)) 
  #   { cat("\n"); flush.console() }
  
  # in case of premature convergence remove NAs from summary 
  # fitness evalutations
  object@summary <- na.exclude(object@summary)
  attr(object@summary, "na.action") <- NULL
  
  # get solution(s)
  object@fitnessValue <- max(object@fitness, na.rm = TRUE)
  valueAt <- which(object@fitness == object@fitnessValue)
  solution <- object@population[valueAt,,drop=FALSE]
  if(nrow(solution) > 1)
  { # find unique solutions to precision given by default tolerance
    eps <- gaControl("eps")
    solution <- unique(round(solution/eps)*eps, margin = 1)
  }
  colnames(solution) <- parNames(object)
  object@solution <- solution
  if(keepBest)
    object@bestSol <- object@bestSol[!sapply(object@bestSol, is.null)]  
  
  # return an object of class 'ga'
  return(object)
}

setClassUnion("numericOrNA", members = c("numeric", "logical"))

setClass(Class = "ga", 
         representation(call = "language",
                        type = "character",
                        lower = "numericOrNA", 
                        upper = "numericOrNA", 
                        nBits = "numericOrNA", 
                        names = "character",
                        popSize = "numeric",
                        iter = "numeric", 
                        run = "numeric", 
                        maxiter = "numeric",
                        suggestions = "matrix",
                        population = "matrix",
                        elitism = "numeric", 
                        pcrossover = "numeric", 
                        pmutation = "numericOrNA",
                        optim = "logical",
                        fitness = "numericOrNA",
                        summary = "matrix",
                        bestSol = "list",
                        fitnessValue = "numeric",
                        solution = "matrix"
         ),
         package = "GA" 
) 

setMethod("print", "ga", function(x, ...) str(x))

setMethod("show", "ga",
          function(object)
          { cat("An object of class \"ga\"\n")
            cat("\nCall:\n", deparse(object@call), "\n\n",sep="")
            cat("Available slots:\n")
            print(slotNames(object))
          }) 

summary.ga <- function(object, ...)
{
  nvars <- ncol(object@population)
  varnames <- parNames(object)
  domain <- NULL
  if(object@type == "real-valued")
  { domain <- rbind(object@lower, object@upper)
  rownames(domain) <- c("lower", "upper")
  if(ncol(domain) == nvars) 
    colnames(domain) <- varnames
  }
  suggestions <- NULL
  if(nrow(object@suggestions) > 0) 
  { suggestions <- object@suggestions
  dimnames(suggestions) <- list(1:nrow(suggestions), varnames) 
  }
  
  out <- list(type = object@type,
              popSize = object@popSize,
              maxiter = object@maxiter,
              elitism = object@elitism,
              pcrossover = object@pcrossover,
              pmutation = object@pmutation,
              domain = domain,
              suggestions = suggestions,
              iter = object@iter,
              fitness = object@fitnessValue,
              solution = object@solution)
  class(out) <- "summary.ga"
  return(out)
}

setMethod("summary", "ga", summary.ga)

print.summary.ga <- function(x, digits = getOption("digits"), ...)
{
  dotargs <- list(...)
  if(is.null(dotargs$head)) dotargs$head <- 10
  if(is.null(dotargs$tail)) dotargs$tail <- 2
  if(is.null(dotargs$chead)) dotargs$chead <- 10
  if(is.null(dotargs$ctail)) dotargs$ctail <- 2
  
  cat(cli::rule(left = crayon::bold("Genetic Algorithm"), 
                width = min(getOption("width"),40)), "\n\n")
  # cat("+-----------------------------------+\n")
  # cat("|         Genetic Algorithm         |\n")
  # cat("+-----------------------------------+\n\n")
  
  cat("GA settings: \n")
  cat(paste("Type                  = ", x$type, "\n"))
  cat(paste("Population size       = ", x$popSize, "\n"))
  cat(paste("Number of generations = ", x$maxiter, "\n"))
  cat(paste("Elitism               = ", x$elitism, "\n"))
  cat(paste("Crossover probability = ", format(x$pcrossover, digits = digits), "\n"))
  cat(paste("Mutation probability  = ", format(x$pmutation, digits = digits), "\n"))
  #
  if(x$type == "real-valued")
  { cat(paste("Search domain = \n"))
    do.call(".printShortMatrix", 
            c(list(x$domain, digits = digits), 
              dotargs[c("head", "tail", "chead", "ctail")]))
  }
  #
  if(!is.null(x$suggestions))
  { cat(paste("Suggestions =", "\n"))
    do.call(".printShortMatrix", 
            c(list(x$suggestions, digits = digits), 
              dotargs[c("head", "tail", "chead", "ctail")]))
  }
  #
  cat("\nGA results: \n")
  cat(paste("Iterations             =", format(x$iter, digits = digits), "\n"))
  cat(paste("Fitness function value =", format(x$fitness, digits = digits), "\n"))
  if(nrow(x$solution) > 1) 
  { cat(paste("Solutions = \n")) }
  else
  { cat(paste("Solution = \n")) }
  do.call(".printShortMatrix", 
          c(list(x$solution, digits = digits), 
            dotargs[c("head", "tail", "chead", "ctail")]))
  #
  invisible()
}


plot.ga <- function(x, y, ylim, cex.points = 0.7,
                    col = c("green3", "dodgerblue3", adjustcolor("green3", alpha.f = 0.1)),
                    pch = c(16, 1), lty = c(1,2), legend = TRUE,
                    grid = graphics:::grid, ...)
{
  object <- x  # Argh.  Really want to use 'object' anyway
  is.final <- !(any(is.na(object@summary[,1])))
  iters <- if(is.final) 1:object@iter else 1:object@maxiter
  summary <- object@summary
  if(missing(ylim)) 
  { ylim <- c(max(apply(summary[,c(2,4)], 2, 
                        function(x) min(range(x, na.rm = TRUE, finite = TRUE)))),
              max(range(summary[,1], na.rm = TRUE, finite = TRUE))) 
  }
  
  plot(iters, summary[,1], type = "n", ylim = ylim, 
       xlab = "Generation", ylab = "Fitness value", ...)
  if(is.final & is.function(grid)) 
  { grid(equilogs=FALSE) }
  points(iters, summary[,1], type = ifelse(is.final, "o", "p"),
         pch = pch[1], lty = lty[1], col = col[1], cex = cex.points)
  points(iters, summary[,2], type = ifelse(is.final, "o", "p"),
         pch = pch[2], lty = lty[2], col = col[2], cex = cex.points)
  if(is.final)
  { polygon(c(iters, rev(iters)), 
            c(summary[,4], rev(summary[,1])), 
            border = FALSE, col = col[3]) }
  else
  { title(paste("Iteration", object@iter), font.main = 1) }
  if(is.final & legend)
  { inc <- !is.na(col)
  legend("bottomright", 
         legend = c("Best", "Mean", "Median")[inc], 
         col = col[inc], pch = c(pch,NA)[inc], 
         lty = c(lty,1)[inc], lwd = c(1,1,10)[inc], 
         pt.cex = c(rep(cex.points,2), 2)[inc], 
         inset = 0.02) }
  
  out <- data.frame(iter = iters, summary)
  invisible(out)
}

setMethod("plot", "ga", plot.ga)

setGeneric(name = "parNames", 
           def = function(object, ...) { standardGeneric("parNames") }
)

setMethod("parNames", "ga",
          function(object, ...)
          { 
            names <- object@names
            nvars <- ncol(object@population)
            if(length(names) == 0)
            { names <- paste("x", 1:nvars, sep = "") }
            return(names)
          })

gaSummary <- function(x, ...)
{
  # compute summary for each step
  x <- na.exclude(as.vector(x))
  q <- fivenum(x)
  c(max = q[5], mean = mean(x), q3 = q[4], median = q[3], q1 = q[2], min = q[1])
}
```



