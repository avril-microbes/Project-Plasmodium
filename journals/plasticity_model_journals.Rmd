---
title: "plasticity_model_journal"
output: html_document
---

# Load libraries
```{r}
library(deSolve)
library(splines)
library(optimParallel)
library(ggplot2)
library(ggpubr)
library(tidyr)
library(magrittr)
library(Rcpp)
library(microbenchmark)
```

# Load functions
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt.R")
source("par_to_df.R")
source("chabaudi_si_opt_fast.R")
```

# Testing single infection model chabaudi_si_opt
See if results matches original script. It does!
```{r}
# define arguments
parameters_cr <- c(1,2,3,4)
parameters <- c(R1 = 8.5*10^6,
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 4*10^-6,
                alpha = 1, 
                alphag = 2, 
                beta = 10, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1)

time_range <- seq(0, 20, by = 1e-3)
cue_range <- seq(0, (3.7*10^5)*(8.5*10^6)/((3.7*10^5)-0.025*(8.5*10^6)), by = 1000) 

# Run model
## Name = parasite_infection(single/co-infection)_immunity_cue_infectiontimeperiod.opt
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_ni_I_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt, 
                      control = list(trace = 6),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)

stopCluster(cl) #1.543123 -309.396705  -25.689852    2.609319
end.time <- Sys.time()

time.taken <- end.time - start.time 
time.taken #12.18853 minutes

#setwd("/Users/avrilwang/Desktop/Project_Plasmodium/opt_parm")
#write.csv(ch_si_ni_i_20.opt$par, "ch_si_ni_i_20.csv")

# visualizing conversion rate across cue range
## convert parameter values to dataframe 
ch_si_ni_I_20_cr.df <- par_to_df(ch_si_ni_i_20.opt, cue_range)

## plot!
ch_si_ni_I_20_cr.df %>% 
    gather(key = "optimization_methods", value = "Transmission_investment", -cue_range) %>%
    ggplot(aes(x = cue_range, y = model)) +
    geom_line(alpha = 0.7) +
    xlab("Infected RBC density") +
    ylab("Transmission investment") +
  xlim(0,400000) +
    labs(color = "Optimization methods") +
    theme_bw()
```

# Testing chabaudi single infection model to see whether host immunity modulates optimal conversion rate strategy
```{r}
# run model for 20 days with immunity. Conversion rate still dependent on infected RBC density

## very slow at its current state.
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)

stopCluster(cl) #1.769660 -363.080884  -37.980378    1.827227
#setwd("/Users/avrilwang/Desktop/Project_Plasmodium/opt_parm")
#write.csv(ch_si_i_I_20.opt$par, "ch_si_i_I_20.csv")

# visualize
ch_si_i_I_20_cr.df <- par_to_df(ch_si_i_I_20.opt, cue_range)
ch_si_i_I_20_cr.df %>% 
    ggplot(aes(x = cue_range, y = model)) +
    geom_line(alpha = 0.7) +
    xlab("Infected RBC density") +
    ylab("Transmission investment") +
    xlim(0, 500000)+
    labs(color = "Optimization methods") +
    theme_bw()

ch_si_ni_I_20_cr.df %>% 
    ggplot(aes(x = cue_range, y = model)) +
    geom_line(alpha = 0.7) +
    xlab("Infected RBC density") +
    ylab("Transmission investment") +
    xlim(0, 500000)+
    labs(color = "Optimization methods") +
    theme_bw()

# seems to have earlier convesion rate rise with immunity
ch_si_i_I_20.opt$par
ch_si_ni_i_20.opt$par
```

# integrating C++ to speed up calculation
## test out whether using splines 2 bSpline will be faster. Nope!
## streamlined cr function section. much faster
```{r}
# get alternative y value
dummy_y.vals <- rep(0, length(cue_range)) 
# bind to make dummy data
dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
# fit basic spline with no internal knots. Here, increasing df increases knots
dummy_cr.mod <- lm(dummy_y.vals ~ bSpline(cue_range, degree = 3, df = 3))
# specify coefficient, or the way individual splines are multiplicated. Numberof parameters = d+k+1, or degree of freedom (shape of basis sline) + number of knots (0) here + 1.
dummy_cr.mod $coefficients <- c(1,2,3,4)
cr_fit <- exp(-exp(predict(dummy_cr.mod, newdata = data.frame(cue_range))))
cr2 <- splinefun(data.frame(cue_range, cr_fit))

# same as original cr function output
all.equal(cr, cr2)

# testing whether models run or not
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_ni_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)
stopCluster(cl) #1.543123 -309.396705  -25.689852    2.609319. Same as before
end.time <- Sys.time()

time.taken <- end.time - start.time 
time.taken #7.009973 minutes much faster. Compared to 12 minutes, much faster!
```

# testing after removing with list
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_cpp.R")

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_ni_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)
stopCluster(cl) #1.543123 -309.396705  -25.689852    2.609319
end.time <- Sys.time()
time.taken <- end.time - start.time 
time.taken #6.350481. Not sure whether this is much better or due to diff between programs
```

# changed method of solver to lsoda
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_cpp.R")

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_ni_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)
ch_si_i_ni_20.opt$par
stopCluster(cl) #1.543123 -309.396705  -25.689852    2.609319
end.time <- Sys.time()
time.taken <- end.time - start.time 
time.taken #6.533385. not too different
```

## testing with immunity function
## very slow with base integrate or integral from pracma
## investigating where the bottle neck is
```{r}

  df <- 3
  #-------------------------#
  # Define initial condition
  #------------------------#
  state <- c(R = 8.5*10^6,
             I = 43.85965,
             Ig = 0,
             M = 0,
             G = 0)
  
  #-------------------------#
  # Function to describe population 
  # structure of initial inoculum
  #------------------------#
  pulseBeta <- function(I0, sp, t){ 
    res = rep(NA, length(t))
    for (num in 1:length(t)){
      res[num] = I0*(dbeta(t[num], sp, sp))
    }
    return(res)}
  
  #-------------------------#
  # Define conversion rate function. 
  # Simplified to increase performance. 
  #------------------------#
  ## Define dummy data of conversion rate
  dummy_y.vals <- rep(0, length(cue_range)) 
  dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
  
  ## fit basic cubic spline with no internal knots. Here, increasing df increases knots.
  ## degree defines shape of basis spline. This shouldn't have any impact on ultimate result
  ## What matter is the number of knots, or df. Increasing df should give us more complex reaction norm
  dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(cue_range, degree = 3, df = df))
  dummy_cr.mod$data <- dummy_cr.data
  
  ## Assign coefficient to be optimized to the dummy conversion rate function
  dummy_cr.mod$coefficients <- parameters_cr
  
  ## use spline function to predict cr 
  cr_fit <- exp(-exp(predict(dummy_cr.mod, newdata = data.frame(cue_range))))
  
  ## Get spline function where cr ~ cue
  cr <- splinefun(cbind(cue_range, cr_fit))
  
  # define trapezoid function for estimation survival curve
  trapezoid <- function(f, lower, upper) {
  if (is.function(f) == FALSE) {
    stop('f must be a function with one parameter (variable)')
  }
  h <- upper - lower
  fxdx <- (h / 2) * (f(lower) + f(upper))
  return(fxdx)}
  
  #-------------------------#
  # Define single-infection model
  #------------------------#
   single_infection.fun <- function(t, state, parameters) {
      
      ## Define the lag terms. lag[1] = R, lag[2] = I, lag[3] = Ig, lag[4] = M, lag[5] = G
      if(t>parameters["alpha"]){lag1 = deSolve::lagvalue(t-parameters["alpha"])} # lag state for asexual development
      if(t>parameters["alphag"]){lag2 = deSolve::lagvalue(t-parameters["alphag"])} # lag state for gametocyte development
      
      ## get lag term index given cue
      lag.i <- match(cue, names(state))
      
      ## convert cue to variable in state
      cue_state <- state[cue]
      
      ## Define K, carrying capacity of RBC
      K <- parameters["lambda"]*parameters["R1"]/(parameters["lambda"]-parameters["mu"]*parameters["R1"])
      
      ## Define survival functions
      ### Survival of infected asexual RBC
      if(t>parameters["alpha"] && immunity == "ni"){
        S <- exp(-parameters["mu"]*parameters["alpha"])
      } else if(t>parameters["alpha"] && immunity =="i"){
        integrand <- function(x) {parameters["mu"]+parameters["a"]/(parameters["b"]+state["I"])}
        integrate_val <- trapezoid(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)
        S <- exp(-1*integrate_val)
      } else if(t<=parameters["alpha"] && immunity == "ni"){
        S <- exp(-parameters["mu"]*t)
      } else{
        integrand <- function(x) {parameters["mu"]+parameters["a"]/(parameters["b"]+state["I"])}
        integrate_val <- trapezoid(Vectorize(integrand), lower = 0, upper = t)
        S <- exp(-1*integrate_val)
      }
      
      ### Survival of gametocytes. We assume that infected
      ### RBC with gametocyte is not removed by immune response
      if(t<=parameters["alphag"]){
        Sg <- exp(-parameters["mu"]*t)
      } else{
        Sg <- exp(-parameters["mu"]*parameters["alphag"])}
      
      ## Define the models without lag terms. 
      dR <- parameters["lambda"]*(1-state["R"]/K)-parameters["mu"]*state["R"]-parameters["p"]*state["R"]*state["M"] # change in susceptible RBC
      if(immunity == "ni"){
        dI_nolag <- (1-cr(cue_state))*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["I"] # change in infected RBC density
      } else{
        dI_nolag <- (1-cr(cue_state))*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["I"]-(parameters["a"]*state["I"])/(parameters["b"]+state["I"]) # change in infected RBC density with immunity
      }
      dIg_nolag <- cr(cue_state)*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["Ig"] 
      dM_nolag <- -parameters["mum"]*state["M"]-parameters["p"]*state["R"]*state["M"]
      dG_nolag <- -parameters["mug"]*state["G"]
      
      ## Track states in initial cohort of infection
      if(t<=parameters["alpha"]){
        dI <- dI_nolag-pulseBeta(parameters["I0"], parameters["sp"], t)*S 
        dM <- dM_nolag+parameters["beta"]*pulseBeta(parameters["I0"], parameters["sp"], t)*S 
      }
      
      if(t<=parameters["alphag"]){
        dIg <- dIg_nolag-pulseBeta(parameters["Ig0"], parameters["sp"], t-1)*Sg 
        dG <- dG_nolag+pulseBeta(parameters["Ig0"], parameters["sp"], t-1)*Sg 
      }
      
      ## Track states after delay 
      if(t>parameters["alpha"]){
        dI <- dI_nolag-(1-cr(lag1[lag.i]))*parameters["p"]*lag1[1]*lag1[4]*S 
        dM <- dM_nolag+parameters["beta"]*(1-cr(lag1[lag.i]))*parameters["p"]*lag1[1]*lag1[4]*S 
      }
      
      if(t>parameters["alphag"]){
        dIg <- dIg_nolag-cr(lag2[lag.i])*parameters["p"]*lag2[1]*lag2[4]*Sg 
        dG <- dG_nolag+cr(lag2[lag.i])*parameters["p"]*lag2[1]*lag2[4]*Sg
      }
      
      ## Return the states
      return(list(c(dR, dI, dIg, dM, dG)))
  }

immunity <- "i"
cue <- "I"
  
# visualize where bottle neck with immunity run is. Integration is the greatest bottleneck 23000ms for integrate alone. Down to 11850 for trapezoid approximation
profvis::profvis({deSolve::dede(y = state, times = time_range, func = single_infection.fun, p = parameters, control=list(mxhist = 1e6))})

# trying lsoda
start.time <- Sys.time()
deSolve::dede(y = state, times = time_range, func = single_infection.fun, p = parameters, control=list(mxhist = 1e6), method = "lsoda")
end.time <- Sys.time()
end.time-start.time #31.42669 secs

# trying bdf
start.time <- Sys.time()
deSolve::dede(y = state, times = time_range, func = single_infection.fun, p = parameters, control=list(mxhist = 1e6), method = "bdf")
end.time <- Sys.time()
end.time-start.time #34.48703 secs'

# trying vode
start.time <- Sys.time()
deSolve::dede(y = state, times = time_range, func = single_infection.fun, p = parameters, control=list(mxhist = 1e6), method = "vode")
end.time <- Sys.time()
end.time-start.time #6.451089 
```

# testing the speed of different integrator
```{r}
# using stat integrate
t <- 10
integrand <- function(x) {parameters["mu"]+parameters["a"]/(parameters["b"]+state["I"])}
integrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$value

# cubature package. much slower
cubature::adaptIntegrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$integral

# pracma
pracma::integral(Vectorize(integrand), xmin = t-parameters["alpha"], xmax = t, method = "Kronrod")

# foreach
library(foreach)
foreach(i=1,.combine="c") %dopar%
{
  integrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$value;
}

# trapezoid estimation
trapezoid <- function(f, lower, upper) {
  if (is.function(f) == FALSE) {
    stop('f must be a function with one parameter (variable)')
  }
  h <- upper - lower
  fxdx <- (h / 2) * (f(lower) + f(upper))
  return(fxdx)
}

# composite trapezoid estimation
composite_trapezoid <- function(f, lower, upper, n) {
  if (is.function(f) == FALSE) {
    stop('f must be a function with one parameter (variable)')
  }
  h <- (upper - lower) / n
  j <- 1:n - 1
  xj <- lower + j * h
  approx <- (h / 2) * (f(lower) + 2 * sum(f(xj)) + f(upper))
  return(approx)
}

composite_trapezoid(Vectorize(integrand), lower = t-parameters["alpha"], upper = t, n = parameters["alpha"]/1e-3)

# Simpsin's rule
simpsons_rule <- function(f, lower, upper) {
  if (is.function(f) == FALSE) {
    stop('f must be a function with one parameter (variable)')
  }
  h <- (upper - lower) / 2
  x0 <- lower
  x1 <- lower + h
  x2 <- upper
  s <- (h / 3) * (f(x0) + 4 * f(x1) + f(x2))
  return(s)
}

simpsons_rule(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)

# pracma auadinf
pracma::quadinf(Vectorize(integrand), t-parameters["alpha"], t)$Q

# compare method speeds. Trapezoid fastest followed by Simpson's and R integrate
microbenchmark(integrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$value,
               cubature::adaptIntegrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$integral, foreach(i=1,.combine="c") %dopar%
{
  integrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)$value;
},
pracma::integral(Vectorize(integrand), xmin = t-parameters["alpha"], xmax = t, method = "Kronrod"),
pracma::integral(Vectorize(integrand), xmin = t-parameters["alpha"], xmax = t, method = "Clenshaw"),
pracma::integral(Vectorize(integrand), xmin = t-parameters["alpha"], xmax = t, method = "Simpson"),
trapezoid(Vectorize(integrand), lower = t-parameters["alpha"], upper = t), 
composite_trapezoid(Vectorize(integrand), lower = t-parameters["alpha"], upper = t, n = parameters["alpha"]/1e-3), 
simpsons_rule(Vectorize(integrand), lower = t-parameters["alpha"], upper = t), 
pracma::quadinf(Vectorize(integrand), t-parameters["alpha"], t)$Q, times = 1000L)
```

# rerunning immunity model and calculate run time
```{r}
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_i_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range)
ch_si_i_i_20.opt$par
stopCluster(cl) #1.769660 -363.080884  -37.980378    1.827227. Same as before
end.time <- Sys.time()
time.taken <- end.time - start.time 
time.taken #38.85414 (40 minutes!)
```

# optimizing pulsebeta function to vectorize
```{r}
# original pulse beta function
pulseBeta <- function(I0, sp, t){ 
    res = rep(NA, length(t))
    for (num in 1:length(t)){
      res[num] = I0*(dbeta(t[num], sp, sp))
    }
    return(res)}

# new pulse beta function
pulseBeta2 <- function(I0, sp, t){ 
    res = rep(NA, length(t))
    res = I0*(dbeta(t, sp, sp))
    }

# are they equal? Yes!
all.equal(pulseBeta2(48, 100, time_range), pulseBeta(48, 100, time_range))

# how should we call new function. Here dividng time by 1e-3 (time interval) and + 1 give us the proper index
test <- pulseBeta2(48, 100, time_range)
test[[(t/1e-3)+1]]

# plotting. We should see synchronous centering at 12 hours. Yes, it does
ggplot(data.frame(time_range, test)) +
  geom_line(aes(x = time_range, y = test)) +
  xlim(0,2)

# plotting asynchronous. All infected RBC must brst after 1 day. Matches up. 
ggplot(data.frame(time_range, test2 = pulseBeta2(48, 1, time_range))) +
  geom_line(aes(x = time_range, y = test2)) +
  xlim(0,2)
```

# testing new function that includes updated pulse-beta function and time-based cue
## without immunity, time-based. Looks good.
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_cpp.R")

# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_ni_t_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "ni",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range)

stopCluster(cl) 
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken #13 minutes, down from 40 minutes in original run and from 20 minutes in first iteration
ch_si_ni_t_20.opt$par #6.2932211 -15.3891982   0.3197596 -11.3816705. Similar to Greischar model

# plot
ch_si_ni_t_20_cr.df <- par_to_df(ch_si_ni_t_20.opt, time_range)
```

## with immunity. Different! Greischar model had much later trnamission investment. 
### plotting the cumulutive transmission potential suggests that my model should be correct... By my model, Greischar;s optimal strategy produced lower cumulative transmission potential than the one I found.
```{r}
# with immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.opt <- optimParallel(par = c(1,2,3,4), 
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range)

stopCluster(cl) 
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken #58.7155 minutes. Very long with lsoda and integrate function
ch_si_i_t_20.opt$par #10.948894 -23.608461  -1.903851 -17.421159. SLightly different from Greischar's model wonder why.
ch_si_i_t_20.opt$value #-11.96688. 

## plotting
ch_si_i_t_20_cr.df <- par_to_df(ch_si_i_t_20.opt, time_range)
### get greischar model parameters
ch_si_i_t_20.opt_gre <- ch_si_i_t_20.opt
ch_si_i_t_20.opt_gre$par <- c(13.46, -27.66, -3.62, -20.24)
ch_si_i_t_20_cr_gre.df <- par_to_df(ch_si_i_t_20.opt_gre, time_range)

### similar directions but Greischar model had even more delayed transmission investment. 
ggplot() +
  geom_line(data = ch_si_i_t_20_cr.df, aes(x = time_range, y = model), alpha = 0.7, color = "blue") +
  geom_line(data = ch_si_i_t_20_cr_gre.df, aes(x = time_range, y = model), alpha = 0.7, color = "red") +
  geom_line(data = ch_si_ni_t_20_cr.df, aes(x = time_range, y = model), alpha = 0.7, color = "black") +
    xlab("Time") +
    ylab("Transmission investment") +
    labs(color = "Optimization methods") +
    theme_bw()

parameters
```

## getting transmission value cumulative form greischar's parameters 11.87644 in Greischar model. Smaller than ours. Different model or something?
```{r}
cue_range <- time_range
immunity <- "i"
cue <- "t"
df <- 3

state <- c(R = 8.5*10^6,
             I = 43.85965,
             Ig = 0,
             M = 0,
             G = 0)


  pulseBeta_fun <- function(I0, sp, t){ 
    res = rep(NA, length(t))
    res = I0*(dbeta(t, sp, sp))
  }
  
  #-------------------------#
  # Define conversion rate function. 
  # Simplified to increase performance. 
  #------------------------#
  ## Define dummy data of conversion rate
  dummy_y.vals <- rep(0, length(cue_range)) 
  dummy_cr.data <- as.data.frame(cbind(cue_range, dummy_y.vals))
  
  ## fit basic cubic spline with no internal knots. Here, increasing df increases knots.
  ## degree defines shape of basis spline. This shouldn't have any impact on ultimate result
  ## What matter is the number of knots, or df. Increasing df should give us more complex reaction norm
  dummy_cr.mod <- lm(dummy_y.vals ~ splines2::bSpline(cue_range, degree = 3, df = df))
  dummy_cr.mod$data <- dummy_cr.data
  
  ## Assign coefficient to be optimized to the dummy conversion rate function
  dummy_cr.mod$coefficients <- c(13.46, -27.66, -3.62, -20.24)
  
  ## use spline function to predict cr 
  cr_fit <- exp(-exp(predict(dummy_cr.mod, newdata = data.frame(cue_range))))
  
  ## Get spline function where cr ~ cue
  cr <- splinefun(cbind(cue_range, cr_fit))
  
  #-------------------------#
  # Define trapezoidal estimation 
  # for survival function approximation. Use this if speeding up model
  #------------------------#
  trapezoid <- function(f, lower, upper) {
    if (is.function(f) == FALSE) {
      stop('f must be a function with one parameter (variable)')
    }
    h <- upper - lower
    fxdx <- (h / 2) * (f(lower) + f(upper))
    return(fxdx)}
  
  #-------------------------#
  # Define single-infection model
  #------------------------#
  single_infection.fun <- function(t, state, parameters) {
    
    ## Defining Pulse beta function based on current time
    pulseBeta <- pulseBeta_fun(parameters["I0"], parameters["sp"], t)
      
      ## Define the lag terms. lag[1] = R, lag[2] = I, lag[3] = Ig, lag[4] = M, lag[5] = G
      if(t>parameters["alpha"]){lag1 = deSolve::lagvalue(t-parameters["alpha"])} # lag state for asexual development
      if(t>parameters["alphag"]){lag2 = deSolve::lagvalue(t-parameters["alphag"])} # lag state for gametocyte development
      
      ## get lag term index given cue
    ### Only get lag index when it is a state-based cue
    if(cue != "t") {
      lag.i <- match(cue, names(state))}
    
     ## convert cue to variable in state or just time
    if(cue == "t"){
      cue_state <- t}
    else{
      cue_state <- state[cue]}
    
    ### define lagged cue. Lag1 = alpha times ago, lag2 = alphag times ago
    if(t>parameters["alpha"] && cue == "t"){
      cue_lag1 <- t-parameters["alpha"]
    } 
    
    if(t>parameters["alpha"] && cue != "t"){
      cue_lag1 <- lag1[lag.i]
    } 
    
    if(t>parameters["alphag"] && cue == "t") {
      cue_lag2 <- t-parameters["alphag"]
    } 
    
    if(t>parameters["alphag"] && cue != "t") {
      cue_lag2 <- lag2[lag.i]
    }
      
      ## Define K, carrying capacity of RBC
      K <- parameters["lambda"]*parameters["R1"]/(parameters["lambda"]-parameters["mu"]*parameters["R1"])
      
      ## Define survival functions
      ### Survival of infected asexual RBC
      if(t>parameters["alpha"] && immunity == "ni"){
        S <- exp(-parameters["mu"]*parameters["alpha"])
      } else if(t>parameters["alpha"] && immunity =="i"){
        integrand <- function(x) {parameters["mu"]+parameters["a"]/(parameters["b"]+state["I"])}
        integrate_val <- integrate(Vectorize(integrand), lower = t-parameters["alpha"], upper = t)
        S <- exp(-1*integrate_val$value)
      } else if(t<=parameters["alpha"] && immunity == "ni"){
        S <- exp(-parameters["mu"]*t)
      } else{
        integrand <- function(x) {parameters["mu"]+parameters["a"]/(parameters["b"]+state["I"])}
        integrate_val <- integrate(Vectorize(integrand), lower = 0, upper = t)
        S <- exp(-1*integrate_val$value)
      }
      
      ### Survival of gametocytes. We assume that infected
      ### RBC with gametocyte is not removed by immune response
      if(t<=parameters["alphag"]){
        Sg <- exp(-parameters["mu"]*t)
      } else{
        Sg <- exp(-parameters["mu"]*parameters["alphag"])}
      
      ## Define the models without lag terms. 
      dR <- parameters["lambda"]*(1-state["R"]/K)-parameters["mu"]*state["R"]-parameters["p"]*state["R"]*state["M"] # change in susceptible RBC
     
       if(immunity == "ni"){
        dI_nolag <- (1-cr(cue_state))*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["I"] # change in infected RBC density
      } else{
        dI_nolag <- (1-cr(cue_state))*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["I"]-(parameters["a"]*state["I"])/(parameters["b"]+state["I"]) # change in infected RBC density with immunity
      }
      
      dIg_nolag <- cr(cue_state)*parameters["p"]*state["R"]*state["M"]-parameters["mu"]*state["Ig"] 
      dM_nolag <- -parameters["mum"]*state["M"]-parameters["p"]*state["R"]*state["M"]
      dG_nolag <- -parameters["mug"]*state["G"]
      
      ## Track states in initial cohort of infection
      if(t<=parameters["alpha"]){
        dI <- dI_nolag-pulseBeta*S 
        dM <- dM_nolag+parameters["beta"]*pulseBeta*S 
      }
      
      if(t<=parameters["alphag"]){
        dIg <- dIg_nolag ## should have no cells form initial cohort
        dG <- 0
      }
      
      ## Track states after delay 
      if(t>parameters["alpha"]){
        dI <- dI_nolag-(1-cr(cue_lag1))*parameters["p"]*lag1[1]*lag1[4]*S 
        dM <- dM_nolag+parameters["beta"]*(1-cr(cue_lag1))*parameters["p"]*lag1[1]*lag1[4]*S 
      }
      
      if(t>parameters["alphag"]){
        dIg <- dIg_nolag-cr(cue_lag2)*parameters["p"]*lag2[1]*lag2[4]*Sg 
        dG <- dG_nolag+cr(cue_lag2)*parameters["p"]*lag2[1]*lag2[4]*Sg
      }
      
      ## Return the states
      return(list(c(dR, dI, dIg, dM, dG)))
  }
  
  #-------------------------#
  # Run single-infection model
  #------------------------#
  single_infection.df <- as.data.frame(deSolve::dede(y = state,
                                                     times = time_range,
                                                     func = single_infection.fun,
                                                     p = parameters,
                                                     method = solver,
                                                     control=list(mxhist = 1e6)))
  
#-------------------------#
  # Calculate fitness
  #------------------------#
  ## Get Gametocyte density time series data
  gam <- single_infection.df$G
  gam[gam<0] <- 0 # Assign negative gametocyte density to 0
  
  ## Get timeseries interval. Simplify first time after t=0
  int <- single_infection.df[2,1]
  
  ## Define the fitness parameter values
  aval <- -12.69
  bval <- 3.6
  dens <- log10(gam)
  
  ## Calculate the transmission potential at each time t
  tau.ls <- (exp(aval+bval*dens))/(1+exp(aval+bval*dens))
  
  ## Get approximation of cumulative transmission potential
  tau.sum <- sum(tau.ls*int)
  tau.cumsum <- cumsum(tau.ls*int)
  tau.sum
```

## check infection dynamics to see if same model.Seems to be the case...
```{r}
# tau cumulative sum. Looks very similar
ggplot(data.frame(time_range, tau.cumsum)) +
  geom_line(aes(time_range, tau.cumsum))

# plotting other stuff
single_infection.df2 <- single_infection.df %>% gather(key = "variable", value = "value", -time)

ggplot(single_infection.df2, aes(x = time, y = value)) +
  geom_line() +
  facet_wrap(~variable, scales = "free") +
  scale_y_continuous(labels = scales::scientific) +
  theme_bw()
```

## double check this is the case. I changed some stuff, fixed the conditional lag cue code. So rerun the code
### run with immunity
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_cpp.R")

# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.opt2 <- optimParallel(par = c(13, -25, -3, -20), # get it close so it runs faster
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range)

stopCluster(cl) 
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken # 31.47385 mins taken
ch_si_i_t_20.opt2$par #10.948492 -23.607393  -1.904272 -17.419994. Same as before. Sigh...

single_function.fun
```

## run with immunity + trapezoidal estimation for integration
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.opt_trap <- optimParallel(par = c(13, -25, -3, -20), # get it close so it runs faster
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range,
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #22.84097 minutes. Done from 31 minutes with integrate.
ch_si_i_t_20.opt_trap$par #10.94948 -23.60937  -1.90456 -17.42204 (very similar. insignificant difference)
```

## run with immunity + trapezoid+vode integration. Fastest run so far. 
```{r}
# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.opt_trap_vode <- optimParallel(par = c(13, -25, -3, -20), # get it close so it runs faster
                      fn = chabaudi_si_opt_cpp, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range,
                      integration = "trapezoid",
                      solver = "vode")
stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time # 6.682592 minutes. very fast
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.opt_trap_vode$par #10.947226 -23.605154  -1.902684 -17.423413 (very similar)
```

# fix death rate from immune response
## trying out other forms of immunity removal integration
```{r}
# calculate immune reaction based on non-immunity model
immune <- parameters["a"]/(parameters["b"]+single_infection.df$I)
immune_dummy <- data.frame(time_range, immune)
## calculate cumulative immune hazard rate for each time t (from t-alpha to t)
immune_dummy.df <- immune_dummy %>%
  mutate(cumsum = cumsum(immune)) %>%
  mutate(cum_rolling1000 = zoo::rollapplyr(immune*1e-3, width = 1000, FUN = sum, partial = TRUE)) %>%
  drop_na(cumsum)

# trying definite integral function
def_int <- data.frame(time_range, immune =(parameters["alpha"]*parameters["a"])/(parameters["b"]+single_infection.df$I))
 # trying definite integral function from 0 to alpha
def_int_init <- data.frame(time_range, immune = parameters["a"]*time_range/(parameters["b"]+single_infection.df$I))
  
# trying laplace
laplace <- data.frame(time_range, immune = (parameters["a"]*log10(single_infection.df$time+parameters["b"])-2*log10(single_infection.df$time-parameters["alpha"]))/single_infection.df$I)

# plotting. Definitive integral seem to match up pretty good. Of course...
ggplot() +
  geom_line(data = immune_dummy.df, aes(x = time_range, y = cum_rolling1000), color = "blue") + # OG
  geom_line(data = def_int, aes(x = time_range, y = immune), color = "red") + #valid after alpha
  geom_line(data = def_int_init, aes(x = time_range, y = immune), color = "dark red") + # valid before alpha
  geom_line(data = laplace, aes(x = time_range, y = immune), color = "green") +
  xlim(0, 20) + #applies to only after alpha
  theme_bw() +
  ylim(0,3)

def_int
immune_dummy.df
```

## test out function with immunity as definitive integral
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.def_int <- optimParallel(par = c(13, -25, -3, -20), # get it close so it runs faster
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range,
                      solver = "vode")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time#2.391554 minutes fast!
ch_si_i_t_20.def_int$par # 10.94816 -23.60684  -1.90449 -17.41818. Very similar to integrate. lol.... Still not replicating Greischar et al.

# plotting. Black is our and red is greischar model. Blue is without immunity
par_to_df(ch_si_i_t_20.def_int, time_range) %>% 
  ggplot(aes(x = cue_range, y = model)) +
  geom_line() +
  geom_line(data = ch_si_i_t_20_cr_gre.df, aes(x = time_range, y = model), alpha = 0.7, color = "red") +
  geom_line(data = ch_si_ni_t_20_cr.df, aes(x = time_range, y = model), alpha = 0.7, color = "blue") +
  theme_bw()

```

## changed dI condition to 2 ifs. Nope. doesn't make a difference
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

# no immunity run with time
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_t_20.dIif <- optimParallel(par = c(13, -25, -3, -20), # get it close so it runs faster
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "t",
                      cue_range = time_range,
                      solver = "vode")

stopCluster(cl) 
end.time <- Sys.time()

end.time-start.time #2.4 minutes
# 10.9482 -23.6068 -1.90449 -17.4182  still the same lol
```

# testing out infection dynamics simulation with new function
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

# run infection model using opt function. However, do not wrap around opt and set dyn = TRUE
ch_si_i_t_20.dyn <- chabaudi_si_opt_fast(parameters_cr = c(10.9482, -23.6068, -1.90449, -17.4182),
                                         immunity = "i",
                                         parameters = parameters,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "t",
                                         cue_range = time_range,
                                         solver = "lsoda",
                                         dyn = TRUE)


# get no immunity model to compare. Kind of different than greischar's case. huh.
ch_si_ni_t_20.dyn <- chabaudi_si_opt_fast(parameters_cr = c(6.2932211, -15.3891982,  0.3197596, -11.3816705),
                                         immunity = "ni",
                                         parameters = parameters,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "t",
                                         cue_range = time_range,
                                         solver = "vode",
                                         dyn = TRUE)

# plot. Red = no immunity. Blue = immunity
ggplot() +
  geom_line(data = ch_si_ni_t_20.dyn, aes(x = time, y = value), color = "red") +
  geom_line(data = ch_si_i_t_20.dyn, aes(x = time, y = value), color = "blue") +
  facet_wrap(~variable, scales = "free") +
  scale_y_continuous(labels = scales::label_scientific(digits = 2)) +
  theme_bw()

```

# testing out more complex models. Where cue is based on I
# redefine parameters
```{r}
parameters <- c(R1 = 8.5*10^6,
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 4*10^-6,
                alpha = 1, 
                alphag = 2, 
                beta = 10, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1)

time_range <- seq(0, 20, by = 1e-3)
cue_range <- seq(0, (3.7*10^5)*(8.5*10^6)/((3.7*10^5)-0.025*(8.5*10^6)), by = 1000) 
```

## Testing out higher df
```{r}
# df = 3
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_3 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "lsoda")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #10.50088 mins
ch_si_i_I_20.opt_3$par #1.7689113 -362.9437761  -26.2038195   -0.5623042 Slightly different than before with numerical integration...
#1.769660 -363.080884  -37.980378    1.827227

ch_si_i_I_20.opt_3$value #-11.63004
```

```{r}
# df = 4. Not able to converge with vode. Try lsoda which converged
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_4 <- optimParallel(par = rep(0.5, 5),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 4,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "lsoda")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time # 8.858414 mins from 0.5x5. Nice!
ch_si_i_I_20.opt_4$par #1.769130 -181.902327   33.287844    2.866469    0.500000


ch_si_i_I_20.opt_4$value #-11.63058
```


```{r}
# visualizing reaction norm. Big difference!
ch_si_i_I_20_3.cr <- par_to_df(ch_si_i_I_20.opt_3, cue_range)
ch_si_i_I_20_4.cr <- par_to_df(ch_si_i_I_20.opt_4, cue_range)

ggplot() +
  geom_line(data = ch_si_i_I_20_3.cr, aes(x = cue_range, y = cr), color = "black") +
  geom_line(data = ch_si_i_I_20_4.cr, aes(x = cue_range, y = cr), color = "blue")  +
  theme_bw()
```

# adjusting cue_range
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")
# first get basic infection simulation to see Infected RBC range. SEt this to max IRBC for constant investment

ch_si_i_I_20.dyn_3 <- chabaudi_si_opt_fast(parameters_cr = ch_si_i_I_20.opt_3$par,
                                         immunity = "i",
                                         parameters = parameters,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range,
                                         solver = "lsoda",
                                         dyn = TRUE)

ch_si_i_I_20.dyn_4 <- chabaudi_si_opt_fast(parameters_cr = ch_si_i_I_20.opt_4$par,
                                         immunity = "i",
                                         parameters = parameters,
                                         time_range = time_range,
                                         df = 4,
                                         cue = "I",
                                         cue_range = cue_range,
                                         solver = "lsoda",
                                         dyn = TRUE)

# plot
ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_3, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  scale_y_continuous(labels = scales::label_scientific(digits = 2)) +
  theme_bw()

# get range of I. Max at 55272.17078. Let's go slightly triple that @200000
range(ch_si_i_I_20.dyn_3 %>% 
  filter(variable == "I") %>% select(value))
```

# redo optimization with different cue_range
```{r}
# Define shorter range
cue_range2 <- seq(0, 2000000, by = 1000) ## shorter distance or else error

## sort of converged??
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_3_short <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range2,
                      solver = "lsoda")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #23.77503
ch_si_i_I_20.opt_3_short$par #1.808594  -73.232651 1251.575459 -133.909465
ch_si_i_I_20.opt_3_short$value #-11.79005 (higher)

# plot
ch_si_i_I_20_3_short.cr <- par_to_df(ch_si_i_I_20.opt_3_short, cue_range2)

# very different lol
ggplot() +
  geom_line(data = ch_si_i_I_20_3_short.cr, aes(x = cue_range, y = cr)) +
  theme_bw()
```

## looking at short_ranged byt with higher df
```{r}
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_4_short <- optimParallel(par = rep(0.5, 5),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "i",
                      parameters = parameters,
                      time_range = time_range,
                      df = 4,
                      cue = "I",
                      cue_range = cue_range2,
                      solver = "lsoda")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #29.59606 mins
ch_si_i_I_20.opt_4_short$par #2.076018 -22.471865 185.846543 -13.824956  27.202292
ch_si_i_I_20.opt_4_short$value #-11.73344

# plot
ch_si_i_I_20_4_short.cr <- par_to_df(ch_si_i_I_20.opt_4_short, cue_range2)

# lacks the terminal high that was shown in the 3 df model
ggplot() +
  geom_line(data = ch_si_i_I_20_4_short.cr, aes(x = cue_range, y = cr)) +
  theme_bw()
```


# plotting overall infection dynamics
```{r}
ch_si_i_I_20.dyn_3_short <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_3_short$par,
                                         immunity = "i",
                                         parameters = parameters,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range2,
                                         solver = "lsoda",
                                         dyn = TRUE)

ch_si_i_I_20.dyn_4_short <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_4_short$par,
                                         immunity = "i",
                                         parameters = parameters,
                                         time_range = time_range,
                                         df = 4,
                                         cue = "I",
                                         cue_range = cue_range2,
                                         solver = "lsoda",
                                         dyn = TRUE)

# compare black = across K optimization, red = 0 to 2000000 optimization. Very different. Blue is time based approach. Overall parasite density is much lower in I-based cue models. The "peak" of iRBC also is reached much earlier in our model (although we have that range spike at the end of infection). The earlier timing is much more reminiscent of typical P. chabaudi infection (which peaks around 6-8 days). Most infection exhibits a unimodel distribution, which our models does not have. This could be due to lack of adaptive immune reaction, which kicks in around 5 days??

## when CR ~ time, population growth seems to be bottom-up (where paratemesia is governed by RBC availability). This does occur in models however, much earlier

## when we do df = 4 for shorter cue_range, we also see a semi peak at around 15 days and subsequent decline in iRBC count due to RBC non-avaiability. Need better immune reaction
ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_4, aes(x = time, y = value), color = "black") +
  #geom_line(data = ch_si_i_I_20.dyn_3_short, aes(x = time, y = value), color = "red") +
  geom_line(data = ch_si_i_I_20.dyn_4_short, aes(x = time, y = value), color = "green") +
  geom_line(data = ch_si_i_t_20.dyn, aes(x = time, y = value), color = "blue") +
  facet_wrap(~variable, scales = "free") +
  #scale_y_continuous(labels = scales::label_scientific(digits = 2)) +
  theme_bw()

```

# Trying different immunity models!
## Kochin's innate immunity
## Very similar results. For some reason, targetted innate immunity is not sufficient. We might need to incorporate indescriminate killing as part of that.
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_imm.R")

# set different parameters
parameters_kochin <- c(R1 = 8.89*10^6,
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 4*10^-6,
                alpha = 1, 
                alphag = 2, 
                beta = 10, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                sigma = 1.17*10^-8,
                mue = 0.3,
                gamma = 133)
  
  
start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_kochin_3 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_imm, 
                      control = list(trace = 6),
                      immunity = "kochin",
                      parameters = parameters_kochin,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "lsoda",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #27.29253 mins
ch_si_i_I_20.opt_kochin_3$par #1.5364718 -301.1007836   -3.1754708    0.5604894
ch_si_i_I_20.opt_kochin_3$value #-12.69556

# plotting cr
ch_si_i_I_20_kochin_3.cr <- par_to_df(ch_si_i_I_20.opt_kochin_3, cue_range)

ggplot() +
  geom_line(data = ch_si_i_I_20_kochin_3.cr, aes(x = cue_range, y = cr)) +
  xlim(0, 500000) +
  theme_bw()

# plotting df
ch_si_i_I_20.dyn_kochin_3 <- chabaudi_si_opt_imm(
  parameters_cr = ch_si_i_I_20.opt_kochin_3$par,
                                         immunity = "kochin",
                                         parameters = parameters_kochin,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range,
                                         solver = "lsoda",
                                         dyn = TRUE,
  integration = "trapezoid")

ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_kochin_3, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```



## Adding indescriminant removal of RBC using tsukushi'd model
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")
## Warning consider changing certain parameter values to the ones Tsukushi used
## Estimated using adobe illustrator lol
parameters_tsukushi <- c(R1 = 8.5*10^6,
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 4*10^-6,
                alpha = 1, 
                alphag = 2, 
                beta = 10, 
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 17.65,
                psiw = 1,
                phin = 28.5175,
                phiw = 552.178,
                iota = (10^4)/(2.18*(10^6)))

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_3 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "lsoda",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #3.825459 mins
ch_si_i_I_20.opt_tsukushi_3$par #0.5462002 0.4996780 0.5000022 0.5000017
ch_si_i_I_20.opt_tsukushi_3$value #-0.02495789

# plotting cr vs cue
ch_si_i_I_20_tsukushi_3.cr <- par_to_df(ch_si_i_I_20.opt_tsukushi_3, cue_range)

ggplot() +
  geom_line(data = ch_si_i_I_20_tsukushi_3.cr, aes(x = cue_range, y = cr)) +
  theme_bw()

# plotting infection dynamics
ch_si_i_I_20.dyn_tsukushi_3 <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_3$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range,
                                         solver = "lsoda",
                                         dyn = TRUE,
  integration = "trapezoid")

 # All RBC dead lol
ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_3, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

## Need to add in replenishment rate that increases with deviation
## testing with new parameter set. Changed dR dt and added in Rho. Much better. Seems to simulate actual infection dynamics captured in experiments. The conversion rate is also much lower. 
```{r}
setwd("/Users/avrilwang/Desktop/Project_Plasmodium/functions")
source("chabaudi_si_opt_fast.R")

parameters_tsukushi2 <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 8.55, # approximate
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 17.65,
                psiw = 1,
                phin = 28.5175,
                phiw = 552.178,
                iota = (10^4)/(2.18*(10^6)), # please surround with bracket. Or else R does wrong calculation
                rho = 0.263)

start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_3 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi2,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "lsoda",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()
end.time-start.time #15.07049 mins
ch_si_i_I_20.opt_tsukushi_3$par #1.1772653 -30.2704138   0.3361028   0.5065292
ch_si_i_I_20.opt_tsukushi_3$value #-7.002037. Lower than before.

# plotting best strategy
ch_si_i_I_20_tsukushi_3.cr <- par_to_df(ch_si_i_I_20.opt_tsukushi_3, cue_range)

ggplot() +
  geom_line(data = ch_si_i_I_20_tsukushi_3.cr, aes(x = cue_range, y = cr)) +
  theme_bw()

# plotting infection dynamics
ch_si_i_I_20.dyn_tsukushi_3 <- chabaudi_si_opt_fast(
  parameters_cr = ch_si_i_I_20.opt_tsukushi_3$par,
                                         immunity = "tsukushi",
                                         parameters = parameters_tsukushi2,
                                         time_range = time_range,
                                         df = 3,
                                         cue = "I",
                                         cue_range = cue_range,
                                         solver = "lsoda",
                                         dyn = TRUE,
  integration = "trapezoid")

# Interesting pattern. Seems to replicate typical infection dynamics
ggplot() +
  geom_line(data = ch_si_i_I_20.dyn_tsukushi_3, aes(x = time, y = value), color = "black") +
  facet_wrap(~variable, scales = "free") +
  theme_bw()
```

# try with negative phin
```{r}
parameters_tsukushi3 <- c(R1 = 8.89*10^6, # slightly higher
                lambda = 3.7*10^5,
                mu = 0.025, 
                p = 8*10^-6, # doubled form original
                alpha = 1, 
                alphag = 2, 
                beta = 8.55, # approximate
                mum = 48, 
                mug = 4, 
                I0 = 43.85965, 
                Ig0 = 0, 
                a = 150, 
                b = 100, 
                sp = 1,
                psin = 17.65,
                psiw = 1,
                phin = 0.035, # changed if negative
                phiw = 552.178,
                iota = (10^4)/(2.18*(10^6)), # please surround with bracket. Or else R does wrong calculation
                rho = 0.263)


start.time <- Sys.time()
cl <- makeCluster(detectCores()); setDefaultCluster(cl = cl)
ch_si_i_I_20.opt_tsukushi_3_phin2 <- optimParallel(par = rep(0.5, 4),# new parameter search space
                      fn = chabaudi_si_opt_fast, 
                      control = list(trace = 6),
                      immunity = "tsukushi",
                      parameters = parameters_tsukushi3,
                      time_range = time_range,
                      df = 3,
                      cue = "I",
                      cue_range = cue_range,
                      solver = "lsoda",
                      integration = "trapezoid")

stopCluster(cl) 
end.time <- Sys.time()

```






